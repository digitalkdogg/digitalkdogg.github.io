(function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define([], factory); else if(typeof exports === 'object') exports["Babel"] = factory(); else root["Babel"] = factory(); })(this, function() { return /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ // __webpack_public_path__ /******/ __webpack_require__.p = ""; /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ((function(modules) { // Check all modules for deduplicated modules for(var i in modules) { if(Object.prototype.hasOwnProperty.call(modules, i)) { switch(typeof modules[i]) { case "function": break; case "object": // Module can be created from a template modules[i] = (function(_m) { var args = _m.slice(1), fn = modules[_m[0]]; return function (a,b,c) { fn.apply(this, [a,b,c].concat(args)); }; }(modules[i])); break; default: // Module is a copy of another module modules[i] = modules[modules[i]]; break; } } } return modules; }([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); exports.version = exports.buildExternalHelpers = exports.availablePresets = exports.availablePlugins = undefined; var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; exports.transform = transform; exports.transformFromAst = transformFromAst; exports.registerPlugin = registerPlugin; exports.registerPlugins = registerPlugins; exports.registerPreset = registerPreset; exports.registerPresets = registerPresets; exports.transformScriptTags = transformScriptTags; exports.disableScriptTags = disableScriptTags; var _babelCore = __webpack_require__(290); var Babel = _interopRequireWildcard(_babelCore); var _transformScriptTags = __webpack_require__(629); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } var isArray = Array.isArray || function (arg) { return Object.prototype.toString.call(arg) === '[object Array]'; }; /** * Loads the given name (or [name, options] pair) from the given table object * holding the available presets or plugins. * * Returns undefined if the preset or plugin is not available; passes through * name unmodified if it (or the first element of the pair) is not a string. */ function loadBuiltin(builtinTable, name) { if (isArray(name) && typeof name[0] === 'string') { if (builtinTable.hasOwnProperty(name[0])) { return [builtinTable[name[0]]].concat(name.slice(1)); } return; } else if (typeof name === 'string') { return builtinTable[name]; } // Could be an actual preset/plugin module return name; } /** * Parses plugin names and presets from the specified options. */ function processOptions(options) { // Parse preset names var presets = (options.presets || []).map(function (presetName) { var preset = loadBuiltin(availablePresets, presetName); if (preset) { // workaround for babel issue // at some point, babel copies the preset, losing the non-enumerable // buildPreset key; convert it into an enumerable key. if (isArray(preset) && _typeof(preset[0]) === 'object' && preset[0].hasOwnProperty('buildPreset')) { preset[0] = _extends({}, preset[0], { buildPreset: preset[0].buildPreset }); } } else { throw new Error('Invalid preset specified in Babel options: "' + presetName + '"'); } return preset; }); // Parse plugin names var plugins = (options.plugins || []).map(function (pluginName) { var plugin = loadBuiltin(availablePlugins, pluginName); if (!plugin) { throw new Error('Invalid plugin specified in Babel options: "' + pluginName + '"'); } return plugin; }); return _extends({ babelrc: false }, options, { presets: presets, plugins: plugins }); } function transform(code, options) { return Babel.transform(code, processOptions(options)); } function transformFromAst(ast, code, options) { return Babel.transformFromAst(ast, code, processOptions(options)); } var availablePlugins = exports.availablePlugins = {}; var availablePresets = exports.availablePresets = {}; var buildExternalHelpers = exports.buildExternalHelpers = Babel.buildExternalHelpers; /** * Registers a named plugin for use with Babel. */ function registerPlugin(name, plugin) { if (availablePlugins.hasOwnProperty(name)) { console.warn('A plugin named "' + name + '" is already registered, it will be overridden'); } availablePlugins[name] = plugin; } /** * Registers multiple plugins for use with Babel. `newPlugins` should be an object where the key * is the name of the plugin, and the value is the plugin itself. */ function registerPlugins(newPlugins) { Object.keys(newPlugins).forEach(function (name) { return registerPlugin(name, newPlugins[name]); }); } /** * Registers a named preset for use with Babel. */ function registerPreset(name, preset) { if (availablePresets.hasOwnProperty(name)) { console.warn('A preset named "' + name + '" is already registered, it will be overridden'); } availablePresets[name] = preset; } /** * Registers multiple presets for use with Babel. `newPresets` should be an object where the key * is the name of the preset, and the value is the preset itself. */ function registerPresets(newPresets) { Object.keys(newPresets).forEach(function (name) { return registerPreset(name, newPresets[name]); }); } // All the plugins we should bundle registerPlugins({ 'check-es2015-constants': __webpack_require__(66), 'external-helpers': __webpack_require__(322), 'inline-replace-variables': __webpack_require__(323), 'syntax-async-functions': __webpack_require__(67), 'syntax-async-generators': __webpack_require__(195), 'syntax-class-constructor-call': __webpack_require__(196), 'syntax-class-properties': __webpack_require__(197), 'syntax-decorators': __webpack_require__(125), 'syntax-do-expressions': __webpack_require__(198), 'syntax-exponentiation-operator': __webpack_require__(199), 'syntax-export-extensions': __webpack_require__(200), 'syntax-flow': __webpack_require__(126), 'syntax-function-bind': __webpack_require__(201), 'syntax-function-sent': __webpack_require__(325), 'syntax-jsx': __webpack_require__(127), 'syntax-object-rest-spread': __webpack_require__(202), 'syntax-trailing-function-commas': __webpack_require__(128), 'transform-async-functions': __webpack_require__(326), 'transform-async-to-generator': __webpack_require__(129), 'transform-async-to-module-method': __webpack_require__(328), 'transform-class-constructor-call': __webpack_require__(203), 'transform-class-properties': __webpack_require__(204), 'transform-decorators': __webpack_require__(205), 'transform-decorators-legacy': __webpack_require__(329).default, // <- No clue. Nope. 'transform-do-expressions': __webpack_require__(206), 'transform-es2015-arrow-functions': __webpack_require__(68), 'transform-es2015-block-scoped-functions': __webpack_require__(69), 'transform-es2015-block-scoping': __webpack_require__(70), 'transform-es2015-classes': __webpack_require__(71), 'transform-es2015-computed-properties': __webpack_require__(72), 'transform-es2015-destructuring': __webpack_require__(73), 'transform-es2015-duplicate-keys': __webpack_require__(130), 'transform-es2015-for-of': __webpack_require__(74), 'transform-es2015-function-name': __webpack_require__(75), 'transform-es2015-instanceof': __webpack_require__(332), 'transform-es2015-literals': __webpack_require__(76), 'transform-es2015-modules-amd': __webpack_require__(131), 'transform-es2015-modules-commonjs': __webpack_require__(77), 'transform-es2015-modules-systemjs': __webpack_require__(208), 'transform-es2015-modules-umd': __webpack_require__(209), 'transform-es2015-object-super': __webpack_require__(78), 'transform-es2015-parameters': __webpack_require__(79), 'transform-es2015-shorthand-properties': __webpack_require__(80), 'transform-es2015-spread': __webpack_require__(81), 'transform-es2015-sticky-regex': __webpack_require__(82), 'transform-es2015-template-literals': __webpack_require__(83), 'transform-es2015-typeof-symbol': __webpack_require__(84), 'transform-es2015-unicode-regex': __webpack_require__(85), 'transform-es3-member-expression-literals': __webpack_require__(336), 'transform-es3-property-literals': __webpack_require__(337), 'transform-es5-property-mutators': __webpack_require__(338), 'transform-eval': __webpack_require__(339), 'transform-exponentiation-operator': __webpack_require__(132), 'transform-export-extensions': __webpack_require__(210), 'transform-flow-comments': __webpack_require__(340), 'transform-flow-strip-types': __webpack_require__(211), 'transform-function-bind': __webpack_require__(212), 'transform-jscript': __webpack_require__(341), 'transform-object-assign': __webpack_require__(342), 'transform-object-rest-spread': __webpack_require__(213), 'transform-object-set-prototype-of-to-assign': __webpack_require__(343), 'transform-proto-to-assign': __webpack_require__(344), 'transform-react-constant-elements': __webpack_require__(345), 'transform-react-display-name': __webpack_require__(214), 'transform-react-inline-elements': __webpack_require__(346), 'transform-react-jsx': __webpack_require__(215), 'transform-react-jsx-compat': __webpack_require__(347), 'transform-react-jsx-self': __webpack_require__(349), 'transform-react-jsx-source': __webpack_require__(350), 'transform-regenerator': __webpack_require__(86), 'transform-runtime': __webpack_require__(353), 'transform-strict-mode': __webpack_require__(216), 'undeclared-variables-check': __webpack_require__(354) }); // All the presets we should bundle registerPresets({ es2015: __webpack_require__(217), es2016: __webpack_require__(218), es2017: __webpack_require__(219), latest: __webpack_require__(356), react: __webpack_require__(357), 'stage-0': __webpack_require__(358), 'stage-1': __webpack_require__(220), 'stage-2': __webpack_require__(221), 'stage-3': __webpack_require__(222), // ES2015 preset with es2015-modules-commonjs removed // Plugin list copied from babel-preset-es2015/index.js 'es2015-no-commonjs': { plugins: [__webpack_require__(83), __webpack_require__(76), __webpack_require__(75), __webpack_require__(68), __webpack_require__(69), __webpack_require__(71), __webpack_require__(78), __webpack_require__(80), __webpack_require__(72), __webpack_require__(74), __webpack_require__(82), __webpack_require__(85), __webpack_require__(66), __webpack_require__(81), __webpack_require__(79), __webpack_require__(73), __webpack_require__(70), __webpack_require__(84), [__webpack_require__(86), { async: false, asyncGenerators: false }]] }, // ES2015 preset with plugins set to loose mode. // Based off https://github.com/bkonkle/babel-preset-es2015-loose/blob/master/index.js 'es2015-loose': { plugins: [[__webpack_require__(83), { loose: true }], __webpack_require__(76), __webpack_require__(75), __webpack_require__(68), __webpack_require__(69), [__webpack_require__(71), { loose: true }], __webpack_require__(78), __webpack_require__(80), __webpack_require__(130), [__webpack_require__(72), { loose: true }], [__webpack_require__(74), { loose: true }], __webpack_require__(82), __webpack_require__(85), __webpack_require__(66), [__webpack_require__(81), { loose: true }], __webpack_require__(79), [__webpack_require__(73), { loose: true }], __webpack_require__(70), __webpack_require__(84), [__webpack_require__(77), { loose: true }], [__webpack_require__(86), { async: false, asyncGenerators: false }]] } }); var version = exports.version = ("6.26.0"); // Listen for load event if we're in a browser and then kick off finding and // running of scripts with "text/babel" type. if (typeof window !== 'undefined' && window && window.addEventListener) { window.addEventListener('DOMContentLoaded', function () { return transformScriptTags(); }, false); } /** * Transform <script> tags with "text/babel" type. * @param {Array} scriptTags specify script tags to transform, transform all in the <head> if not given */ function transformScriptTags(scriptTags) { (0, _transformScriptTags.runScripts)(transform, scriptTags); } /** * Disables automatic transformation of <script> tags with "text/babel" type. */ function disableScriptTags() { window.removeEventListener('DOMContentLoaded', transformScriptTags); } /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.createTypeAnnotationBasedOnTypeof = exports.removeTypeDuplicates = exports.createUnionTypeAnnotation = exports.valueToNode = exports.toBlock = exports.toExpression = exports.toStatement = exports.toBindingIdentifierName = exports.toIdentifier = exports.toKeyAlias = exports.toSequenceExpression = exports.toComputedKey = exports.isNodesEquivalent = exports.isImmutable = exports.isScope = exports.isSpecifierDefault = exports.isVar = exports.isBlockScoped = exports.isLet = exports.isValidIdentifier = exports.isReferenced = exports.isBinding = exports.getOuterBindingIdentifiers = exports.getBindingIdentifiers = exports.TYPES = exports.react = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined; var _getOwnPropertySymbols = __webpack_require__(360); var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols); var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _keys = __webpack_require__(14); var _keys2 = _interopRequireDefault(_keys); var _stringify = __webpack_require__(35); var _stringify2 = _interopRequireDefault(_stringify); var _constants = __webpack_require__(135); Object.defineProperty(exports, "STATEMENT_OR_BLOCK_KEYS", { enumerable: true, get: function get() { return _constants.STATEMENT_OR_BLOCK_KEYS; } }); Object.defineProperty(exports, "FLATTENABLE_KEYS", { enumerable: true, get: function get() { return _constants.FLATTENABLE_KEYS; } }); Object.defineProperty(exports, "FOR_INIT_KEYS", { enumerable: true, get: function get() { return _constants.FOR_INIT_KEYS; } }); Object.defineProperty(exports, "COMMENT_KEYS", { enumerable: true, get: function get() { return _constants.COMMENT_KEYS; } }); Object.defineProperty(exports, "LOGICAL_OPERATORS", { enumerable: true, get: function get() { return _constants.LOGICAL_OPERATORS; } }); Object.defineProperty(exports, "UPDATE_OPERATORS", { enumerable: true, get: function get() { return _constants.UPDATE_OPERATORS; } }); Object.defineProperty(exports, "BOOLEAN_NUMBER_BINARY_OPERATORS", { enumerable: true, get: function get() { return _constants.BOOLEAN_NUMBER_BINARY_OPERATORS; } }); Object.defineProperty(exports, "EQUALITY_BINARY_OPERATORS", { enumerable: true, get: function get() { return _constants.EQUALITY_BINARY_OPERATORS; } }); Object.defineProperty(exports, "COMPARISON_BINARY_OPERATORS", { enumerable: true, get: function get() { return _constants.COMPARISON_BINARY_OPERATORS; } }); Object.defineProperty(exports, "BOOLEAN_BINARY_OPERATORS", { enumerable: true, get: function get() { return _constants.BOOLEAN_BINARY_OPERATORS; } }); Object.defineProperty(exports, "NUMBER_BINARY_OPERATORS", { enumerable: true, get: function get() { return _constants.NUMBER_BINARY_OPERATORS; } }); Object.defineProperty(exports, "BINARY_OPERATORS", { enumerable: true, get: function get() { return _constants.BINARY_OPERATORS; } }); Object.defineProperty(exports, "BOOLEAN_UNARY_OPERATORS", { enumerable: true, get: function get() { return _constants.BOOLEAN_UNARY_OPERATORS; } }); Object.defineProperty(exports, "NUMBER_UNARY_OPERATORS", { enumerable: true, get: function get() { return _constants.NUMBER_UNARY_OPERATORS; } }); Object.defineProperty(exports, "STRING_UNARY_OPERATORS", { enumerable: true, get: function get() { return _constants.STRING_UNARY_OPERATORS; } }); Object.defineProperty(exports, "UNARY_OPERATORS", { enumerable: true, get: function get() { return _constants.UNARY_OPERATORS; } }); Object.defineProperty(exports, "INHERIT_KEYS", { enumerable: true, get: function get() { return _constants.INHERIT_KEYS; } }); Object.defineProperty(exports, "BLOCK_SCOPED_SYMBOL", { enumerable: true, get: function get() { return _constants.BLOCK_SCOPED_SYMBOL; } }); Object.defineProperty(exports, "NOT_LOCAL_BINDING", { enumerable: true, get: function get() { return _constants.NOT_LOCAL_BINDING; } }); exports.is = is; exports.isType = isType; exports.validate = validate; exports.shallowEqual = shallowEqual; exports.appendToMemberExpression = appendToMemberExpression; exports.prependToMemberExpression = prependToMemberExpression; exports.ensureBlock = ensureBlock; exports.clone = clone; exports.cloneWithoutLoc = cloneWithoutLoc; exports.cloneDeep = cloneDeep; exports.buildMatchMemberExpression = buildMatchMemberExpression; exports.removeComments = removeComments; exports.inheritsComments = inheritsComments; exports.inheritTrailingComments = inheritTrailingComments; exports.inheritLeadingComments = inheritLeadingComments; exports.inheritInnerComments = inheritInnerComments; exports.inherits = inherits; exports.assertNode = assertNode; exports.isNode = isNode; exports.traverseFast = traverseFast; exports.removeProperties = removeProperties; exports.removePropertiesDeep = removePropertiesDeep; var _retrievers = __webpack_require__(226); Object.defineProperty(exports, "getBindingIdentifiers", { enumerable: true, get: function get() { return _retrievers.getBindingIdentifiers; } }); Object.defineProperty(exports, "getOuterBindingIdentifiers", { enumerable: true, get: function get() { return _retrievers.getOuterBindingIdentifiers; } }); var _validators = __webpack_require__(395); Object.defineProperty(exports, "isBinding", { enumerable: true, get: function get() { return _validators.isBinding; } }); Object.defineProperty(exports, "isReferenced", { enumerable: true, get: function get() { return _validators.isReferenced; } }); Object.defineProperty(exports, "isValidIdentifier", { enumerable: true, get: function get() { return _validators.isValidIdentifier; } }); Object.defineProperty(exports, "isLet", { enumerable: true, get: function get() { return _validators.isLet; } }); Object.defineProperty(exports, "isBlockScoped", { enumerable: true, get: function get() { return _validators.isBlockScoped; } }); Object.defineProperty(exports, "isVar", { enumerable: true, get: function get() { return _validators.isVar; } }); Object.defineProperty(exports, "isSpecifierDefault", { enumerable: true, get: function get() { return _validators.isSpecifierDefault; } }); Object.defineProperty(exports, "isScope", { enumerable: true, get: function get() { return _validators.isScope; } }); Object.defineProperty(exports, "isImmutable", { enumerable: true, get: function get() { return _validators.isImmutable; } }); Object.defineProperty(exports, "isNodesEquivalent", { enumerable: true, get: function get() { return _validators.isNodesEquivalent; } }); var _converters = __webpack_require__(385); Object.defineProperty(exports, "toComputedKey", { enumerable: true, get: function get() { return _converters.toComputedKey; } }); Object.defineProperty(exports, "toSequenceExpression", { enumerable: true, get: function get() { return _converters.toSequenceExpression; } }); Object.defineProperty(exports, "toKeyAlias", { enumerable: true, get: function get() { return _converters.toKeyAlias; } }); Object.defineProperty(exports, "toIdentifier", { enumerable: true, get: function get() { return _converters.toIdentifier; } }); Object.defineProperty(exports, "toBindingIdentifierName", { enumerable: true, get: function get() { return _converters.toBindingIdentifierName; } }); Object.defineProperty(exports, "toStatement", { enumerable: true, get: function get() { return _converters.toStatement; } }); Object.defineProperty(exports, "toExpression", { enumerable: true, get: function get() { return _converters.toExpression; } }); Object.defineProperty(exports, "toBlock", { enumerable: true, get: function get() { return _converters.toBlock; } }); Object.defineProperty(exports, "valueToNode", { enumerable: true, get: function get() { return _converters.valueToNode; } }); var _flow = __webpack_require__(393); Object.defineProperty(exports, "createUnionTypeAnnotation", { enumerable: true, get: function get() { return _flow.createUnionTypeAnnotation; } }); Object.defineProperty(exports, "removeTypeDuplicates", { enumerable: true, get: function get() { return _flow.removeTypeDuplicates; } }); Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function get() { return _flow.createTypeAnnotationBasedOnTypeof; } }); var _toFastProperties = __webpack_require__(624); var _toFastProperties2 = _interopRequireDefault(_toFastProperties); var _clone = __webpack_require__(109); var _clone2 = _interopRequireDefault(_clone); var _uniq = __webpack_require__(600); var _uniq2 = _interopRequireDefault(_uniq); __webpack_require__(390); var _definitions = __webpack_require__(26); var _react2 = __webpack_require__(394); var _react = _interopRequireWildcard(_react2); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var t = exports; function registerType(type) { var is = t["is" + type]; if (!is) { is = t["is" + type] = function (node, opts) { return t.is(type, node, opts); }; } t["assert" + type] = function (node, opts) { opts = opts || {}; if (!is(node, opts)) { throw new Error("Expected type " + (0, _stringify2.default)(type) + " with option " + (0, _stringify2.default)(opts)); } }; } exports.VISITOR_KEYS = _definitions.VISITOR_KEYS; exports.ALIAS_KEYS = _definitions.ALIAS_KEYS; exports.NODE_FIELDS = _definitions.NODE_FIELDS; exports.BUILDER_KEYS = _definitions.BUILDER_KEYS; exports.DEPRECATED_KEYS = _definitions.DEPRECATED_KEYS; exports.react = _react; for (var type in t.VISITOR_KEYS) { registerType(type); } t.FLIPPED_ALIAS_KEYS = {}; (0, _keys2.default)(t.ALIAS_KEYS).forEach(function (type) { t.ALIAS_KEYS[type].forEach(function (alias) { var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || []; types.push(type); }); }); (0, _keys2.default)(t.FLIPPED_ALIAS_KEYS).forEach(function (type) { t[type.toUpperCase() + "_TYPES"] = t.FLIPPED_ALIAS_KEYS[type]; registerType(type); }); var TYPES = exports.TYPES = (0, _keys2.default)(t.VISITOR_KEYS).concat((0, _keys2.default)(t.FLIPPED_ALIAS_KEYS)).concat((0, _keys2.default)(t.DEPRECATED_KEYS)); function is(type, node, opts) { if (!node) return false; var matches = isType(node.type, type); if (!matches) return false; if (typeof opts === "undefined") { return true; } else { return t.shallowEqual(node, opts); } } function isType(nodeType, targetType) { if (nodeType === targetType) return true; if (t.ALIAS_KEYS[targetType]) return false; var aliases = t.FLIPPED_ALIAS_KEYS[targetType]; if (aliases) { if (aliases[0] === nodeType) return true; for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var alias = _ref; if (nodeType === alias) return true; } } return false; } (0, _keys2.default)(t.BUILDER_KEYS).forEach(function (type) { var keys = t.BUILDER_KEYS[type]; function builder() { if (arguments.length > keys.length) { throw new Error("t." + type + ": Too many arguments passed. Received " + arguments.length + " but can receive " + ("no more than " + keys.length)); } var node = {}; node.type = type; var i = 0; for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var _key = _ref2; var field = t.NODE_FIELDS[type][_key]; var arg = arguments[i++]; if (arg === undefined) arg = (0, _clone2.default)(field.default); node[_key] = arg; } for (var key in node) { validate(node, key, node[key]); } return node; } t[type] = builder; t[type[0].toLowerCase() + type.slice(1)] = builder; }); var _loop = function _loop(_type) { var newType = t.DEPRECATED_KEYS[_type]; function proxy(fn) { return function () { console.trace("The node type " + _type + " has been renamed to " + newType); return fn.apply(this, arguments); }; } t[_type] = t[_type[0].toLowerCase() + _type.slice(1)] = proxy(t[newType]); t["is" + _type] = proxy(t["is" + newType]); t["assert" + _type] = proxy(t["assert" + newType]); }; for (var _type in t.DEPRECATED_KEYS) { _loop(_type); } function validate(node, key, val) { if (!node) return; var fields = t.NODE_FIELDS[node.type]; if (!fields) return; var field = fields[key]; if (!field || !field.validate) return; if (field.optional && val == null) return; field.validate(node, key, val); } function shallowEqual(actual, expected) { var keys = (0, _keys2.default)(expected); for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) { var _ref3; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref3 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref3 = _i3.value; } var key = _ref3; if (actual[key] !== expected[key]) { return false; } } return true; } function appendToMemberExpression(member, append, computed) { member.object = t.memberExpression(member.object, member.property, member.computed); member.property = append; member.computed = !!computed; return member; } function prependToMemberExpression(member, prepend) { member.object = t.memberExpression(prepend, member.object); return member; } function ensureBlock(node) { var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "body"; return node[key] = t.toBlock(node[key], node); } function clone(node) { if (!node) return node; var newNode = {}; for (var key in node) { if (key[0] === "_") continue; newNode[key] = node[key]; } return newNode; } function cloneWithoutLoc(node) { var newNode = clone(node); delete newNode.loc; return newNode; } function cloneDeep(node) { if (!node) return node; var newNode = {}; for (var key in node) { if (key[0] === "_") continue; var val = node[key]; if (val) { if (val.type) { val = t.cloneDeep(val); } else if (Array.isArray(val)) { val = val.map(t.cloneDeep); } } newNode[key] = val; } return newNode; } function buildMatchMemberExpression(match, allowPartial) { var parts = match.split("."); return function (member) { if (!t.isMemberExpression(member)) return false; var search = [member]; var i = 0; while (search.length) { var node = search.shift(); if (allowPartial && i === parts.length) { return true; } if (t.isIdentifier(node)) { if (parts[i] !== node.name) return false; } else if (t.isStringLiteral(node)) { if (parts[i] !== node.value) return false; } else if (t.isMemberExpression(node)) { if (node.computed && !t.isStringLiteral(node.property)) { return false; } else { search.push(node.object); search.push(node.property); continue; } } else { return false; } if (++i > parts.length) { return false; } } return true; }; } function removeComments(node) { for (var _iterator4 = t.COMMENT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) { var _ref4; if (_isArray4) { if (_i4 >= _iterator4.length) break; _ref4 = _iterator4[_i4++]; } else { _i4 = _iterator4.next(); if (_i4.done) break; _ref4 = _i4.value; } var key = _ref4; delete node[key]; } return node; } function inheritsComments(child, parent) { inheritTrailingComments(child, parent); inheritLeadingComments(child, parent); inheritInnerComments(child, parent); return child; } function inheritTrailingComments(child, parent) { _inheritComments("trailingComments", child, parent); } function inheritLeadingComments(child, parent) { _inheritComments("leadingComments", child, parent); } function inheritInnerComments(child, parent) { _inheritComments("innerComments", child, parent); } function _inheritComments(key, child, parent) { if (child && parent) { child[key] = (0, _uniq2.default)([].concat(child[key], parent[key]).filter(Boolean)); } } function inherits(child, parent) { if (!child || !parent) return child; for (var _iterator5 = t.INHERIT_KEYS.optional, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) { var _ref5; if (_isArray5) { if (_i5 >= _iterator5.length) break; _ref5 = _iterator5[_i5++]; } else { _i5 = _iterator5.next(); if (_i5.done) break; _ref5 = _i5.value; } var _key2 = _ref5; if (child[_key2] == null) { child[_key2] = parent[_key2]; } } for (var key in parent) { if (key[0] === "_") child[key] = parent[key]; } for (var _iterator6 = t.INHERIT_KEYS.force, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) { var _ref6; if (_isArray6) { if (_i6 >= _iterator6.length) break; _ref6 = _iterator6[_i6++]; } else { _i6 = _iterator6.next(); if (_i6.done) break; _ref6 = _i6.value; } var _key3 = _ref6; child[_key3] = parent[_key3]; } t.inheritsComments(child, parent); return child; } function assertNode(node) { if (!isNode(node)) { throw new TypeError("Not a valid node " + (node && node.type)); } } function isNode(node) { return !!(node && _definitions.VISITOR_KEYS[node.type]); } (0, _toFastProperties2.default)(t); (0, _toFastProperties2.default)(t.VISITOR_KEYS); function traverseFast(node, enter, opts) { if (!node) return; var keys = t.VISITOR_KEYS[node.type]; if (!keys) return; opts = opts || {}; enter(node, opts); for (var _iterator7 = keys, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) { var _ref7; if (_isArray7) { if (_i7 >= _iterator7.length) break; _ref7 = _iterator7[_i7++]; } else { _i7 = _iterator7.next(); if (_i7.done) break; _ref7 = _i7.value; } var key = _ref7; var subNode = node[key]; if (Array.isArray(subNode)) { for (var _iterator8 = subNode, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) { var _ref8; if (_isArray8) { if (_i8 >= _iterator8.length) break; _ref8 = _iterator8[_i8++]; } else { _i8 = _iterator8.next(); if (_i8.done) break; _ref8 = _i8.value; } var _node = _ref8; traverseFast(_node, enter, opts); } } else { traverseFast(subNode, enter, opts); } } } var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"]; var CLEAR_KEYS_PLUS_COMMENTS = t.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS); function removeProperties(node, opts) { opts = opts || {}; var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS; for (var _iterator9 = map, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) { var _ref9; if (_isArray9) { if (_i9 >= _iterator9.length) break; _ref9 = _iterator9[_i9++]; } else { _i9 = _iterator9.next(); if (_i9.done) break; _ref9 = _i9.value; } var _key4 = _ref9; if (node[_key4] != null) node[_key4] = undefined; } for (var key in node) { if (key[0] === "_" && node[key] != null) node[key] = undefined; } var syms = (0, _getOwnPropertySymbols2.default)(node); for (var _iterator10 = syms, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) { var _ref10; if (_isArray10) { if (_i10 >= _iterator10.length) break; _ref10 = _iterator10[_i10++]; } else { _i10 = _iterator10.next(); if (_i10.done) break; _ref10 = _i10.value; } var sym = _ref10; node[sym] = null; } } function removePropertiesDeep(tree, opts) { traverseFast(tree, removeProperties, opts); return tree; } /***/ }), /* 2 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; module.exports = { "default": __webpack_require__(404), __esModule: true }; /***/ }), /* 3 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }; /***/ }), /* 4 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _symbol = __webpack_require__(10); var _symbol2 = _interopRequireDefault(_symbol); exports.default = function (code, opts) { var stack = void 0; try { throw new Error(); } catch (error) { if (error.stack) { stack = error.stack.split("\n").slice(1).join("\n"); } } opts = (0, _assign2.default)({ allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, preserveComments: false }, opts); var _getAst = function getAst() { var ast = void 0; try { ast = babylon.parse(code, opts); ast = _babelTraverse2.default.removeProperties(ast, { preserveComments: opts.preserveComments }); _babelTraverse2.default.cheap(ast, function (node) { node[FROM_TEMPLATE] = true; }); } catch (err) { err.stack = err.stack + "from\n" + stack; throw err; } _getAst = function getAst() { return ast; }; return ast; }; return function () { for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) { args[_key] = arguments[_key]; } return useTemplate(_getAst(), args); }; }; var _cloneDeep = __webpack_require__(574); var _cloneDeep2 = _interopRequireDefault(_cloneDeep); var _assign = __webpack_require__(174); var _assign2 = _interopRequireDefault(_assign); var _has = __webpack_require__(274); var _has2 = _interopRequireDefault(_has); var _babelTraverse = __webpack_require__(7); var _babelTraverse2 = _interopRequireDefault(_babelTraverse); var _babylon = __webpack_require__(89); var babylon = _interopRequireWildcard(_babylon); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var FROM_TEMPLATE = "_fromTemplate"; var TEMPLATE_SKIP = (0, _symbol2.default)(); function useTemplate(ast, nodes) { ast = (0, _cloneDeep2.default)(ast); var _ast = ast, program = _ast.program; if (nodes.length) { (0, _babelTraverse2.default)(ast, templateVisitor, null, nodes); } if (program.body.length > 1) { return program.body; } else { return program.body[0]; } } var templateVisitor = { noScope: true, enter: function enter(path, args) { var node = path.node; if (node[TEMPLATE_SKIP]) return path.skip(); if (t.isExpressionStatement(node)) { node = node.expression; } var replacement = void 0; if (t.isIdentifier(node) && node[FROM_TEMPLATE]) { if ((0, _has2.default)(args[0], node.name)) { replacement = args[0][node.name]; } else if (node.name[0] === "$") { var i = +node.name.slice(1); if (args[i]) replacement = args[i]; } } if (replacement === null) { path.remove(); } if (replacement) { replacement[TEMPLATE_SKIP] = true; path.replaceInline(replacement); } }, exit: function exit(_ref) { var node = _ref.node; if (!node.loc) _babelTraverse2.default.clearNode(node); } }; module.exports = exports["default"]; /***/ }), /* 5 */ /***/ (function(module, exports) { 'use strict'; var core = module.exports = { version: '2.5.0' }; if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef /***/ }), /* 6 */ /***/ (function(module, exports) { "use strict"; /** * Checks if `value` is classified as an `Array` object. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is an array, else `false`. * @example * * _.isArray([1, 2, 3]); * // => true * * _.isArray(document.body.children); * // => false * * _.isArray('abc'); * // => false * * _.isArray(_.noop); * // => false */ var isArray = Array.isArray; module.exports = isArray; /***/ }), /* 7 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.visitors = exports.Hub = exports.Scope = exports.NodePath = undefined; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _path = __webpack_require__(36); Object.defineProperty(exports, "NodePath", { enumerable: true, get: function get() { return _interopRequireDefault(_path).default; } }); var _scope = __webpack_require__(134); Object.defineProperty(exports, "Scope", { enumerable: true, get: function get() { return _interopRequireDefault(_scope).default; } }); var _hub = __webpack_require__(223); Object.defineProperty(exports, "Hub", { enumerable: true, get: function get() { return _interopRequireDefault(_hub).default; } }); exports.default = traverse; var _context = __webpack_require__(367); var _context2 = _interopRequireDefault(_context); var _visitors = __webpack_require__(384); var visitors = _interopRequireWildcard(_visitors); var _babelMessages = __webpack_require__(20); var messages = _interopRequireWildcard(_babelMessages); var _includes = __webpack_require__(111); var _includes2 = _interopRequireDefault(_includes); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); var _cache = __webpack_require__(88); var cache = _interopRequireWildcard(_cache); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } exports.visitors = visitors; function traverse(parent, opts, scope, state, parentPath) { if (!parent) return; if (!opts) opts = {}; if (!opts.noScope && !scope) { if (parent.type !== "Program" && parent.type !== "File") { throw new Error(messages.get("traverseNeedsParent", parent.type)); } } visitors.explode(opts); traverse.node(parent, opts, scope, state, parentPath); } traverse.visitors = visitors; traverse.verify = visitors.verify; traverse.explode = visitors.explode; traverse.NodePath = __webpack_require__(36); traverse.Scope = __webpack_require__(134); traverse.Hub = __webpack_require__(223); traverse.cheap = function (node, enter) { return t.traverseFast(node, enter); }; traverse.node = function (node, opts, scope, state, parentPath, skipKeys) { var keys = t.VISITOR_KEYS[node.type]; if (!keys) return; var context = new _context2.default(scope, opts, state, parentPath); for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var key = _ref; if (skipKeys && skipKeys[key]) continue; if (context.visit(node, key)) return; } }; traverse.clearNode = function (node, opts) { t.removeProperties(node, opts); cache.path.delete(node); }; traverse.removeProperties = function (tree, opts) { t.traverseFast(tree, traverse.clearNode, opts); return tree; }; function hasBlacklistedType(path, state) { if (path.node.type === state.type) { state.has = true; path.stop(); } } traverse.hasType = function (tree, scope, type, blacklistTypes) { if ((0, _includes2.default)(blacklistTypes, tree.type)) return false; if (tree.type === type) return true; var state = { has: false, type: type }; traverse(tree, { blacklist: blacklistTypes, enter: hasBlacklistedType }, scope, state); return state.has; }; traverse.clearCache = function () { cache.clear(); }; traverse.clearCache.clearPath = cache.clearPath; traverse.clearCache.clearScope = cache.clearScope; traverse.copyCache = function (source, destination) { if (cache.path.has(source)) { cache.path.set(destination, cache.path.get(source)); } }; /***/ }), /* 8 */ /***/ (function(module, exports) { 'use strict'; // shim for using process in browser var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it // don't break things. But we need to wrap it in a try catch in case it is // wrapped in strict mode code which doesn't define any globals. It's inside a // function because try/catches deoptimize in certain engines. var cachedSetTimeout; var cachedClearTimeout; function defaultSetTimout() { throw new Error('setTimeout has not been defined'); } function defaultClearTimeout() { throw new Error('clearTimeout has not been defined'); } (function () { try { if (typeof setTimeout === 'function') { cachedSetTimeout = setTimeout; } else { cachedSetTimeout = defaultSetTimout; } } catch (e) { cachedSetTimeout = defaultSetTimout; } try { if (typeof clearTimeout === 'function') { cachedClearTimeout = clearTimeout; } else { cachedClearTimeout = defaultClearTimeout; } } catch (e) { cachedClearTimeout = defaultClearTimeout; } })(); function runTimeout(fun) { if (cachedSetTimeout === setTimeout) { //normal enviroments in sane situations return setTimeout(fun, 0); } // if setTimeout wasn't available but was latter defined if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) { cachedSetTimeout = setTimeout; return setTimeout(fun, 0); } try { // when when somebody has screwed with setTimeout but no I.E. maddness return cachedSetTimeout(fun, 0); } catch (e) { try { // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally return cachedSetTimeout.call(null, fun, 0); } catch (e) { // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error return cachedSetTimeout.call(this, fun, 0); } } } function runClearTimeout(marker) { if (cachedClearTimeout === clearTimeout) { //normal enviroments in sane situations return clearTimeout(marker); } // if clearTimeout wasn't available but was latter defined if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) { cachedClearTimeout = clearTimeout; return clearTimeout(marker); } try { // when when somebody has screwed with setTimeout but no I.E. maddness return cachedClearTimeout(marker); } catch (e) { try { // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally return cachedClearTimeout.call(null, marker); } catch (e) { // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error. // Some versions of I.E. have different rules for clearTimeout vs setTimeout return cachedClearTimeout.call(this, marker); } } } var queue = []; var draining = false; var currentQueue; var queueIndex = -1; function cleanUpNextTick() { if (!draining || !currentQueue) { return; } draining = false; if (currentQueue.length) { queue = currentQueue.concat(queue); } else { queueIndex = -1; } if (queue.length) { drainQueue(); } } function drainQueue() { if (draining) { return; } var timeout = runTimeout(cleanUpNextTick); draining = true; var len = queue.length; while (len) { currentQueue = queue; queue = []; while (++queueIndex < len) { if (currentQueue) { currentQueue[queueIndex].run(); } } queueIndex = -1; len = queue.length; } currentQueue = null; draining = false; runClearTimeout(timeout); } process.nextTick = function (fun) { var args = new Array(arguments.length - 1); if (arguments.length > 1) { for (var i = 1; i < arguments.length; i++) { args[i - 1] = arguments[i]; } } queue.push(new Item(fun, args)); if (queue.length === 1 && !draining) { runTimeout(drainQueue); } }; // v8 likes predictible objects function Item(fun, array) { this.fun = fun; this.array = array; } Item.prototype.run = function () { this.fun.apply(null, this.array); }; process.title = 'browser'; process.browser = true; process.env = {}; process.argv = []; process.version = ''; // empty string to avoid regexp issues process.versions = {}; function noop() {} process.on = noop; process.addListener = noop; process.once = noop; process.off = noop; process.removeListener = noop; process.removeAllListeners = noop; process.emit = noop; process.prependListener = noop; process.prependOnceListener = noop; process.listeners = function (name) { return []; }; process.binding = function (name) { throw new Error('process.binding is not supported'); }; process.cwd = function () { return '/'; }; process.chdir = function (dir) { throw new Error('process.chdir is not supported'); }; process.umask = function () { return 0; }; /***/ }), /* 9 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; module.exports = { "default": __webpack_require__(409), __esModule: true }; /***/ }), /* 10 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; module.exports = { "default": __webpack_require__(414), __esModule: true }; /***/ }), /* 11 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; exports.__esModule = true; var _iterator = __webpack_require__(363); var _iterator2 = _interopRequireDefault(_iterator); var _symbol = __webpack_require__(10); var _symbol2 = _interopRequireDefault(_symbol); var _typeof = typeof _symbol2.default === "function" && _typeof2(_iterator2.default) === "symbol" ? function (obj) { return typeof obj === "undefined" ? "undefined" : _typeof2(obj); } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj); }; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) { return typeof obj === "undefined" ? "undefined" : _typeof(obj); } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj); }; /***/ }), /* 12 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(15); var core = __webpack_require__(5); var ctx = __webpack_require__(43); var hide = __webpack_require__(29); var PROTOTYPE = 'prototype'; var $export = function $export(type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var IS_WRAP = type & $export.W; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE]; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]; var key, own, out; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; if (own && key in exports) continue; // export native or passed out = own ? target[key] : source[key]; // prevent global pollution for namespaces exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library : IS_WRAP && target[key] == out ? function (C) { var F = function F(a, b, c) { if (this instanceof C) { switch (arguments.length) { case 0: return new C(); case 1: return new C(a); case 2: return new C(a, b); }return new C(a, b, c); }return C.apply(this, arguments); }; F[PROTOTYPE] = C[PROTOTYPE]; return F; // make static versions for prototype methods }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME% if (IS_PROTO) { (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME% if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out); } } }; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; /***/ }), /* 13 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var store = __webpack_require__(151)('wks'); var uid = __webpack_require__(95); var _Symbol = __webpack_require__(15).Symbol; var USE_SYMBOL = typeof _Symbol == 'function'; var $exports = module.exports = function (name) { return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name)); }; $exports.store = store; /***/ }), /* 14 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; module.exports = { "default": __webpack_require__(411), __esModule: true }; /***/ }), /* 15 */ /***/ (function(module, exports) { 'use strict'; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028 var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func : Function('return this')(); if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef /***/ }), /* 16 */ /***/ (function(module, exports) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; module.exports = function (it) { return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function'; }; /***/ }), /* 17 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; var freeGlobal = __webpack_require__(261); /** Detect free variable `self`. */ var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self; /** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')(); module.exports = root; /***/ }), /* 18 */ /***/ (function(module, exports) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /** * Checks if `value` is the * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types) * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is an object, else `false`. * @example * * _.isObject({}); * // => true * * _.isObject([1, 2, 3]); * // => true * * _.isObject(_.noop); * // => true * * _.isObject(null); * // => false */ function isObject(value) { var type = typeof value === 'undefined' ? 'undefined' : _typeof(value); return value != null && (type == 'object' || type == 'function'); } module.exports = isObject; /***/ }), /* 19 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(process) {'use strict'; // Copyright Joyent, Inc. and other Node contributors. // // Permission is hereby granted, free of charge, to any person obtaining a // copy of this software and associated documentation files (the // "Software"), to deal in the Software without restriction, including // without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to permit // persons to whom the Software is furnished to do so, subject to the // following conditions: // // The above copyright notice and this permission notice shall be included // in all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE // USE OR OTHER DEALINGS IN THE SOFTWARE. // resolves . and .. elements in a path array with directory names there // must be no slashes, empty elements, or device names (c:\) in the array // (so also no leading and trailing slashes - it does not distinguish // relative and absolute paths) function normalizeArray(parts, allowAboveRoot) { // if the path tries to go above the root, `up` ends up > 0 var up = 0; for (var i = parts.length - 1; i >= 0; i--) { var last = parts[i]; if (last === '.') { parts.splice(i, 1); } else if (last === '..') { parts.splice(i, 1); up++; } else if (up) { parts.splice(i, 1); up--; } } // if the path is allowed to go above the root, restore leading ..s if (allowAboveRoot) { for (; up--; up) { parts.unshift('..'); } } return parts; } // Split a filename into [root, dir, basename, ext], unix version // 'root' is just a slash, or nothing. var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; var splitPath = function splitPath(filename) { return splitPathRe.exec(filename).slice(1); }; // path.resolve([from ...], to) // posix version exports.resolve = function () { var resolvedPath = '', resolvedAbsolute = false; for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) { var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries if (typeof path !== 'string') { throw new TypeError('Arguments to path.resolve must be strings'); } else if (!path) { continue; } resolvedPath = path + '/' + resolvedPath; resolvedAbsolute = path.charAt(0) === '/'; } // At this point the path should be resolved to a full absolute path, but // handle relative paths to be safe (might happen when process.cwd() fails) // Normalize the path resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) { return !!p; }), !resolvedAbsolute).join('/'); return (resolvedAbsolute ? '/' : '') + resolvedPath || '.'; }; // path.normalize(path) // posix version exports.normalize = function (path) { var isAbsolute = exports.isAbsolute(path), trailingSlash = substr(path, -1) === '/'; // Normalize the path path = normalizeArray(filter(path.split('/'), function (p) { return !!p; }), !isAbsolute).join('/'); if (!path && !isAbsolute) { path = '.'; } if (path && trailingSlash) { path += '/'; } return (isAbsolute ? '/' : '') + path; }; // posix version exports.isAbsolute = function (path) { return path.charAt(0) === '/'; }; // posix version exports.join = function () { var paths = Array.prototype.slice.call(arguments, 0); return exports.normalize(filter(paths, function (p, index) { if (typeof p !== 'string') { throw new TypeError('Arguments to path.join must be strings'); } return p; }).join('/')); }; // path.relative(from, to) // posix version exports.relative = function (from, to) { from = exports.resolve(from).substr(1); to = exports.resolve(to).substr(1); function trim(arr) { var start = 0; for (; start < arr.length; start++) { if (arr[start] !== '') break; } var end = arr.length - 1; for (; end >= 0; end--) { if (arr[end] !== '') break; } if (start > end) return []; return arr.slice(start, end - start + 1); } var fromParts = trim(from.split('/')); var toParts = trim(to.split('/')); var length = Math.min(fromParts.length, toParts.length); var samePartsLength = length; for (var i = 0; i < length; i++) { if (fromParts[i] !== toParts[i]) { samePartsLength = i; break; } } var outputParts = []; for (var i = samePartsLength; i < fromParts.length; i++) { outputParts.push('..'); } outputParts = outputParts.concat(toParts.slice(samePartsLength)); return outputParts.join('/'); }; exports.sep = '/'; exports.delimiter = ':'; exports.dirname = function (path) { var result = splitPath(path), root = result[0], dir = result[1]; if (!root && !dir) { // No dirname whatsoever return '.'; } if (dir) { // It has a dirname, strip trailing slash dir = dir.substr(0, dir.length - 1); } return root + dir; }; exports.basename = function (path, ext) { var f = splitPath(path)[2]; // TODO: make this comparison case-insensitive on windows? if (ext && f.substr(-1 * ext.length) === ext) { f = f.substr(0, f.length - ext.length); } return f; }; exports.extname = function (path) { return splitPath(path)[3]; }; function filter(xs, f) { if (xs.filter) return xs.filter(f); var res = []; for (var i = 0; i < xs.length; i++) { if (f(xs[i], i, xs)) res.push(xs[i]); } return res; } // String.prototype.substr - negative index don't work in IE8 var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) { return str.substr(start, len); } : function (str, start, len) { if (start < 0) start = str.length + start; return str.substr(start, len); }; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8))) /***/ }), /* 20 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.MESSAGES = undefined; var _stringify = __webpack_require__(35); var _stringify2 = _interopRequireDefault(_stringify); exports.get = get; exports.parseArgs = parseArgs; var _util = __webpack_require__(117); var util = _interopRequireWildcard(_util); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var MESSAGES = exports.MESSAGES = { tailCallReassignmentDeopt: "Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence", classesIllegalBareSuper: "Illegal use of bare super", classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead", scopeDuplicateDeclaration: "Duplicate declaration $1", settersNoRest: "Setters aren't allowed to have a rest", noAssignmentsInForHead: "No assignments allowed in for-in/of head", expectedMemberExpressionOrIdentifier: "Expected type MemberExpression or Identifier", invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue", readOnly: "$1 is read-only", unknownForHead: "Unknown node type $1 in ForStatement", didYouMean: "Did you mean $1?", codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.", missingTemplatesDirectory: "no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues", unsupportedOutputType: "Unsupported output type $1", illegalMethodName: "Illegal method name $1", lostTrackNodePath: "We lost track of this node's position, likely because the AST was directly manipulated", modulesIllegalExportName: "Illegal export $1", modulesDuplicateDeclarations: "Duplicate module declarations with the same source but in different scopes", undeclaredVariable: "Reference to undeclared variable $1", undeclaredVariableType: "Referencing a type alias outside of a type annotation", undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?", traverseNeedsParent: "You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a $1 node without passing scope and parentPath.", traverseVerifyRootFunction: "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?", traverseVerifyVisitorProperty: "You passed `traverse()` a visitor object with the property $1 that has the invalid property $2", traverseVerifyNodeType: "You gave us a visitor for the node type $1 but it's not a valid type", pluginNotObject: "Plugin $2 specified in $1 was expected to return an object when invoked but returned $3", pluginNotFunction: "Plugin $2 specified in $1 was expected to return a function but returned $3", pluginUnknown: "Unknown plugin $1 specified in $2 at $3, attempted to resolve relative to $4", pluginInvalidProperty: "Plugin $2 specified in $1 provided an invalid property of $3" }; function get(key) { for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) { args[_key - 1] = arguments[_key]; } var msg = MESSAGES[key]; if (!msg) throw new ReferenceError("Unknown message " + (0, _stringify2.default)(key)); args = parseArgs(args); return msg.replace(/\$(\d+)/g, function (str, i) { return args[i - 1]; }); } function parseArgs(args) { return args.map(function (val) { if (val != null && val.inspect) { return val.inspect(); } else { try { return (0, _stringify2.default)(val) || val + ""; } catch (e) { return util.inspect(val); } } }); } /***/ }), /* 21 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isObject = __webpack_require__(16); module.exports = function (it) { if (!isObject(it)) throw TypeError(it + ' is not an object!'); return it; }; /***/ }), /* 22 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // Thank's IE8 for his funny defineProperty module.exports = !__webpack_require__(27)(function () { return Object.defineProperty({}, 'a', { get: function get() { return 7; } }).a != 7; }); /***/ }), /* 23 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(21); var IE8_DOM_DEFINE = __webpack_require__(231); var toPrimitive = __webpack_require__(154); var dP = Object.defineProperty; exports.f = __webpack_require__(22) ? Object.defineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return dP(O, P, Attributes); } catch (e) {/* empty */} if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!'); if ('value' in Attributes) O[P] = Attributes.value; return O; }; /***/ }), /* 24 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isFunction = __webpack_require__(175), isLength = __webpack_require__(176); /** * Checks if `value` is array-like. A value is considered array-like if it's * not a function and has a `value.length` that's an integer greater than or * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is array-like, else `false`. * @example * * _.isArrayLike([1, 2, 3]); * // => true * * _.isArrayLike(document.body.children); * // => true * * _.isArrayLike('abc'); * // => true * * _.isArrayLike(_.noop); * // => false */ function isArrayLike(value) { return value != null && isLength(value.length) && !isFunction(value); } module.exports = isArrayLike; /***/ }), /* 25 */ /***/ (function(module, exports) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /** * Checks if `value` is object-like. A value is object-like if it's not `null` * and has a `typeof` result of "object". * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is object-like, else `false`. * @example * * _.isObjectLike({}); * // => true * * _.isObjectLike([1, 2, 3]); * // => true * * _.isObjectLike(_.noop); * // => false * * _.isObjectLike(null); * // => false */ function isObjectLike(value) { return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object'; } module.exports = isObjectLike; /***/ }), /* 26 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = undefined; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _stringify = __webpack_require__(35); var _stringify2 = _interopRequireDefault(_stringify); var _typeof2 = __webpack_require__(11); var _typeof3 = _interopRequireDefault(_typeof2); exports.assertEach = assertEach; exports.assertOneOf = assertOneOf; exports.assertNodeType = assertNodeType; exports.assertNodeOrValueType = assertNodeOrValueType; exports.assertValueType = assertValueType; exports.chain = chain; exports.default = defineType; var _index = __webpack_require__(1); var t = _interopRequireWildcard(_index); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var VISITOR_KEYS = exports.VISITOR_KEYS = {}; var ALIAS_KEYS = exports.ALIAS_KEYS = {}; var NODE_FIELDS = exports.NODE_FIELDS = {}; var BUILDER_KEYS = exports.BUILDER_KEYS = {}; var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {}; function getType(val) { if (Array.isArray(val)) { return "array"; } else if (val === null) { return "null"; } else if (val === undefined) { return "undefined"; } else { return typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val); } } function assertEach(callback) { function validator(node, key, val) { if (!Array.isArray(val)) return; for (var i = 0; i < val.length; i++) { callback(node, key + "[" + i + "]", val[i]); } } validator.each = callback; return validator; } function assertOneOf() { for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) { vals[_key] = arguments[_key]; } function validate(node, key, val) { if (vals.indexOf(val) < 0) { throw new TypeError("Property " + key + " expected value to be one of " + (0, _stringify2.default)(vals) + " but got " + (0, _stringify2.default)(val)); } } validate.oneOf = vals; return validate; } function assertNodeType() { for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) { types[_key2] = arguments[_key2]; } function validate(node, key, val) { var valid = false; for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var type = _ref; if (t.is(type, val)) { valid = true; break; } } if (!valid) { throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type))); } } validate.oneOfNodeTypes = types; return validate; } function assertNodeOrValueType() { for (var _len3 = arguments.length, types = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) { types[_key3] = arguments[_key3]; } function validate(node, key, val) { var valid = false; for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var type = _ref2; if (getType(val) === type || t.is(type, val)) { valid = true; break; } } if (!valid) { throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type))); } } validate.oneOfNodeOrValueTypes = types; return validate; } function assertValueType(type) { function validate(node, key, val) { var valid = getType(val) === type; if (!valid) { throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val)); } } validate.type = type; return validate; } function chain() { for (var _len4 = arguments.length, fns = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) { fns[_key4] = arguments[_key4]; } function validate() { for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) { var _ref3; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref3 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref3 = _i3.value; } var fn = _ref3; fn.apply(undefined, arguments); } } validate.chainOf = fns; return validate; } function defineType(type) { var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; var inherits = opts.inherits && store[opts.inherits] || {}; opts.fields = opts.fields || inherits.fields || {}; opts.visitor = opts.visitor || inherits.visitor || []; opts.aliases = opts.aliases || inherits.aliases || []; opts.builder = opts.builder || inherits.builder || opts.visitor || []; if (opts.deprecatedAlias) { DEPRECATED_KEYS[opts.deprecatedAlias] = type; } for (var _iterator4 = opts.visitor.concat(opts.builder), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) { var _ref4; if (_isArray4) { if (_i4 >= _iterator4.length) break; _ref4 = _iterator4[_i4++]; } else { _i4 = _iterator4.next(); if (_i4.done) break; _ref4 = _i4.value; } var _key5 = _ref4; opts.fields[_key5] = opts.fields[_key5] || {}; } for (var key in opts.fields) { var field = opts.fields[key]; if (opts.builder.indexOf(key) === -1) { field.optional = true; } if (field.default === undefined) { field.default = null; } else if (!field.validate) { field.validate = assertValueType(getType(field.default)); } } VISITOR_KEYS[type] = opts.visitor; BUILDER_KEYS[type] = opts.builder; NODE_FIELDS[type] = opts.fields; ALIAS_KEYS[type] = opts.aliases; store[type] = opts; } var store = {}; /***/ }), /* 27 */ /***/ (function(module, exports) { "use strict"; module.exports = function (exec) { try { return !!exec(); } catch (e) { return true; } }; /***/ }), /* 28 */ /***/ (function(module, exports) { "use strict"; var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); }; /***/ }), /* 29 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var dP = __webpack_require__(23); var createDesc = __webpack_require__(92); module.exports = __webpack_require__(22) ? function (object, key, value) { return dP.f(object, key, createDesc(1, value)); } : function (object, key, value) { object[key] = value; return object; }; /***/ }), /* 30 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var _Symbol = __webpack_require__(45), getRawTag = __webpack_require__(534), objectToString = __webpack_require__(559); /** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]'; /** Built-in value references. */ var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined; /** * The base implementation of `getTag` without fallbacks for buggy environments. * * @private * @param {*} value The value to query. * @returns {string} Returns the `toStringTag`. */ function baseGetTag(value) { if (value == null) { return value === undefined ? undefinedTag : nullTag; } return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value); } module.exports = baseGetTag; /***/ }), /* 31 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var assignValue = __webpack_require__(162), baseAssignValue = __webpack_require__(163); /** * Copies properties of `source` to `object`. * * @private * @param {Object} source The object to copy properties from. * @param {Array} props The property identifiers to copy. * @param {Object} [object={}] The object to copy properties to. * @param {Function} [customizer] The function to customize copied values. * @returns {Object} Returns `object`. */ function copyObject(source, props, object, customizer) { var isNew = !object; object || (object = {}); var index = -1, length = props.length; while (++index < length) { var key = props[index]; var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined; if (newValue === undefined) { newValue = source[key]; } if (isNew) { baseAssignValue(object, key, newValue); } else { assignValue(object, key, newValue); } } return object; } module.exports = copyObject; /***/ }), /* 32 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var arrayLikeKeys = __webpack_require__(245), baseKeys = __webpack_require__(500), isArrayLike = __webpack_require__(24); /** * Creates an array of the own enumerable property names of `object`. * * **Note:** Non-object values are coerced to objects. See the * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys) * for more details. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property names. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.keys(new Foo); * // => ['a', 'b'] (iteration order is not guaranteed) * * _.keys('hi'); * // => ['0', '1'] */ function keys(object) { return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object); } module.exports = keys; /***/ }), /* 33 */ /***/ (function(module, exports) { "use strict"; module.exports = { filename: { type: "filename", description: "filename to use when reading from stdin - this will be used in source-maps, errors etc", default: "unknown", shorthand: "f" }, filenameRelative: { hidden: true, type: "string" }, inputSourceMap: { hidden: true }, env: { hidden: true, default: {} }, mode: { description: "", hidden: true }, retainLines: { type: "boolean", default: false, description: "retain line numbers - will result in really ugly code" }, highlightCode: { description: "enable/disable ANSI syntax highlighting of code frames (on by default)", type: "boolean", default: true }, suppressDeprecationMessages: { type: "boolean", default: false, hidden: true }, presets: { type: "list", description: "", default: [] }, plugins: { type: "list", default: [], description: "" }, ignore: { type: "list", description: "list of glob paths to **not** compile", default: [] }, only: { type: "list", description: "list of glob paths to **only** compile" }, code: { hidden: true, default: true, type: "boolean" }, metadata: { hidden: true, default: true, type: "boolean" }, ast: { hidden: true, default: true, type: "boolean" }, extends: { type: "string", hidden: true }, comments: { type: "boolean", default: true, description: "write comments to generated output (true by default)" }, shouldPrintComment: { hidden: true, description: "optional callback to control whether a comment should be inserted, when this is used the comments option is ignored" }, wrapPluginVisitorMethod: { hidden: true, description: "optional callback to wrap all visitor methods" }, compact: { type: "booleanString", default: "auto", description: "do not include superfluous whitespace characters and line terminators [true|false|auto]" }, minified: { type: "boolean", default: false, description: "save as much bytes when printing [true|false]" }, sourceMap: { alias: "sourceMaps", hidden: true }, sourceMaps: { type: "booleanString", description: "[true|false|inline]", default: false, shorthand: "s" }, sourceMapTarget: { type: "string", description: "set `file` on returned source map" }, sourceFileName: { type: "string", description: "set `sources[0]` on returned source map" }, sourceRoot: { type: "filename", description: "the root from which all sources are relative" }, babelrc: { description: "Whether or not to look up .babelrc and .babelignore files", type: "boolean", default: true }, sourceType: { description: "", default: "module" }, auxiliaryCommentBefore: { type: "string", description: "print a comment before any injected non-user code" }, auxiliaryCommentAfter: { type: "string", description: "print a comment after any injected non-user code" }, resolveModuleSource: { hidden: true }, getModuleId: { hidden: true }, moduleRoot: { type: "filename", description: "optional prefix for the AMD module formatter that will be prepend to the filename on module definitions" }, moduleIds: { type: "boolean", default: false, shorthand: "M", description: "insert an explicit id for modules" }, moduleId: { description: "specify a custom name for module ids", type: "string" }, passPerPreset: { description: "Whether to spawn a traversal pass per a preset. By default all presets are merged.", type: "boolean", default: false, hidden: true }, parserOpts: { description: "Options to pass into the parser, or to change parsers (parserOpts.parser)", default: false }, generatorOpts: { description: "Options to pass into the generator, or to change generators (generatorOpts.generator)", default: false } }; /***/ }), /* 34 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(process) {"use strict"; exports.__esModule = true; var _objectWithoutProperties2 = __webpack_require__(366); var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2); var _stringify = __webpack_require__(35); var _stringify2 = _interopRequireDefault(_stringify); var _assign = __webpack_require__(87); var _assign2 = _interopRequireDefault(_assign); var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _typeof2 = __webpack_require__(11); var _typeof3 = _interopRequireDefault(_typeof2); var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); var _node = __webpack_require__(182); var context = _interopRequireWildcard(_node); var _plugin2 = __webpack_require__(65); var _plugin3 = _interopRequireDefault(_plugin2); var _babelMessages = __webpack_require__(20); var messages = _interopRequireWildcard(_babelMessages); var _index = __webpack_require__(52); var _resolvePlugin = __webpack_require__(184); var _resolvePlugin2 = _interopRequireDefault(_resolvePlugin); var _resolvePreset = __webpack_require__(185); var _resolvePreset2 = _interopRequireDefault(_resolvePreset); var _cloneDeepWith = __webpack_require__(575); var _cloneDeepWith2 = _interopRequireDefault(_cloneDeepWith); var _clone = __webpack_require__(109); var _clone2 = _interopRequireDefault(_clone); var _merge = __webpack_require__(293); var _merge2 = _interopRequireDefault(_merge); var _config2 = __webpack_require__(33); var _config3 = _interopRequireDefault(_config2); var _removed = __webpack_require__(54); var _removed2 = _interopRequireDefault(_removed); var _buildConfigChain = __webpack_require__(51); var _buildConfigChain2 = _interopRequireDefault(_buildConfigChain); var _path = __webpack_require__(19); var _path2 = _interopRequireDefault(_path); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var OptionManager = function () { function OptionManager(log) { (0, _classCallCheck3.default)(this, OptionManager); this.resolvedConfigs = []; this.options = OptionManager.createBareOptions(); this.log = log; } OptionManager.memoisePluginContainer = function memoisePluginContainer(fn, loc, i, alias) { for (var _iterator = OptionManager.memoisedPlugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var cache = _ref; if (cache.container === fn) return cache.plugin; } var obj = void 0; if (typeof fn === "function") { obj = fn(context); } else { obj = fn; } if ((typeof obj === "undefined" ? "undefined" : (0, _typeof3.default)(obj)) === "object") { var _plugin = new _plugin3.default(obj, alias); OptionManager.memoisedPlugins.push({ container: fn, plugin: _plugin }); return _plugin; } else { throw new TypeError(messages.get("pluginNotObject", loc, i, typeof obj === "undefined" ? "undefined" : (0, _typeof3.default)(obj)) + loc + i); } }; OptionManager.createBareOptions = function createBareOptions() { var opts = {}; for (var _key in _config3.default) { var opt = _config3.default[_key]; opts[_key] = (0, _clone2.default)(opt.default); } return opts; }; OptionManager.normalisePlugin = function normalisePlugin(plugin, loc, i, alias) { plugin = plugin.__esModule ? plugin.default : plugin; if (!(plugin instanceof _plugin3.default)) { if (typeof plugin === "function" || (typeof plugin === "undefined" ? "undefined" : (0, _typeof3.default)(plugin)) === "object") { plugin = OptionManager.memoisePluginContainer(plugin, loc, i, alias); } else { throw new TypeError(messages.get("pluginNotFunction", loc, i, typeof plugin === "undefined" ? "undefined" : (0, _typeof3.default)(plugin))); } } plugin.init(loc, i); return plugin; }; OptionManager.normalisePlugins = function normalisePlugins(loc, dirname, plugins) { return plugins.map(function (val, i) { var plugin = void 0, options = void 0; if (!val) { throw new TypeError("Falsy value found in plugins"); } if (Array.isArray(val)) { plugin = val[0]; options = val[1]; } else { plugin = val; } var alias = typeof plugin === "string" ? plugin : loc + "$" + i; if (typeof plugin === "string") { var pluginLoc = (0, _resolvePlugin2.default)(plugin, dirname); if (pluginLoc) { plugin = __webpack_require__(179)(pluginLoc); } else { throw new ReferenceError(messages.get("pluginUnknown", plugin, loc, i, dirname)); } } plugin = OptionManager.normalisePlugin(plugin, loc, i, alias); return [plugin, options]; }); }; OptionManager.prototype.mergeOptions = function mergeOptions(_ref2) { var _this = this; var rawOpts = _ref2.options, extendingOpts = _ref2.extending, alias = _ref2.alias, loc = _ref2.loc, dirname = _ref2.dirname; alias = alias || "foreign"; if (!rawOpts) return; if ((typeof rawOpts === "undefined" ? "undefined" : (0, _typeof3.default)(rawOpts)) !== "object" || Array.isArray(rawOpts)) { this.log.error("Invalid options type for " + alias, TypeError); } var opts = (0, _cloneDeepWith2.default)(rawOpts, function (val) { if (val instanceof _plugin3.default) { return val; } }); dirname = dirname || process.cwd(); loc = loc || alias; for (var _key2 in opts) { var option = _config3.default[_key2]; if (!option && this.log) { if (_removed2.default[_key2]) { this.log.error("Using removed Babel 5 option: " + alias + "." + _key2 + " - " + _removed2.default[_key2].message, ReferenceError); } else { var unknownOptErr = "Unknown option: " + alias + "." + _key2 + ". Check out http://babeljs.io/docs/usage/options/ for more information about options."; var presetConfigErr = "A common cause of this error is the presence of a configuration options object without the corresponding preset name. Example:\n\nInvalid:\n `{ presets: [{option: value}] }`\nValid:\n `{ presets: [['presetName', {option: value}]] }`\n\nFor more detailed information on preset configuration, please see http://babeljs.io/docs/plugins/#pluginpresets-options."; this.log.error(unknownOptErr + "\n\n" + presetConfigErr, ReferenceError); } } } (0, _index.normaliseOptions)(opts); if (opts.plugins) { opts.plugins = OptionManager.normalisePlugins(loc, dirname, opts.plugins); } if (opts.presets) { if (opts.passPerPreset) { opts.presets = this.resolvePresets(opts.presets, dirname, function (preset, presetLoc) { _this.mergeOptions({ options: preset, extending: preset, alias: presetLoc, loc: presetLoc, dirname: dirname }); }); } else { this.mergePresets(opts.presets, dirname); delete opts.presets; } } if (rawOpts === extendingOpts) { (0, _assign2.default)(extendingOpts, opts); } else { (0, _merge2.default)(extendingOpts || this.options, opts); } }; OptionManager.prototype.mergePresets = function mergePresets(presets, dirname) { var _this2 = this; this.resolvePresets(presets, dirname, function (presetOpts, presetLoc) { _this2.mergeOptions({ options: presetOpts, alias: presetLoc, loc: presetLoc, dirname: _path2.default.dirname(presetLoc || "") }); }); }; OptionManager.prototype.resolvePresets = function resolvePresets(presets, dirname, onResolve) { return presets.map(function (val) { var options = void 0; if (Array.isArray(val)) { if (val.length > 2) { throw new Error("Unexpected extra options " + (0, _stringify2.default)(val.slice(2)) + " passed to preset."); } var _val = val; val = _val[0]; options = _val[1]; } var presetLoc = void 0; try { if (typeof val === "string") { presetLoc = (0, _resolvePreset2.default)(val, dirname); if (!presetLoc) { throw new Error("Couldn't find preset " + (0, _stringify2.default)(val) + " relative to directory " + (0, _stringify2.default)(dirname)); } val = __webpack_require__(179)(presetLoc); } if ((typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val)) === "object" && val.__esModule) { if (val.default) { val = val.default; } else { var _val2 = val, __esModule = _val2.__esModule, rest = (0, _objectWithoutProperties3.default)(_val2, ["__esModule"]); val = rest; } } if ((typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val)) === "object" && val.buildPreset) val = val.buildPreset; if (typeof val !== "function" && options !== undefined) { throw new Error("Options " + (0, _stringify2.default)(options) + " passed to " + (presetLoc || "a preset") + " which does not accept options."); } if (typeof val === "function") val = val(context, options, { dirname: dirname }); if ((typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val)) !== "object") { throw new Error("Unsupported preset format: " + val + "."); } onResolve && onResolve(val, presetLoc); } catch (e) { if (presetLoc) { e.message += " (While processing preset: " + (0, _stringify2.default)(presetLoc) + ")"; } throw e; } return val; }); }; OptionManager.prototype.normaliseOptions = function normaliseOptions() { var opts = this.options; for (var _key3 in _config3.default) { var option = _config3.default[_key3]; var val = opts[_key3]; if (!val && option.optional) continue; if (option.alias) { opts[option.alias] = opts[option.alias] || val; } else { opts[_key3] = val; } } }; OptionManager.prototype.init = function init() { var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; for (var _iterator2 = (0, _buildConfigChain2.default)(opts, this.log), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref3; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref3 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref3 = _i2.value; } var _config = _ref3; this.mergeOptions(_config); } this.normaliseOptions(opts); return this.options; }; return OptionManager; }(); exports.default = OptionManager; OptionManager.memoisedPlugins = []; module.exports = exports["default"]; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8))) /***/ }), /* 35 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; module.exports = { "default": __webpack_require__(405), __esModule: true }; /***/ }), /* 36 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); var _virtualTypes = __webpack_require__(224); var virtualTypes = _interopRequireWildcard(_virtualTypes); var _debug2 = __webpack_require__(239); var _debug3 = _interopRequireDefault(_debug2); var _invariant = __webpack_require__(466); var _invariant2 = _interopRequireDefault(_invariant); var _index = __webpack_require__(7); var _index2 = _interopRequireDefault(_index); var _assign = __webpack_require__(174); var _assign2 = _interopRequireDefault(_assign); var _scope = __webpack_require__(134); var _scope2 = _interopRequireDefault(_scope); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); var _cache = __webpack_require__(88); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var _debug = (0, _debug3.default)("babel"); var NodePath = function () { function NodePath(hub, parent) { (0, _classCallCheck3.default)(this, NodePath); this.parent = parent; this.hub = hub; this.contexts = []; this.data = {}; this.shouldSkip = false; this.shouldStop = false; this.removed = false; this.state = null; this.opts = null; this.skipKeys = null; this.parentPath = null; this.context = null; this.container = null; this.listKey = null; this.inList = false; this.parentKey = null; this.key = null; this.node = null; this.scope = null; this.type = null; this.typeAnnotation = null; } NodePath.get = function get(_ref) { var hub = _ref.hub, parentPath = _ref.parentPath, parent = _ref.parent, container = _ref.container, listKey = _ref.listKey, key = _ref.key; if (!hub && parentPath) { hub = parentPath.hub; } (0, _invariant2.default)(parent, "To get a node path the parent needs to exist"); var targetNode = container[key]; var paths = _cache.path.get(parent) || []; if (!_cache.path.has(parent)) { _cache.path.set(parent, paths); } var path = void 0; for (var i = 0; i < paths.length; i++) { var pathCheck = paths[i]; if (pathCheck.node === targetNode) { path = pathCheck; break; } } if (!path) { path = new NodePath(hub, parent); paths.push(path); } path.setup(parentPath, container, listKey, key); return path; }; NodePath.prototype.getScope = function getScope(scope) { var ourScope = scope; if (this.isScope()) { ourScope = new _scope2.default(this, scope); } return ourScope; }; NodePath.prototype.setData = function setData(key, val) { return this.data[key] = val; }; NodePath.prototype.getData = function getData(key, def) { var val = this.data[key]; if (!val && def) val = this.data[key] = def; return val; }; NodePath.prototype.buildCodeFrameError = function buildCodeFrameError(msg) { var Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError; return this.hub.file.buildCodeFrameError(this.node, msg, Error); }; NodePath.prototype.traverse = function traverse(visitor, state) { (0, _index2.default)(this.node, visitor, this.scope, state, this); }; NodePath.prototype.mark = function mark(type, message) { this.hub.file.metadata.marked.push({ type: type, message: message, loc: this.node.loc }); }; NodePath.prototype.set = function set(key, node) { t.validate(this.node, key, node); this.node[key] = node; }; NodePath.prototype.getPathLocation = function getPathLocation() { var parts = []; var path = this; do { var key = path.key; if (path.inList) key = path.listKey + "[" + key + "]"; parts.unshift(key); } while (path = path.parentPath); return parts.join("."); }; NodePath.prototype.debug = function debug(buildMessage) { if (!_debug.enabled) return; _debug(this.getPathLocation() + " " + this.type + ": " + buildMessage()); }; return NodePath; }(); exports.default = NodePath; (0, _assign2.default)(NodePath.prototype, __webpack_require__(368)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(374)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(382)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(372)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(371)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(377)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(370)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(381)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(380)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(373)); (0, _assign2.default)(NodePath.prototype, __webpack_require__(369)); var _loop2 = function _loop2() { if (_isArray) { if (_i >= _iterator.length) return "break"; _ref2 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) return "break"; _ref2 = _i.value; } var type = _ref2; var typeKey = "is" + type; NodePath.prototype[typeKey] = function (opts) { return t[typeKey](this.node, opts); }; NodePath.prototype["assert" + type] = function (opts) { if (!this[typeKey](opts)) { throw new TypeError("Expected node path of type " + type); } }; }; for (var _iterator = t.TYPES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref2; var _ret2 = _loop2(); if (_ret2 === "break") break; } var _loop = function _loop(type) { if (type[0] === "_") return "continue"; if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type); var virtualType = virtualTypes[type]; NodePath.prototype["is" + type] = function (opts) { return virtualType.checkPath(this, opts); }; }; for (var type in virtualTypes) { var _ret = _loop(type); if (_ret === "continue") continue; } module.exports = exports["default"]; /***/ }), /* 37 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // to indexed object, toObject with fallback for non-array-like ES3 strings var IObject = __webpack_require__(142); var defined = __webpack_require__(140); module.exports = function (it) { return IObject(defined(it)); }; /***/ }), /* 38 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var baseIsNative = __webpack_require__(497), getValue = __webpack_require__(535); /** * Gets the native function at `key` of `object`. * * @private * @param {Object} object The object to query. * @param {string} key The key of the method to get. * @returns {*} Returns the function if it's native, else `undefined`. */ function getNative(object, key) { var value = getValue(object, key); return baseIsNative(value) ? value : undefined; } module.exports = getNative; /***/ }), /* 39 */ /***/ (function(module, exports) { "use strict"; module.exports = function (module) { if (!module.webpackPolyfill) { module.deprecate = function () {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; }; /***/ }), /* 40 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.default = function (_ref) { var node = _ref.node, parent = _ref.parent, scope = _ref.scope, id = _ref.id; if (node.id) return; if ((t.isObjectProperty(parent) || t.isObjectMethod(parent, { kind: "method" })) && (!parent.computed || t.isLiteral(parent.key))) { id = parent.key; } else if (t.isVariableDeclarator(parent)) { id = parent.id; if (t.isIdentifier(id)) { var binding = scope.parent.getBinding(id.name); if (binding && binding.constant && scope.getBinding(id.name) === binding) { node.id = id; node.id[t.NOT_LOCAL_BINDING] = true; return; } } } else if (t.isAssignmentExpression(parent)) { id = parent.left; } else if (!id) { return; } var name = void 0; if (id && t.isLiteral(id)) { name = id.value; } else if (id && t.isIdentifier(id)) { name = id.name; } else { return; } name = t.toBindingIdentifierName(name); id = t.identifier(name); id[t.NOT_LOCAL_BINDING] = true; var state = visit(node, name, scope); return wrap(state, node, id, scope) || node; }; var _babelHelperGetFunctionArity = __webpack_require__(189); var _babelHelperGetFunctionArity2 = _interopRequireDefault(_babelHelperGetFunctionArity); var _babelTemplate = __webpack_require__(4); var _babelTemplate2 = _interopRequireDefault(_babelTemplate); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var buildPropertyMethodAssignmentWrapper = (0, _babelTemplate2.default)("\n (function (FUNCTION_KEY) {\n function FUNCTION_ID() {\n return FUNCTION_KEY.apply(this, arguments);\n }\n\n FUNCTION_ID.toString = function () {\n return FUNCTION_KEY.toString();\n }\n\n return FUNCTION_ID;\n })(FUNCTION)\n"); var buildGeneratorPropertyMethodAssignmentWrapper = (0, _babelTemplate2.default)("\n (function (FUNCTION_KEY) {\n function* FUNCTION_ID() {\n return yield* FUNCTION_KEY.apply(this, arguments);\n }\n\n FUNCTION_ID.toString = function () {\n return FUNCTION_KEY.toString();\n };\n\n return FUNCTION_ID;\n })(FUNCTION)\n"); var visitor = { "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) { if (path.node.name !== state.name) return; var localDeclar = path.scope.getBindingIdentifier(state.name); if (localDeclar !== state.outerDeclar) return; state.selfReference = true; path.stop(); } }; function wrap(state, method, id, scope) { if (state.selfReference) { if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) { scope.rename(id.name); } else { if (!t.isFunction(method)) return; var build = buildPropertyMethodAssignmentWrapper; if (method.generator) build = buildGeneratorPropertyMethodAssignmentWrapper; var _template = build({ FUNCTION: method, FUNCTION_ID: id, FUNCTION_KEY: scope.generateUidIdentifier(id.name) }).expression; _template.callee._skipModulesRemap = true; var params = _template.callee.body.body[0].params; for (var i = 0, len = (0, _babelHelperGetFunctionArity2.default)(method); i < len; i++) { params.push(scope.generateUidIdentifier("x")); } return _template; } } method.id = id; scope.getProgramParent().references[id.name] = true; } function visit(node, name, scope) { var state = { selfAssignment: false, selfReference: false, outerDeclar: scope.getBindingIdentifier(name), references: [], name: name }; var binding = scope.getOwnBinding(name); if (binding) { if (binding.kind === "param") { state.selfReference = true; } else {} } else if (state.outerDeclar || scope.hasGlobal(name)) { scope.traverse(node, visitor, state); } return state; } module.exports = exports["default"]; /***/ }), /* 41 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _setPrototypeOf = __webpack_require__(361); var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf); var _create = __webpack_require__(9); var _create2 = _interopRequireDefault(_create); var _typeof2 = __webpack_require__(11); var _typeof3 = _interopRequireDefault(_typeof2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } exports.default = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass))); } subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass; }; /***/ }), /* 42 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _typeof2 = __webpack_require__(11); var _typeof3 = _interopRequireDefault(_typeof2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } exports.default = function (self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self; }; /***/ }), /* 43 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // optional / simple context binding var aFunction = __webpack_require__(227); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function () /* ...args */{ return fn.apply(that, arguments); }; }; /***/ }), /* 44 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.2.14 / 15.2.3.14 Object.keys(O) var $keys = __webpack_require__(237); var enumBugKeys = __webpack_require__(141); module.exports = Object.keys || function keys(O) { return $keys(O, enumBugKeys); }; /***/ }), /* 45 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var root = __webpack_require__(17); /** Built-in value references. */ var _Symbol = root.Symbol; module.exports = _Symbol; /***/ }), /* 46 */ /***/ (function(module, exports) { "use strict"; /** * Performs a * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * comparison between two values to determine if they are equivalent. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returns `true` if the values are equivalent, else `false`. * @example * * var object = { 'a': 1 }; * var other = { 'a': 1 }; * * _.eq(object, object); * // => true * * _.eq(object, other); * // => false * * _.eq('a', 'a'); * // => true * * _.eq('a', Object('a')); * // => false * * _.eq(NaN, NaN); * // => true */ function eq(value, other) { return value === other || value !== value && other !== other; } module.exports = eq; /***/ }), /* 47 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var arrayLikeKeys = __webpack_require__(245), baseKeysIn = __webpack_require__(501), isArrayLike = __webpack_require__(24); /** * Creates an array of the own and inherited enumerable property names of `object`. * * **Note:** Non-object values are coerced to objects. * * @static * @memberOf _ * @since 3.0.0 * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property names. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.keysIn(new Foo); * // => ['a', 'b', 'c'] (iteration order is not guaranteed) */ function keysIn(object) { return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object); } module.exports = keysIn; /***/ }), /* 48 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var toFinite = __webpack_require__(597); /** * Converts `value` to an integer. * * **Note:** This method is loosely based on * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted integer. * @example * * _.toInteger(3.2); * // => 3 * * _.toInteger(Number.MIN_VALUE); * // => 0 * * _.toInteger(Infinity); * // => 1.7976931348623157e+308 * * _.toInteger('3.2'); * // => 3 */ function toInteger(value) { var result = toFinite(value), remainder = result % 1; return result === result ? remainder ? result - remainder : result : 0; } module.exports = toInteger; /***/ }), /* 49 */ /***/ (function(module, exports) { /* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__; /* WEBPACK VAR INJECTION */}.call(exports, {})) /***/ }), /* 50 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(process) {"use strict"; exports.__esModule = true; exports.File = undefined; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _create = __webpack_require__(9); var _create2 = _interopRequireDefault(_create); var _assign = __webpack_require__(87); var _assign2 = _interopRequireDefault(_assign); var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); var _possibleConstructorReturn2 = __webpack_require__(42); var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2); var _inherits2 = __webpack_require__(41); var _inherits3 = _interopRequireDefault(_inherits2); var _babelHelpers = __webpack_require__(194); var _babelHelpers2 = _interopRequireDefault(_babelHelpers); var _metadata = __webpack_require__(121); var metadataVisitor = _interopRequireWildcard(_metadata); var _convertSourceMap = __webpack_require__(403); var _convertSourceMap2 = _interopRequireDefault(_convertSourceMap); var _optionManager = __webpack_require__(34); var _optionManager2 = _interopRequireDefault(_optionManager); var _pluginPass = __webpack_require__(299); var _pluginPass2 = _interopRequireDefault(_pluginPass); var _babelTraverse = __webpack_require__(7); var _babelTraverse2 = _interopRequireDefault(_babelTraverse); var _sourceMap = __webpack_require__(288); var _sourceMap2 = _interopRequireDefault(_sourceMap); var _babelGenerator = __webpack_require__(186); var _babelGenerator2 = _interopRequireDefault(_babelGenerator); var _babelCodeFrame = __webpack_require__(181); var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame); var _defaults = __webpack_require__(273); var _defaults2 = _interopRequireDefault(_defaults); var _logger = __webpack_require__(120); var _logger2 = _interopRequireDefault(_logger); var _store = __webpack_require__(119); var _store2 = _interopRequireDefault(_store); var _babylon = __webpack_require__(89); var _util = __webpack_require__(122); var util = _interopRequireWildcard(_util); var _path = __webpack_require__(19); var _path2 = _interopRequireDefault(_path); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); var _resolve = __webpack_require__(118); var _resolve2 = _interopRequireDefault(_resolve); var _blockHoist = __webpack_require__(296); var _blockHoist2 = _interopRequireDefault(_blockHoist); var _shadowFunctions = __webpack_require__(297); var _shadowFunctions2 = _interopRequireDefault(_shadowFunctions); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var shebangRegex = /^#!.*/; var INTERNAL_PLUGINS = [[_blockHoist2.default], [_shadowFunctions2.default]]; var errorVisitor = { enter: function enter(path, state) { var loc = path.node.loc; if (loc) { state.loc = loc; path.stop(); } } }; var File = function (_Store) { (0, _inherits3.default)(File, _Store); function File() { var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; var pipeline = arguments[1]; (0, _classCallCheck3.default)(this, File); var _this = (0, _possibleConstructorReturn3.default)(this, _Store.call(this)); _this.pipeline = pipeline; _this.log = new _logger2.default(_this, opts.filename || "unknown"); _this.opts = _this.initOptions(opts); _this.parserOpts = { sourceType: _this.opts.sourceType, sourceFileName: _this.opts.filename, plugins: [] }; _this.pluginVisitors = []; _this.pluginPasses = []; _this.buildPluginsForOptions(_this.opts); if (_this.opts.passPerPreset) { _this.perPresetOpts = []; _this.opts.presets.forEach(function (presetOpts) { var perPresetOpts = (0, _assign2.default)((0, _create2.default)(_this.opts), presetOpts); _this.perPresetOpts.push(perPresetOpts); _this.buildPluginsForOptions(perPresetOpts); }); } _this.metadata = { usedHelpers: [], marked: [], modules: { imports: [], exports: { exported: [], specifiers: [] } } }; _this.dynamicImportTypes = {}; _this.dynamicImportIds = {}; _this.dynamicImports = []; _this.declarations = {}; _this.usedHelpers = {}; _this.path = null; _this.ast = {}; _this.code = ""; _this.shebang = ""; _this.hub = new _babelTraverse.Hub(_this); return _this; } File.prototype.getMetadata = function getMetadata() { var has = false; for (var _iterator = this.ast.program.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var node = _ref; if (t.isModuleDeclaration(node)) { has = true; break; } } if (has) { this.path.traverse(metadataVisitor, this); } }; File.prototype.initOptions = function initOptions(opts) { opts = new _optionManager2.default(this.log, this.pipeline).init(opts); if (opts.inputSourceMap) { opts.sourceMaps = true; } if (opts.moduleId) { opts.moduleIds = true; } opts.basename = _path2.default.basename(opts.filename, _path2.default.extname(opts.filename)); opts.ignore = util.arrayify(opts.ignore, util.regexify); if (opts.only) opts.only = util.arrayify(opts.only, util.regexify); (0, _defaults2.default)(opts, { moduleRoot: opts.sourceRoot }); (0, _defaults2.default)(opts, { sourceRoot: opts.moduleRoot }); (0, _defaults2.default)(opts, { filenameRelative: opts.filename }); var basenameRelative = _path2.default.basename(opts.filenameRelative); (0, _defaults2.default)(opts, { sourceFileName: basenameRelative, sourceMapTarget: basenameRelative }); return opts; }; File.prototype.buildPluginsForOptions = function buildPluginsForOptions(opts) { if (!Array.isArray(opts.plugins)) { return; } var plugins = opts.plugins.concat(INTERNAL_PLUGINS); var currentPluginVisitors = []; var currentPluginPasses = []; for (var _iterator2 = plugins, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var ref = _ref2; var plugin = ref[0], pluginOpts = ref[1]; currentPluginVisitors.push(plugin.visitor); currentPluginPasses.push(new _pluginPass2.default(this, plugin, pluginOpts)); if (plugin.manipulateOptions) { plugin.manipulateOptions(opts, this.parserOpts, this); } } this.pluginVisitors.push(currentPluginVisitors); this.pluginPasses.push(currentPluginPasses); }; File.prototype.getModuleName = function getModuleName() { var opts = this.opts; if (!opts.moduleIds) { return null; } if (opts.moduleId != null && !opts.getModuleId) { return opts.moduleId; } var filenameRelative = opts.filenameRelative; var moduleName = ""; if (opts.moduleRoot != null) { moduleName = opts.moduleRoot + "/"; } if (!opts.filenameRelative) { return moduleName + opts.filename.replace(/^\//, ""); } if (opts.sourceRoot != null) { var sourceRootRegEx = new RegExp("^" + opts.sourceRoot + "\/?"); filenameRelative = filenameRelative.replace(sourceRootRegEx, ""); } filenameRelative = filenameRelative.replace(/\.(\w*?)$/, ""); moduleName += filenameRelative; moduleName = moduleName.replace(/\\/g, "/"); if (opts.getModuleId) { return opts.getModuleId(moduleName) || moduleName; } else { return moduleName; } }; File.prototype.resolveModuleSource = function resolveModuleSource(source) { var resolveModuleSource = this.opts.resolveModuleSource; if (resolveModuleSource) source = resolveModuleSource(source, this.opts.filename); return source; }; File.prototype.addImport = function addImport(source, imported) { var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : imported; var alias = source + ":" + imported; var id = this.dynamicImportIds[alias]; if (!id) { source = this.resolveModuleSource(source); id = this.dynamicImportIds[alias] = this.scope.generateUidIdentifier(name); var specifiers = []; if (imported === "*") { specifiers.push(t.importNamespaceSpecifier(id)); } else if (imported === "default") { specifiers.push(t.importDefaultSpecifier(id)); } else { specifiers.push(t.importSpecifier(id, t.identifier(imported))); } var declar = t.importDeclaration(specifiers, t.stringLiteral(source)); declar._blockHoist = 3; this.path.unshiftContainer("body", declar); } return id; }; File.prototype.addHelper = function addHelper(name) { var declar = this.declarations[name]; if (declar) return declar; if (!this.usedHelpers[name]) { this.metadata.usedHelpers.push(name); this.usedHelpers[name] = true; } var generator = this.get("helperGenerator"); var runtime = this.get("helpersNamespace"); if (generator) { var res = generator(name); if (res) return res; } else if (runtime) { return t.memberExpression(runtime, t.identifier(name)); } var ref = (0, _babelHelpers2.default)(name); var uid = this.declarations[name] = this.scope.generateUidIdentifier(name); if (t.isFunctionExpression(ref) && !ref.id) { ref.body._compact = true; ref._generated = true; ref.id = uid; ref.type = "FunctionDeclaration"; this.path.unshiftContainer("body", ref); } else { ref._compact = true; this.scope.push({ id: uid, init: ref, unique: true }); } return uid; }; File.prototype.addTemplateObject = function addTemplateObject(helperName, strings, raw) { var stringIds = raw.elements.map(function (string) { return string.value; }); var name = helperName + "_" + raw.elements.length + "_" + stringIds.join(","); var declar = this.declarations[name]; if (declar) return declar; var uid = this.declarations[name] = this.scope.generateUidIdentifier("templateObject"); var helperId = this.addHelper(helperName); var init = t.callExpression(helperId, [strings, raw]); init._compact = true; this.scope.push({ id: uid, init: init, _blockHoist: 1.9 }); return uid; }; File.prototype.buildCodeFrameError = function buildCodeFrameError(node, msg) { var Error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SyntaxError; var loc = node && (node.loc || node._loc); var err = new Error(msg); if (loc) { err.loc = loc.start; } else { (0, _babelTraverse2.default)(node, errorVisitor, this.scope, err); err.message += " (This is an error on an internal node. Probably an internal error"; if (err.loc) { err.message += ". Location has been estimated."; } err.message += ")"; } return err; }; File.prototype.mergeSourceMap = function mergeSourceMap(map) { var inputMap = this.opts.inputSourceMap; if (inputMap) { var inputMapConsumer = new _sourceMap2.default.SourceMapConsumer(inputMap); var outputMapConsumer = new _sourceMap2.default.SourceMapConsumer(map); var mergedGenerator = new _sourceMap2.default.SourceMapGenerator({ file: inputMapConsumer.file, sourceRoot: inputMapConsumer.sourceRoot }); var source = outputMapConsumer.sources[0]; inputMapConsumer.eachMapping(function (mapping) { var generatedPosition = outputMapConsumer.generatedPositionFor({ line: mapping.generatedLine, column: mapping.generatedColumn, source: source }); if (generatedPosition.column != null) { mergedGenerator.addMapping({ source: mapping.source, original: mapping.source == null ? null : { line: mapping.originalLine, column: mapping.originalColumn }, generated: generatedPosition }); } }); var mergedMap = mergedGenerator.toJSON(); inputMap.mappings = mergedMap.mappings; return inputMap; } else { return map; } }; File.prototype.parse = function parse(code) { var parseCode = _babylon.parse; var parserOpts = this.opts.parserOpts; if (parserOpts) { parserOpts = (0, _assign2.default)({}, this.parserOpts, parserOpts); if (parserOpts.parser) { if (typeof parserOpts.parser === "string") { var dirname = _path2.default.dirname(this.opts.filename) || process.cwd(); var parser = (0, _resolve2.default)(parserOpts.parser, dirname); if (parser) { parseCode = __webpack_require__(178)(parser).parse; } else { throw new Error("Couldn't find parser " + parserOpts.parser + " with \"parse\" method " + ("relative to directory " + dirname)); } } else { parseCode = parserOpts.parser; } parserOpts.parser = { parse: function parse(source) { return (0, _babylon.parse)(source, parserOpts); } }; } } this.log.debug("Parse start"); var ast = parseCode(code, parserOpts || this.parserOpts); this.log.debug("Parse stop"); return ast; }; File.prototype._addAst = function _addAst(ast) { this.path = _babelTraverse.NodePath.get({ hub: this.hub, parentPath: null, parent: ast, container: ast, key: "program" }).setContext(); this.scope = this.path.scope; this.ast = ast; this.getMetadata(); }; File.prototype.addAst = function addAst(ast) { this.log.debug("Start set AST"); this._addAst(ast); this.log.debug("End set AST"); }; File.prototype.transform = function transform() { for (var i = 0; i < this.pluginPasses.length; i++) { var pluginPasses = this.pluginPasses[i]; this.call("pre", pluginPasses); this.log.debug("Start transform traverse"); var visitor = _babelTraverse2.default.visitors.merge(this.pluginVisitors[i], pluginPasses, this.opts.wrapPluginVisitorMethod); (0, _babelTraverse2.default)(this.ast, visitor, this.scope); this.log.debug("End transform traverse"); this.call("post", pluginPasses); } return this.generate(); }; File.prototype.wrap = function wrap(code, callback) { code = code + ""; try { if (this.shouldIgnore()) { return this.makeResult({ code: code, ignored: true }); } else { return callback(); } } catch (err) { if (err._babel) { throw err; } else { err._babel = true; } var message = err.message = this.opts.filename + ": " + err.message; var loc = err.loc; if (loc) { err.codeFrame = (0, _babelCodeFrame2.default)(code, loc.line, loc.column + 1, this.opts); message += "\n" + err.codeFrame; } if (process.browser) { err.message = message; } if (err.stack) { var newStack = err.stack.replace(err.message, message); err.stack = newStack; } throw err; } }; File.prototype.addCode = function addCode(code) { code = (code || "") + ""; code = this.parseInputSourceMap(code); this.code = code; }; File.prototype.parseCode = function parseCode() { this.parseShebang(); var ast = this.parse(this.code); this.addAst(ast); }; File.prototype.shouldIgnore = function shouldIgnore() { var opts = this.opts; return util.shouldIgnore(opts.filename, opts.ignore, opts.only); }; File.prototype.call = function call(key, pluginPasses) { for (var _iterator3 = pluginPasses, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) { var _ref3; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref3 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref3 = _i3.value; } var pass = _ref3; var plugin = pass.plugin; var fn = plugin[key]; if (fn) fn.call(pass, this); } }; File.prototype.parseInputSourceMap = function parseInputSourceMap(code) { var opts = this.opts; if (opts.inputSourceMap !== false) { var inputMap = _convertSourceMap2.default.fromSource(code); if (inputMap) { opts.inputSourceMap = inputMap.toObject(); code = _convertSourceMap2.default.removeComments(code); } } return code; }; File.prototype.parseShebang = function parseShebang() { var shebangMatch = shebangRegex.exec(this.code); if (shebangMatch) { this.shebang = shebangMatch[0]; this.code = this.code.replace(shebangRegex, ""); } }; File.prototype.makeResult = function makeResult(_ref4) { var code = _ref4.code, map = _ref4.map, ast = _ref4.ast, ignored = _ref4.ignored; var result = { metadata: null, options: this.opts, ignored: !!ignored, code: null, ast: null, map: map || null }; if (this.opts.code) { result.code = code; } if (this.opts.ast) { result.ast = ast; } if (this.opts.metadata) { result.metadata = this.metadata; } return result; }; File.prototype.generate = function generate() { var opts = this.opts; var ast = this.ast; var result = { ast: ast }; if (!opts.code) return this.makeResult(result); var gen = _babelGenerator2.default; if (opts.generatorOpts.generator) { gen = opts.generatorOpts.generator; if (typeof gen === "string") { var dirname = _path2.default.dirname(this.opts.filename) || process.cwd(); var generator = (0, _resolve2.default)(gen, dirname); if (generator) { gen = __webpack_require__(178)(generator).print; } else { throw new Error("Couldn't find generator " + gen + " with \"print\" method relative " + ("to directory " + dirname)); } } } this.log.debug("Generation start"); var _result = gen(ast, opts.generatorOpts ? (0, _assign2.default)(opts, opts.generatorOpts) : opts, this.code); result.code = _result.code; result.map = _result.map; this.log.debug("Generation end"); if (this.shebang) { result.code = this.shebang + "\n" + result.code; } if (result.map) { result.map = this.mergeSourceMap(result.map); } if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") { result.code += "\n" + _convertSourceMap2.default.fromObject(result.map).toComment(); } if (opts.sourceMaps === "inline") { result.map = null; } return this.makeResult(result); }; return File; }(_store2.default); exports.default = File; exports.File = File; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8))) /***/ }), /* 51 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(process) {"use strict"; exports.__esModule = true; var _assign = __webpack_require__(87); var _assign2 = _interopRequireDefault(_assign); var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); exports.default = buildConfigChain; var _resolve = __webpack_require__(118); var _resolve2 = _interopRequireDefault(_resolve); var _json = __webpack_require__(470); var _json2 = _interopRequireDefault(_json); var _pathIsAbsolute = __webpack_require__(604); var _pathIsAbsolute2 = _interopRequireDefault(_pathIsAbsolute); var _path = __webpack_require__(19); var _path2 = _interopRequireDefault(_path); var _fs = __webpack_require__(115); var _fs2 = _interopRequireDefault(_fs); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var existsCache = {}; var jsonCache = {}; var BABELIGNORE_FILENAME = ".babelignore"; var BABELRC_FILENAME = ".babelrc"; var PACKAGE_FILENAME = "package.json"; function exists(filename) { var cached = existsCache[filename]; if (cached == null) { return existsCache[filename] = _fs2.default.existsSync(filename); } else { return cached; } } function buildConfigChain() { var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; var log = arguments[1]; var filename = opts.filename; var builder = new ConfigChainBuilder(log); if (opts.babelrc !== false) { builder.findConfigs(filename); } builder.mergeConfig({ options: opts, alias: "base", dirname: filename && _path2.default.dirname(filename) }); return builder.configs; } var ConfigChainBuilder = function () { function ConfigChainBuilder(log) { (0, _classCallCheck3.default)(this, ConfigChainBuilder); this.resolvedConfigs = []; this.configs = []; this.log = log; } ConfigChainBuilder.prototype.findConfigs = function findConfigs(loc) { if (!loc) return; if (!(0, _pathIsAbsolute2.default)(loc)) { loc = _path2.default.join(process.cwd(), loc); } var foundConfig = false; var foundIgnore = false; while (loc !== (loc = _path2.default.dirname(loc))) { if (!foundConfig) { var configLoc = _path2.default.join(loc, BABELRC_FILENAME); if (exists(configLoc)) { this.addConfig(configLoc); foundConfig = true; } var pkgLoc = _path2.default.join(loc, PACKAGE_FILENAME); if (!foundConfig && exists(pkgLoc)) { foundConfig = this.addConfig(pkgLoc, "babel", JSON); } } if (!foundIgnore) { var ignoreLoc = _path2.default.join(loc, BABELIGNORE_FILENAME); if (exists(ignoreLoc)) { this.addIgnoreConfig(ignoreLoc); foundIgnore = true; } } if (foundIgnore && foundConfig) return; } }; ConfigChainBuilder.prototype.addIgnoreConfig = function addIgnoreConfig(loc) { var file = _fs2.default.readFileSync(loc, "utf8"); var lines = file.split("\n"); lines = lines.map(function (line) { return line.replace(/#(.*?)$/, "").trim(); }).filter(function (line) { return !!line; }); if (lines.length) { this.mergeConfig({ options: { ignore: lines }, alias: loc, dirname: _path2.default.dirname(loc) }); } }; ConfigChainBuilder.prototype.addConfig = function addConfig(loc, key) { var json = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _json2.default; if (this.resolvedConfigs.indexOf(loc) >= 0) { return false; } this.resolvedConfigs.push(loc); var content = _fs2.default.readFileSync(loc, "utf8"); var options = void 0; try { options = jsonCache[content] = jsonCache[content] || json.parse(content); if (key) options = options[key]; } catch (err) { err.message = loc + ": Error while parsing JSON - " + err.message; throw err; } this.mergeConfig({ options: options, alias: loc, dirname: _path2.default.dirname(loc) }); return !!options; }; ConfigChainBuilder.prototype.mergeConfig = function mergeConfig(_ref) { var options = _ref.options, alias = _ref.alias, loc = _ref.loc, dirname = _ref.dirname; if (!options) { return false; } options = (0, _assign2.default)({}, options); dirname = dirname || process.cwd(); loc = loc || alias; if (options.extends) { var extendsLoc = (0, _resolve2.default)(options.extends, dirname); if (extendsLoc) { this.addConfig(extendsLoc); } else { if (this.log) this.log.error("Couldn't resolve extends clause of " + options.extends + " in " + alias); } delete options.extends; } this.configs.push({ options: options, alias: alias, loc: loc, dirname: dirname }); var envOpts = void 0; var envKey = process.env.BABEL_ENV || ("production") || "development"; if (options.env) { envOpts = options.env[envKey]; delete options.env; } this.mergeConfig({ options: envOpts, alias: alias + ".env." + envKey, dirname: dirname }); }; return ConfigChainBuilder; }(); module.exports = exports["default"]; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8))) /***/ }), /* 52 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.config = undefined; exports.normaliseOptions = normaliseOptions; var _parsers = __webpack_require__(53); var parsers = _interopRequireWildcard(_parsers); var _config = __webpack_require__(33); var _config2 = _interopRequireDefault(_config); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } exports.config = _config2.default; function normaliseOptions() { var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; for (var key in options) { var val = options[key]; if (val == null) continue; var opt = _config2.default[key]; if (opt && opt.alias) opt = _config2.default[opt.alias]; if (!opt) continue; var parser = parsers[opt.type]; if (parser) val = parser(val); options[key] = val; } return options; } /***/ }), /* 53 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.filename = undefined; exports.boolean = boolean; exports.booleanString = booleanString; exports.list = list; var _slash = __webpack_require__(284); var _slash2 = _interopRequireDefault(_slash); var _util = __webpack_require__(122); var util = _interopRequireWildcard(_util); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var filename = exports.filename = _slash2.default; function boolean(val) { return !!val; } function booleanString(val) { return util.booleanify(val); } function list(val) { return util.list(val); } /***/ }), /* 54 */ /***/ (function(module, exports) { "use strict"; module.exports = { "auxiliaryComment": { "message": "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, "blacklist": { "message": "Put the specific transforms you want in the `plugins` option" }, "breakConfig": { "message": "This is not a necessary option in Babel 6" }, "experimental": { "message": "Put the specific transforms you want in the `plugins` option" }, "externalHelpers": { "message": "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, "extra": { "message": "" }, "jsxPragma": { "message": "use the `pragma` option in the `react-jsx` plugin . Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, "loose": { "message": "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, "metadataUsedHelpers": { "message": "Not required anymore as this is enabled by default" }, "modules": { "message": "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, "nonStandard": { "message": "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, "optional": { "message": "Put the specific transforms you want in the `plugins` option" }, "sourceMapName": { "message": "Use the `sourceMapTarget` option" }, "stage": { "message": "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, "whitelist": { "message": "Put the specific transforms you want in the `plugins` option" } }; /***/ }), /* 55 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var ctx = __webpack_require__(43); var call = __webpack_require__(428); var isArrayIter = __webpack_require__(427); var anObject = __webpack_require__(21); var toLength = __webpack_require__(153); var getIterFn = __webpack_require__(238); var BREAK = {}; var RETURN = {}; var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) { var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable); var f = ctx(fn, that, entries ? 2 : 1); var index = 0; var length, step, iterator, result; if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) { result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]); if (result === BREAK || result === RETURN) return result; } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) { result = call(iterator, f, step.value, entries); if (result === BREAK || result === RETURN) return result; } }; _exports.BREAK = BREAK; _exports.RETURN = RETURN; /***/ }), /* 56 */ /***/ (function(module, exports) { "use strict"; module.exports = {}; /***/ }), /* 57 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; var META = __webpack_require__(95)('meta'); var isObject = __webpack_require__(16); var has = __webpack_require__(28); var setDesc = __webpack_require__(23).f; var id = 0; var isExtensible = Object.isExtensible || function () { return true; }; var FREEZE = !__webpack_require__(27)(function () { return isExtensible(Object.preventExtensions({})); }); var setMeta = function setMeta(it) { setDesc(it, META, { value: { i: 'O' + ++id, // object ID w: {} // weak collections IDs } }); }; var fastKey = function fastKey(it, create) { // return primitive with prefix if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it; if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return 'F'; // not necessary to add metadata if (!create) return 'E'; // add missing metadata setMeta(it); // return object ID }return it[META].i; }; var getWeak = function getWeak(it, create) { if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return true; // not necessary to add metadata if (!create) return false; // add missing metadata setMeta(it); // return hash weak collections IDs }return it[META].w; }; // add metadata on freeze-family methods calling var onFreeze = function onFreeze(it) { if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it); return it; }; var meta = module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze }; /***/ }), /* 58 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isObject = __webpack_require__(16); module.exports = function (it, TYPE) { if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!'); return it; }; /***/ }), /* 59 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(440); var global = __webpack_require__(15); var hide = __webpack_require__(29); var Iterators = __webpack_require__(56); var TO_STRING_TAG = __webpack_require__(13)('toStringTag'); var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(','); for (var i = 0; i < DOMIterables.length; i++) { var NAME = DOMIterables[i]; var Collection = global[NAME]; var proto = Collection && Collection.prototype; if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME); Iterators[NAME] = Iterators.Array; } /***/ }), /* 60 */ /***/ (function(module, exports) { "use strict"; /** * A specialized version of `_.map` for arrays without support for iteratee * shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} iteratee The function invoked per iteration. * @returns {Array} Returns the new mapped array. */ function arrayMap(array, iteratee) { var index = -1, length = array == null ? 0 : array.length, result = Array(length); while (++index < length) { result[index] = iteratee(array[index], index, array); } return result; } module.exports = arrayMap; /***/ }), /* 61 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; var baseMatches = __webpack_require__(502), baseMatchesProperty = __webpack_require__(503), identity = __webpack_require__(110), isArray = __webpack_require__(6), property = __webpack_require__(592); /** * The base implementation of `_.iteratee`. * * @private * @param {*} [value=_.identity] The value to convert to an iteratee. * @returns {Function} Returns the iteratee. */ function baseIteratee(value) { // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9. // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details. if (typeof value == 'function') { return value; } if (value == null) { return identity; } if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') { return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value); } return property(value); } module.exports = baseIteratee; /***/ }), /* 62 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; var baseGetTag = __webpack_require__(30), isObjectLike = __webpack_require__(25); /** `Object#toString` result references. */ var symbolTag = '[object Symbol]'; /** * Checks if `value` is classified as a `Symbol` primitive or object. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is a symbol, else `false`. * @example * * _.isSymbol(Symbol.iterator); * // => true * * _.isSymbol('abc'); * // => false */ function isSymbol(value) { return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag; } module.exports = isSymbol; /***/ }), /* 63 */ /***/ (function(module, exports) { 'use strict'; /* -*- Mode: js; js-indent-level: 2; -*- */ /* * Copyright 2011 Mozilla Foundation and contributors * Licensed under the New BSD license. See LICENSE or: * http://opensource.org/licenses/BSD-3-Clause */ /** * This is a helper function for getting values from parameter/options * objects. * * @param args The object we are extracting values from * @param name The name of the property we are getting. * @param defaultValue An optional value to return if the property is missing * from the object. If this is not specified and the property is missing, an * error will be thrown. */ function getArg(aArgs, aName, aDefaultValue) { if (aName in aArgs) { return aArgs[aName]; } else if (arguments.length === 3) { return aDefaultValue; } else { throw new Error('"' + aName + '" is a required argument.'); } } exports.getArg = getArg; var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/; var dataUrlRegexp = /^data:.+\,.+$/; function urlParse(aUrl) { var match = aUrl.match(urlRegexp); if (!match) { return null; } return { scheme: match[1], auth: match[2], host: match[3], port: match[4], path: match[5] }; } exports.urlParse = urlParse; function urlGenerate(aParsedUrl) { var url = ''; if (aParsedUrl.scheme) { url += aParsedUrl.scheme + ':'; } url += '//'; if (aParsedUrl.auth) { url += aParsedUrl.auth + '@'; } if (aParsedUrl.host) { url += aParsedUrl.host; } if (aParsedUrl.port) { url += ":" + aParsedUrl.port; } if (aParsedUrl.path) { url += aParsedUrl.path; } return url; } exports.urlGenerate = urlGenerate; /** * Normalizes a path, or the path portion of a URL: * * - Replaces consecutive slashes with one slash. * - Removes unnecessary '.' parts. * - Removes unnecessary '<dir>/..' parts. * * Based on code in the Node.js 'path' core module. * * @param aPath The path or url to normalize. */ function normalize(aPath) { var path = aPath; var url = urlParse(aPath); if (url) { if (!url.path) { return aPath; } path = url.path; } var isAbsolute = exports.isAbsolute(path); var parts = path.split(/\/+/); for (var part, up = 0, i = parts.length - 1; i >= 0; i--) { part = parts[i]; if (part === '.') { parts.splice(i, 1); } else if (part === '..') { up++; } else if (up > 0) { if (part === '') { // The first part is blank if the path is absolute. Trying to go // above the root is a no-op. Therefore we can remove all '..' parts // directly after the root. parts.splice(i + 1, up); up = 0; } else { parts.splice(i, 2); up--; } } } path = parts.join('/'); if (path === '') { path = isAbsolute ? '/' : '.'; } if (url) { url.path = path; return urlGenerate(url); } return path; } exports.normalize = normalize; /** * Joins two paths/URLs. * * @param aRoot The root path or URL. * @param aPath The path or URL to be joined with the root. * * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a * scheme-relative URL: Then the scheme of aRoot, if any, is prepended * first. * - Otherwise aPath is a path. If aRoot is a URL, then its path portion * is updated with the result and aRoot is returned. Otherwise the result * is returned. * - If aPath is absolute, the result is aPath. * - Otherwise the two paths are joined with a slash. * - Joining for example 'http://' and 'www.example.com' is also supported. */ function join(aRoot, aPath) { if (aRoot === "") { aRoot = "."; } if (aPath === "") { aPath = "."; } var aPathUrl = urlParse(aPath); var aRootUrl = urlParse(aRoot); if (aRootUrl) { aRoot = aRootUrl.path || '/'; } // `join(foo, '//www.example.org')` if (aPathUrl && !aPathUrl.scheme) { if (aRootUrl) { aPathUrl.scheme = aRootUrl.scheme; } return urlGenerate(aPathUrl); } if (aPathUrl || aPath.match(dataUrlRegexp)) { return aPath; } // `join('http://', 'www.example.com')` if (aRootUrl && !aRootUrl.host && !aRootUrl.path) { aRootUrl.host = aPath; return urlGenerate(aRootUrl); } var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath); if (aRootUrl) { aRootUrl.path = joined; return urlGenerate(aRootUrl); } return joined; } exports.join = join; exports.isAbsolute = function (aPath) { return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp); }; /** * Make a path relative to a URL or another path. * * @param aRoot The root path or URL. * @param aPath The path or URL to be made relative to aRoot. */ function relative(aRoot, aPath) { if (aRoot === "") { aRoot = "."; } aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply // checking whether the root is a prefix of the path won't work. Instead, we // need to remove components from the root one by one, until either we find // a prefix that fits, or we run out of components to remove. var level = 0; while (aPath.indexOf(aRoot + '/') !== 0) { var index = aRoot.lastIndexOf("/"); if (index < 0) { return aPath; } // If the only part of the root that is left is the scheme (i.e. http://, // file:///, etc.), one or more slashes (/), or simply nothing at all, we // have exhausted all components, so the path is not relative to the root. aRoot = aRoot.slice(0, index); if (aRoot.match(/^([^\/]+:\/)?\/*$/)) { return aPath; } ++level; } // Make sure we add a "../" for each component we removed from the root. return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1); } exports.relative = relative; var supportsNullProto = function () { var obj = Object.create(null); return !('__proto__' in obj); }(); function identity(s) { return s; } /** * Because behavior goes wacky when you set `__proto__` on objects, we * have to prefix all the strings in our set with an arbitrary character. * * See https://github.com/mozilla/source-map/pull/31 and * https://github.com/mozilla/source-map/issues/30 * * @param String aStr */ function toSetString(aStr) { if (isProtoString(aStr)) { return '$' + aStr; } return aStr; } exports.toSetString = supportsNullProto ? identity : toSetString; function fromSetString(aStr) { if (isProtoString(aStr)) { return aStr.slice(1); } return aStr; } exports.fromSetString = supportsNullProto ? identity : fromSetString; function isProtoString(s) { if (!s) { return false; } var length = s.length; if (length < 9 /* "__proto__".length */) { return false; } if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) { return false; } for (var i = length - 10; i >= 0; i--) { if (s.charCodeAt(i) !== 36 /* '$' */) { return false; } } return true; } /** * Comparator between two mappings where the original positions are compared. * * Optionally pass in `true` as `onlyCompareGenerated` to consider two * mappings with the same original source/line/column, but different generated * line and column the same. Useful when searching for a mapping with a * stubbed out mapping. */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) { var cmp = mappingA.source - mappingB.source; if (cmp !== 0) { return cmp; } cmp = mappingA.originalLine - mappingB.originalLine; if (cmp !== 0) { return cmp; } cmp = mappingA.originalColumn - mappingB.originalColumn; if (cmp !== 0 || onlyCompareOriginal) { return cmp; } cmp = mappingA.generatedColumn - mappingB.generatedColumn; if (cmp !== 0) { return cmp; } cmp = mappingA.generatedLine - mappingB.generatedLine; if (cmp !== 0) { return cmp; } return mappingA.name - mappingB.name; } exports.compareByOriginalPositions = compareByOriginalPositions; /** * Comparator between two mappings with deflated source and name indices where * the generated positions are compared. * * Optionally pass in `true` as `onlyCompareGenerated` to consider two * mappings with the same generated line and column, but different * source/name/original line and column the same. Useful when searching for a * mapping with a stubbed out mapping. */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) { var cmp = mappingA.generatedLine - mappingB.generatedLine; if (cmp !== 0) { return cmp; } cmp = mappingA.generatedColumn - mappingB.generatedColumn; if (cmp !== 0 || onlyCompareGenerated) { return cmp; } cmp = mappingA.source - mappingB.source; if (cmp !== 0) { return cmp; } cmp = mappingA.originalLine - mappingB.originalLine; if (cmp !== 0) { return cmp; } cmp = mappingA.originalColumn - mappingB.originalColumn; if (cmp !== 0) { return cmp; } return mappingA.name - mappingB.name; } exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated; function strcmp(aStr1, aStr2) { if (aStr1 === aStr2) { return 0; } if (aStr1 > aStr2) { return 1; } return -1; } /** * Comparator between two mappings with inflated source and name strings where * the generated positions are compared. */ function compareByGeneratedPositionsInflated(mappingA, mappingB) { var cmp = mappingA.generatedLine - mappingB.generatedLine; if (cmp !== 0) { return cmp; } cmp = mappingA.generatedColumn - mappingB.generatedColumn; if (cmp !== 0) { return cmp; } cmp = strcmp(mappingA.source, mappingB.source); if (cmp !== 0) { return cmp; } cmp = mappingA.originalLine - mappingB.originalLine; if (cmp !== 0) { return cmp; } cmp = mappingA.originalColumn - mappingB.originalColumn; if (cmp !== 0) { return cmp; } return strcmp(mappingA.name, mappingB.name); } exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated; /***/ }), /* 64 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {'use strict'; // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js // original notice: /*! * The buffer module from node.js, for the browser. * * @author Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license MIT */ var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; function compare(a, b) { if (a === b) { return 0; } var x = a.length; var y = b.length; for (var i = 0, len = Math.min(x, y); i < len; ++i) { if (a[i] !== b[i]) { x = a[i]; y = b[i]; break; } } if (x < y) { return -1; } if (y < x) { return 1; } return 0; } function isBuffer(b) { if (global.Buffer && typeof global.Buffer.isBuffer === 'function') { return global.Buffer.isBuffer(b); } return !!(b != null && b._isBuffer); } // based on node assert, original notice: // http://wiki.commonjs.org/wiki/Unit_Testing/1.0 // // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8! // // Originally from narwhal.js (http://narwhaljs.org) // Copyright (c) 2009 Thomas Robinson <280north.com> // // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the 'Software'), to // deal in the Software without restriction, including without limitation the // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or // sell copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in // all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. var util = __webpack_require__(117); var hasOwn = Object.prototype.hasOwnProperty; var pSlice = Array.prototype.slice; var functionsHaveNames = function () { return function foo() {}.name === 'foo'; }(); function pToString(obj) { return Object.prototype.toString.call(obj); } function isView(arrbuf) { if (isBuffer(arrbuf)) { return false; } if (typeof global.ArrayBuffer !== 'function') { return false; } if (typeof ArrayBuffer.isView === 'function') { return ArrayBuffer.isView(arrbuf); } if (!arrbuf) { return false; } if (arrbuf instanceof DataView) { return true; } if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) { return true; } return false; } // 1. The assert module provides functions that throw // AssertionError's when particular conditions are not met. The // assert module must conform to the following interface. var assert = module.exports = ok; // 2. The AssertionError is defined in assert. // new assert.AssertionError({ message: message, // actual: actual, // expected: expected }) var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js function getName(func) { if (!util.isFunction(func)) { return; } if (functionsHaveNames) { return func.name; } var str = func.toString(); var match = str.match(regex); return match && match[1]; } assert.AssertionError = function AssertionError(options) { this.name = 'AssertionError'; this.actual = options.actual; this.expected = options.expected; this.operator = options.operator; if (options.message) { this.message = options.message; this.generatedMessage = false; } else { this.message = getMessage(this); this.generatedMessage = true; } var stackStartFunction = options.stackStartFunction || fail; if (Error.captureStackTrace) { Error.captureStackTrace(this, stackStartFunction); } else { // non v8 browsers so we can have a stacktrace var err = new Error(); if (err.stack) { var out = err.stack; // try to strip useless frames var fn_name = getName(stackStartFunction); var idx = out.indexOf('\n' + fn_name); if (idx >= 0) { // once we have located the function frame // we need to strip out everything before it (and its line) var next_line = out.indexOf('\n', idx + 1); out = out.substring(next_line + 1); } this.stack = out; } } }; // assert.AssertionError instanceof Error util.inherits(assert.AssertionError, Error); function truncate(s, n) { if (typeof s === 'string') { return s.length < n ? s : s.slice(0, n); } else { return s; } } function inspect(something) { if (functionsHaveNames || !util.isFunction(something)) { return util.inspect(something); } var rawname = getName(something); var name = rawname ? ': ' + rawname : ''; return '[Function' + name + ']'; } function getMessage(self) { return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128); } // At present only the three keys mentioned above are used and // understood by the spec. Implementations or sub modules can pass // other keys to the AssertionError's constructor - they will be // ignored. // 3. All of the following functions must throw an AssertionError // when a corresponding condition is not met, with a message that // may be undefined if not provided. All assertion methods provide // both the actual and expected values to the assertion error for // display purposes. function fail(actual, expected, message, operator, stackStartFunction) { throw new assert.AssertionError({ message: message, actual: actual, expected: expected, operator: operator, stackStartFunction: stackStartFunction }); } // EXTENSION! allows for well behaved errors defined elsewhere. assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined // by !!guard. // assert.ok(guard, message_opt); // This statement is equivalent to assert.equal(true, !!guard, // message_opt);. To test strictly for the value true, use // assert.strictEqual(true, guard, message_opt);. function ok(value, message) { if (!value) fail(value, true, message, '==', assert.ok); } assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with // ==. // assert.equal(actual, expected, message_opt); assert.equal = function equal(actual, expected, message) { if (actual != expected) fail(actual, expected, message, '==', assert.equal); }; // 6. The non-equality assertion tests for whether two objects are not equal // with != assert.notEqual(actual, expected, message_opt); assert.notEqual = function notEqual(actual, expected, message) { if (actual == expected) { fail(actual, expected, message, '!=', assert.notEqual); } }; // 7. The equivalence assertion tests a deep equality relation. // assert.deepEqual(actual, expected, message_opt); assert.deepEqual = function deepEqual(actual, expected, message) { if (!_deepEqual(actual, expected, false)) { fail(actual, expected, message, 'deepEqual', assert.deepEqual); } }; assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) { if (!_deepEqual(actual, expected, true)) { fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual); } }; function _deepEqual(actual, expected, strict, memos) { // 7.1. All identical values are equivalent, as determined by ===. if (actual === expected) { return true; } else if (isBuffer(actual) && isBuffer(expected)) { return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is // equivalent if it is also a Date object that refers to the same time. } else if (util.isDate(actual) && util.isDate(expected)) { return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is // equivalent if it is also a RegExp object with the same source and // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`). } else if (util.isRegExp(actual) && util.isRegExp(expected)) { return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object', // equivalence is determined by ==. } else if ((actual === null || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) !== 'object') && (expected === null || (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) !== 'object')) { return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying // ArrayBuffers in a Buffer each to increase performance // This optimization requires the arrays to have the same type as checked by // Object.prototype.toString (aka pToString). Never perform binary // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their // bit patterns are not identical. } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) { return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is // determined by having the same number of owned properties (as verified // with Object.prototype.hasOwnProperty.call), the same set of keys // (although not necessarily the same order), equivalent values for every // corresponding key, and an identical 'prototype' property. Note: this // accounts for both named and indexed properties on Arrays. } else if (isBuffer(actual) !== isBuffer(expected)) { return false; } else { memos = memos || { actual: [], expected: [] }; var actualIndex = memos.actual.indexOf(actual); if (actualIndex !== -1) { if (actualIndex === memos.expected.indexOf(expected)) { return true; } } memos.actual.push(actual); memos.expected.push(expected); return objEquiv(actual, expected, strict, memos); } } function isArguments(object) { return Object.prototype.toString.call(object) == '[object Arguments]'; } function objEquiv(a, b, strict, actualVisitedObjects) { if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b; if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false; var aIsArgs = isArguments(a); var bIsArgs = isArguments(b); if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false; if (aIsArgs) { a = pSlice.call(a); b = pSlice.call(b); return _deepEqual(a, b, strict); } var ka = objectKeys(a); var kb = objectKeys(b); var key, i; // having the same number of owned properties (keys incorporates // hasOwnProperty) if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order), ka.sort(); kb.sort(); //~~~cheap key test for (i = ka.length - 1; i >= 0; i--) { if (ka[i] !== kb[i]) return false; } //equivalent values for every corresponding key, and //~~~possibly expensive deep test for (i = ka.length - 1; i >= 0; i--) { key = ka[i]; if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false; } return true; } // 8. The non-equivalence assertion tests for any deep inequality. // assert.notDeepEqual(actual, expected, message_opt); assert.notDeepEqual = function notDeepEqual(actual, expected, message) { if (_deepEqual(actual, expected, false)) { fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual); } }; assert.notDeepStrictEqual = notDeepStrictEqual; function notDeepStrictEqual(actual, expected, message) { if (_deepEqual(actual, expected, true)) { fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual); } } // 9. The strict equality assertion tests strict equality, as determined by ===. // assert.strictEqual(actual, expected, message_opt); assert.strictEqual = function strictEqual(actual, expected, message) { if (actual !== expected) { fail(actual, expected, message, '===', assert.strictEqual); } }; // 10. The strict non-equality assertion tests for strict inequality, as // determined by !==. assert.notStrictEqual(actual, expected, message_opt); assert.notStrictEqual = function notStrictEqual(actual, expected, message) { if (actual === expected) { fail(actual, expected, message, '!==', assert.notStrictEqual); } }; function expectedException(actual, expected) { if (!actual || !expected) { return false; } if (Object.prototype.toString.call(expected) == '[object RegExp]') { return expected.test(actual); } try { if (actual instanceof expected) { return true; } } catch (e) { // Ignore. The instanceof check doesn't work for arrow functions. } if (Error.isPrototypeOf(expected)) { return false; } return expected.call({}, actual) === true; } function _tryBlock(block) { var error; try { block(); } catch (e) { error = e; } return error; } function _throws(shouldThrow, block, expected, message) { var actual; if (typeof block !== 'function') { throw new TypeError('"block" argument must be a function'); } if (typeof expected === 'string') { message = expected; expected = null; } actual = _tryBlock(block); message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.'); if (shouldThrow && !actual) { fail(actual, expected, 'Missing expected exception' + message); } var userProvidedMessage = typeof message === 'string'; var isUnwantedException = !shouldThrow && util.isError(actual); var isUnexpectedException = !shouldThrow && actual && !expected; if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) { fail(actual, expected, 'Got unwanted exception' + message); } if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) { throw actual; } } // 11. Expected to throw an error: // assert.throws(block, Error_opt, message_opt); assert.throws = function (block, /*optional*/error, /*optional*/message) { _throws(true, block, error, message); }; // EXTENSION! This is annoying to write outside this module. assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) { _throws(false, block, error, message); }; assert.ifError = function (err) { if (err) throw err; }; var objectKeys = Object.keys || function (obj) { var keys = []; for (var key in obj) { if (hasOwn.call(obj, key)) keys.push(key); } return keys; }; /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 65 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); var _possibleConstructorReturn2 = __webpack_require__(42); var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2); var _inherits2 = __webpack_require__(41); var _inherits3 = _interopRequireDefault(_inherits2); var _optionManager = __webpack_require__(34); var _optionManager2 = _interopRequireDefault(_optionManager); var _babelMessages = __webpack_require__(20); var messages = _interopRequireWildcard(_babelMessages); var _store = __webpack_require__(119); var _store2 = _interopRequireDefault(_store); var _babelTraverse = __webpack_require__(7); var _babelTraverse2 = _interopRequireDefault(_babelTraverse); var _assign = __webpack_require__(174); var _assign2 = _interopRequireDefault(_assign); var _clone = __webpack_require__(109); var _clone2 = _interopRequireDefault(_clone); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var GLOBAL_VISITOR_PROPS = ["enter", "exit"]; var Plugin = function (_Store) { (0, _inherits3.default)(Plugin, _Store); function Plugin(plugin, key) { (0, _classCallCheck3.default)(this, Plugin); var _this = (0, _possibleConstructorReturn3.default)(this, _Store.call(this)); _this.initialized = false; _this.raw = (0, _assign2.default)({}, plugin); _this.key = _this.take("name") || key; _this.manipulateOptions = _this.take("manipulateOptions"); _this.post = _this.take("post"); _this.pre = _this.take("pre"); _this.visitor = _this.normaliseVisitor((0, _clone2.default)(_this.take("visitor")) || {}); return _this; } Plugin.prototype.take = function take(key) { var val = this.raw[key]; delete this.raw[key]; return val; }; Plugin.prototype.chain = function chain(target, key) { if (!target[key]) return this[key]; if (!this[key]) return target[key]; var fns = [target[key], this[key]]; return function () { var val = void 0; for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) { args[_key] = arguments[_key]; } for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var fn = _ref; if (fn) { var ret = fn.apply(this, args); if (ret != null) val = ret; } } return val; }; }; Plugin.prototype.maybeInherit = function maybeInherit(loc) { var inherits = this.take("inherits"); if (!inherits) return; inherits = _optionManager2.default.normalisePlugin(inherits, loc, "inherits"); this.manipulateOptions = this.chain(inherits, "manipulateOptions"); this.post = this.chain(inherits, "post"); this.pre = this.chain(inherits, "pre"); this.visitor = _babelTraverse2.default.visitors.merge([inherits.visitor, this.visitor]); }; Plugin.prototype.init = function init(loc, i) { if (this.initialized) return; this.initialized = true; this.maybeInherit(loc); for (var key in this.raw) { throw new Error(messages.get("pluginInvalidProperty", loc, i, key)); } }; Plugin.prototype.normaliseVisitor = function normaliseVisitor(visitor) { for (var _iterator2 = GLOBAL_VISITOR_PROPS, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var key = _ref2; if (visitor[key]) { throw new Error("Plugins aren't allowed to specify catch-all enter/exit handlers. " + "Please target individual nodes."); } } _babelTraverse2.default.explode(visitor); return visitor; }; return Plugin; }(_store2.default); exports.default = Plugin; module.exports = exports["default"]; /***/ }), /* 66 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); exports.default = function (_ref) { var messages = _ref.messages; return { visitor: { Scope: function Scope(_ref2) { var scope = _ref2.scope; for (var name in scope.bindings) { var binding = scope.bindings[name]; if (binding.kind !== "const" && binding.kind !== "module") continue; for (var _iterator = binding.constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref3; if (_isArray) { if (_i >= _iterator.length) break; _ref3 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref3 = _i.value; } var violation = _ref3; throw violation.buildCodeFrameError(messages.get("readOnly", name)); } } } } }; }; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 67 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function () { return { manipulateOptions: function manipulateOptions(opts, parserOpts) { parserOpts.plugins.push("asyncFunctions"); } }; }; module.exports = exports["default"]; /***/ }), /* 68 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function (_ref) { var t = _ref.types; return { visitor: { ArrowFunctionExpression: function ArrowFunctionExpression(path, state) { if (state.opts.spec) { var node = path.node; if (node.shadow) return; node.shadow = { this: false }; node.type = "FunctionExpression"; var boundThis = t.thisExpression(); boundThis._forceShadow = path; path.ensureBlock(); path.get("body").unshiftContainer("body", t.expressionStatement(t.callExpression(state.addHelper("newArrowCheck"), [t.thisExpression(), boundThis]))); path.replaceWith(t.callExpression(t.memberExpression(node, t.identifier("bind")), [t.thisExpression()])); } else { path.arrowFunctionToShadowed(); } } } }; }; module.exports = exports["default"]; /***/ }), /* 69 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); exports.default = function (_ref) { var t = _ref.types; function statementList(key, path) { var paths = path.get(key); for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref2; if (_isArray) { if (_i >= _iterator.length) break; _ref2 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref2 = _i.value; } var _path = _ref2; var func = _path.node; if (!_path.isFunctionDeclaration()) continue; var declar = t.variableDeclaration("let", [t.variableDeclarator(func.id, t.toExpression(func))]); declar._blockHoist = 2; func.id = null; _path.replaceWith(declar); } } return { visitor: { BlockStatement: function BlockStatement(path) { var node = path.node, parent = path.parent; if (t.isFunction(parent, { body: node }) || t.isExportDeclaration(parent)) { return; } statementList("body", path); }, SwitchCase: function SwitchCase(path) { statementList("consequent", path); } } }; }; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 70 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _symbol = __webpack_require__(10); var _symbol2 = _interopRequireDefault(_symbol); var _create = __webpack_require__(9); var _create2 = _interopRequireDefault(_create); var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); exports.default = function () { return { visitor: { VariableDeclaration: function VariableDeclaration(path, file) { var node = path.node, parent = path.parent, scope = path.scope; if (!isBlockScoped(node)) return; convertBlockScopedToVar(path, null, parent, scope, true); if (node._tdzThis) { var nodes = [node]; for (var i = 0; i < node.declarations.length; i++) { var decl = node.declarations[i]; if (decl.init) { var assign = t.assignmentExpression("=", decl.id, decl.init); assign._ignoreBlockScopingTDZ = true; nodes.push(t.expressionStatement(assign)); } decl.init = file.addHelper("temporalUndefined"); } node._blockHoist = 2; if (path.isCompletionRecord()) { nodes.push(t.expressionStatement(scope.buildUndefinedNode())); } path.replaceWithMultiple(nodes); } }, Loop: function Loop(path, file) { var node = path.node, parent = path.parent, scope = path.scope; t.ensureBlock(node); var blockScoping = new BlockScoping(path, path.get("body"), parent, scope, file); var replace = blockScoping.run(); if (replace) path.replaceWith(replace); }, CatchClause: function CatchClause(path, file) { var parent = path.parent, scope = path.scope; var blockScoping = new BlockScoping(null, path.get("body"), parent, scope, file); blockScoping.run(); }, "BlockStatement|SwitchStatement|Program": function BlockStatementSwitchStatementProgram(path, file) { if (!ignoreBlock(path)) { var blockScoping = new BlockScoping(null, path, path.parent, path.scope, file); blockScoping.run(); } } } }; }; var _babelTraverse = __webpack_require__(7); var _babelTraverse2 = _interopRequireDefault(_babelTraverse); var _tdz = __webpack_require__(330); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); var _values = __webpack_require__(280); var _values2 = _interopRequireDefault(_values); var _extend = __webpack_require__(578); var _extend2 = _interopRequireDefault(_extend); var _babelTemplate = __webpack_require__(4); var _babelTemplate2 = _interopRequireDefault(_babelTemplate); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function ignoreBlock(path) { return t.isLoop(path.parent) || t.isCatchClause(path.parent); } var buildRetCheck = (0, _babelTemplate2.default)("\n if (typeof RETURN === \"object\") return RETURN.v;\n"); function isBlockScoped(node) { if (!t.isVariableDeclaration(node)) return false; if (node[t.BLOCK_SCOPED_SYMBOL]) return true; if (node.kind !== "let" && node.kind !== "const") return false; return true; } function convertBlockScopedToVar(path, node, parent, scope) { var moveBindingsToParent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; if (!node) { node = path.node; } if (!t.isFor(parent)) { for (var i = 0; i < node.declarations.length; i++) { var declar = node.declarations[i]; declar.init = declar.init || scope.buildUndefinedNode(); } } node[t.BLOCK_SCOPED_SYMBOL] = true; node.kind = "var"; if (moveBindingsToParent) { var parentScope = scope.getFunctionParent(); var ids = path.getBindingIdentifiers(); for (var name in ids) { var binding = scope.getOwnBinding(name); if (binding) binding.kind = "var"; scope.moveBindingTo(name, parentScope); } } } function isVar(node) { return t.isVariableDeclaration(node, { kind: "var" }) && !isBlockScoped(node); } var letReferenceBlockVisitor = _babelTraverse2.default.visitors.merge([{ Loop: { enter: function enter(path, state) { state.loopDepth++; }, exit: function exit(path, state) { state.loopDepth--; } }, Function: function Function(path, state) { if (state.loopDepth > 0) { path.traverse(letReferenceFunctionVisitor, state); } return path.skip(); } }, _tdz.visitor]); var letReferenceFunctionVisitor = _babelTraverse2.default.visitors.merge([{ ReferencedIdentifier: function ReferencedIdentifier(path, state) { var ref = state.letReferences[path.node.name]; if (!ref) return; var localBinding = path.scope.getBindingIdentifier(path.node.name); if (localBinding && localBinding !== ref) return; state.closurify = true; } }, _tdz.visitor]); var hoistVarDeclarationsVisitor = { enter: function enter(path, self) { var node = path.node, parent = path.parent; if (path.isForStatement()) { if (isVar(node.init, node)) { var nodes = self.pushDeclar(node.init); if (nodes.length === 1) { node.init = nodes[0]; } else { node.init = t.sequenceExpression(nodes); } } } else if (path.isFor()) { if (isVar(node.left, node)) { self.pushDeclar(node.left); node.left = node.left.declarations[0].id; } } else if (isVar(node, parent)) { path.replaceWithMultiple(self.pushDeclar(node).map(function (expr) { return t.expressionStatement(expr); })); } else if (path.isFunction()) { return path.skip(); } } }; var loopLabelVisitor = { LabeledStatement: function LabeledStatement(_ref, state) { var node = _ref.node; state.innerLabels.push(node.label.name); } }; var continuationVisitor = { enter: function enter(path, state) { if (path.isAssignmentExpression() || path.isUpdateExpression()) { var bindings = path.getBindingIdentifiers(); for (var name in bindings) { if (state.outsideReferences[name] !== path.scope.getBindingIdentifier(name)) continue; state.reassignments[name] = true; } } } }; function loopNodeTo(node) { if (t.isBreakStatement(node)) { return "break"; } else if (t.isContinueStatement(node)) { return "continue"; } } var loopVisitor = { Loop: function Loop(path, state) { var oldIgnoreLabeless = state.ignoreLabeless; state.ignoreLabeless = true; path.traverse(loopVisitor, state); state.ignoreLabeless = oldIgnoreLabeless; path.skip(); }, Function: function Function(path) { path.skip(); }, SwitchCase: function SwitchCase(path, state) { var oldInSwitchCase = state.inSwitchCase; state.inSwitchCase = true; path.traverse(loopVisitor, state); state.inSwitchCase = oldInSwitchCase; path.skip(); }, "BreakStatement|ContinueStatement|ReturnStatement": function BreakStatementContinueStatementReturnStatement(path, state) { var node = path.node, parent = path.parent, scope = path.scope; if (node[this.LOOP_IGNORE]) return; var replace = void 0; var loopText = loopNodeTo(node); if (loopText) { if (node.label) { if (state.innerLabels.indexOf(node.label.name) >= 0) { return; } loopText = loopText + "|" + node.label.name; } else { if (state.ignoreLabeless) return; if (state.inSwitchCase) return; if (t.isBreakStatement(node) && t.isSwitchCase(parent)) return; } state.hasBreakContinue = true; state.map[loopText] = node; replace = t.stringLiteral(loopText); } if (path.isReturnStatement()) { state.hasReturn = true; replace = t.objectExpression([t.objectProperty(t.identifier("v"), node.argument || scope.buildUndefinedNode())]); } if (replace) { replace = t.returnStatement(replace); replace[this.LOOP_IGNORE] = true; path.skip(); path.replaceWith(t.inherits(replace, node)); } } }; var BlockScoping = function () { function BlockScoping(loopPath, blockPath, parent, scope, file) { (0, _classCallCheck3.default)(this, BlockScoping); this.parent = parent; this.scope = scope; this.file = file; this.blockPath = blockPath; this.block = blockPath.node; this.outsideLetReferences = (0, _create2.default)(null); this.hasLetReferences = false; this.letReferences = (0, _create2.default)(null); this.body = []; if (loopPath) { this.loopParent = loopPath.parent; this.loopLabel = t.isLabeledStatement(this.loopParent) && this.loopParent.label; this.loopPath = loopPath; this.loop = loopPath.node; } } BlockScoping.prototype.run = function run() { var block = this.block; if (block._letDone) return; block._letDone = true; var needsClosure = this.getLetReferences(); if (t.isFunction(this.parent) || t.isProgram(this.block)) { this.updateScopeInfo(); return; } if (!this.hasLetReferences) return; if (needsClosure) { this.wrapClosure(); } else { this.remap(); } this.updateScopeInfo(needsClosure); if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) { return t.labeledStatement(this.loopLabel, this.loop); } }; BlockScoping.prototype.updateScopeInfo = function updateScopeInfo(wrappedInClosure) { var scope = this.scope; var parentScope = scope.getFunctionParent(); var letRefs = this.letReferences; for (var key in letRefs) { var ref = letRefs[key]; var binding = scope.getBinding(ref.name); if (!binding) continue; if (binding.kind === "let" || binding.kind === "const") { binding.kind = "var"; if (wrappedInClosure) { scope.removeBinding(ref.name); } else { scope.moveBindingTo(ref.name, parentScope); } } } }; BlockScoping.prototype.remap = function remap() { var letRefs = this.letReferences; var scope = this.scope; for (var key in letRefs) { var ref = letRefs[key]; if (scope.parentHasBinding(key) || scope.hasGlobal(key)) { if (scope.hasOwnBinding(key)) scope.rename(ref.name); if (this.blockPath.scope.hasOwnBinding(key)) this.blockPath.scope.rename(ref.name); } } }; BlockScoping.prototype.wrapClosure = function wrapClosure() { if (this.file.opts.throwIfClosureRequired) { throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired)."); } var block = this.block; var outsideRefs = this.outsideLetReferences; if (this.loop) { for (var name in outsideRefs) { var id = outsideRefs[name]; if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) { delete outsideRefs[id.name]; delete this.letReferences[id.name]; this.scope.rename(id.name); this.letReferences[id.name] = id; outsideRefs[id.name] = id; } } } this.has = this.checkLoop(); this.hoistVarDeclarations(); var params = (0, _values2.default)(outsideRefs); var args = (0, _values2.default)(outsideRefs); var isSwitch = this.blockPath.isSwitchStatement(); var fn = t.functionExpression(null, params, t.blockStatement(isSwitch ? [block] : block.body)); fn.shadow = true; this.addContinuations(fn); var ref = fn; if (this.loop) { ref = this.scope.generateUidIdentifier("loop"); this.loopPath.insertBefore(t.variableDeclaration("var", [t.variableDeclarator(ref, fn)])); } var call = t.callExpression(ref, args); var ret = this.scope.generateUidIdentifier("ret"); var hasYield = _babelTraverse2.default.hasType(fn.body, this.scope, "YieldExpression", t.FUNCTION_TYPES); if (hasYield) { fn.generator = true; call = t.yieldExpression(call, true); } var hasAsync = _babelTraverse2.default.hasType(fn.body, this.scope, "AwaitExpression", t.FUNCTION_TYPES); if (hasAsync) { fn.async = true; call = t.awaitExpression(call); } this.buildClosure(ret, call); if (isSwitch) this.blockPath.replaceWithMultiple(this.body);else block.body = this.body; }; BlockScoping.prototype.buildClosure = function buildClosure(ret, call) { var has = this.has; if (has.hasReturn || has.hasBreakContinue) { this.buildHas(ret, call); } else { this.body.push(t.expressionStatement(call)); } }; BlockScoping.prototype.addContinuations = function addContinuations(fn) { var state = { reassignments: {}, outsideReferences: this.outsideLetReferences }; this.scope.traverse(fn, continuationVisitor, state); for (var i = 0; i < fn.params.length; i++) { var param = fn.params[i]; if (!state.reassignments[param.name]) continue; var newParam = this.scope.generateUidIdentifier(param.name); fn.params[i] = newParam; this.scope.rename(param.name, newParam.name, fn); fn.body.body.push(t.expressionStatement(t.assignmentExpression("=", param, newParam))); } }; BlockScoping.prototype.getLetReferences = function getLetReferences() { var _this = this; var block = this.block; var declarators = []; if (this.loop) { var init = this.loop.left || this.loop.init; if (isBlockScoped(init)) { declarators.push(init); (0, _extend2.default)(this.outsideLetReferences, t.getBindingIdentifiers(init)); } } var addDeclarationsFromChild = function addDeclarationsFromChild(path, node) { node = node || path.node; if (t.isClassDeclaration(node) || t.isFunctionDeclaration(node) || isBlockScoped(node)) { if (isBlockScoped(node)) { convertBlockScopedToVar(path, node, block, _this.scope); } declarators = declarators.concat(node.declarations || node); } if (t.isLabeledStatement(node)) { addDeclarationsFromChild(path.get("body"), node.body); } }; if (block.body) { for (var i = 0; i < block.body.length; i++) { var declarPath = this.blockPath.get("body")[i]; addDeclarationsFromChild(declarPath); } } if (block.cases) { for (var _i = 0; _i < block.cases.length; _i++) { var consequents = block.cases[_i].consequent; for (var j = 0; j < consequents.length; j++) { var _declarPath = this.blockPath.get("cases")[_i]; var declar = consequents[j]; addDeclarationsFromChild(_declarPath, declar); } } } for (var _i2 = 0; _i2 < declarators.length; _i2++) { var _declar = declarators[_i2]; var keys = t.getBindingIdentifiers(_declar, false, true); (0, _extend2.default)(this.letReferences, keys); this.hasLetReferences = true; } if (!this.hasLetReferences) return; var state = { letReferences: this.letReferences, closurify: false, file: this.file, loopDepth: 0 }; var loopOrFunctionParent = this.blockPath.find(function (path) { return path.isLoop() || path.isFunction(); }); if (loopOrFunctionParent && loopOrFunctionParent.isLoop()) { state.loopDepth++; } this.blockPath.traverse(letReferenceBlockVisitor, state); return state.closurify; }; BlockScoping.prototype.checkLoop = function checkLoop() { var state = { hasBreakContinue: false, ignoreLabeless: false, inSwitchCase: false, innerLabels: [], hasReturn: false, isLoop: !!this.loop, map: {}, LOOP_IGNORE: (0, _symbol2.default)() }; this.blockPath.traverse(loopLabelVisitor, state); this.blockPath.traverse(loopVisitor, state); return state; }; BlockScoping.prototype.hoistVarDeclarations = function hoistVarDeclarations() { this.blockPath.traverse(hoistVarDeclarationsVisitor, this); }; BlockScoping.prototype.pushDeclar = function pushDeclar(node) { var declars = []; var names = t.getBindingIdentifiers(node); for (var name in names) { declars.push(t.variableDeclarator(names[name])); } this.body.push(t.variableDeclaration(node.kind, declars)); var replace = []; for (var i = 0; i < node.declarations.length; i++) { var declar = node.declarations[i]; if (!declar.init) continue; var expr = t.assignmentExpression("=", declar.id, declar.init); replace.push(t.inherits(expr, declar)); } return replace; }; BlockScoping.prototype.buildHas = function buildHas(ret, call) { var body = this.body; body.push(t.variableDeclaration("var", [t.variableDeclarator(ret, call)])); var retCheck = void 0; var has = this.has; var cases = []; if (has.hasReturn) { retCheck = buildRetCheck({ RETURN: ret }); } if (has.hasBreakContinue) { for (var key in has.map) { cases.push(t.switchCase(t.stringLiteral(key), [has.map[key]])); } if (has.hasReturn) { cases.push(t.switchCase(null, [retCheck])); } if (cases.length === 1) { var single = cases[0]; body.push(t.ifStatement(t.binaryExpression("===", ret, single.test), single.consequent[0])); } else { if (this.loop) { for (var i = 0; i < cases.length; i++) { var caseConsequent = cases[i].consequent[0]; if (t.isBreakStatement(caseConsequent) && !caseConsequent.label) { caseConsequent.label = this.loopLabel = this.loopLabel || this.scope.generateUidIdentifier("loop"); } } } body.push(t.switchStatement(ret, cases)); } } else { if (has.hasReturn) { body.push(retCheck); } } }; return BlockScoping; }(); module.exports = exports["default"]; /***/ }), /* 71 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _symbol = __webpack_require__(10); var _symbol2 = _interopRequireDefault(_symbol); exports.default = function (_ref) { var t = _ref.types; var VISITED = (0, _symbol2.default)(); return { visitor: { ExportDefaultDeclaration: function ExportDefaultDeclaration(path) { if (!path.get("declaration").isClassDeclaration()) return; var node = path.node; var ref = node.declaration.id || path.scope.generateUidIdentifier("class"); node.declaration.id = ref; path.replaceWith(node.declaration); path.insertAfter(t.exportDefaultDeclaration(ref)); }, ClassDeclaration: function ClassDeclaration(path) { var node = path.node; var ref = node.id || path.scope.generateUidIdentifier("class"); path.replaceWith(t.variableDeclaration("let", [t.variableDeclarator(ref, t.toExpression(node))])); }, ClassExpression: function ClassExpression(path, state) { var node = path.node; if (node[VISITED]) return; var inferred = (0, _babelHelperFunctionName2.default)(path); if (inferred && inferred !== node) return path.replaceWith(inferred); node[VISITED] = true; var Constructor = _vanilla2.default; if (state.opts.loose) Constructor = _loose2.default; path.replaceWith(new Constructor(path, state.file).run()); } } }; }; var _loose = __webpack_require__(331); var _loose2 = _interopRequireDefault(_loose); var _vanilla = __webpack_require__(207); var _vanilla2 = _interopRequireDefault(_vanilla); var _babelHelperFunctionName = __webpack_require__(40); var _babelHelperFunctionName2 = _interopRequireDefault(_babelHelperFunctionName); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 72 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); exports.default = function (_ref) { var t = _ref.types, template = _ref.template; var buildMutatorMapAssign = template("\n MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n MUTATOR_MAP_REF[KEY].KIND = VALUE;\n "); function getValue(prop) { if (t.isObjectProperty(prop)) { return prop.value; } else if (t.isObjectMethod(prop)) { return t.functionExpression(null, prop.params, prop.body, prop.generator, prop.async); } } function pushAssign(objId, prop, body) { if (prop.kind === "get" && prop.kind === "set") { pushMutatorDefine(objId, prop, body); } else { body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(objId, prop.key, prop.computed || t.isLiteral(prop.key)), getValue(prop)))); } } function pushMutatorDefine(_ref2, prop) { var objId = _ref2.objId, body = _ref2.body, getMutatorId = _ref2.getMutatorId, scope = _ref2.scope; var key = !prop.computed && t.isIdentifier(prop.key) ? t.stringLiteral(prop.key.name) : prop.key; var maybeMemoise = scope.maybeGenerateMemoised(key); if (maybeMemoise) { body.push(t.expressionStatement(t.assignmentExpression("=", maybeMemoise, key))); key = maybeMemoise; } body.push.apply(body, buildMutatorMapAssign({ MUTATOR_MAP_REF: getMutatorId(), KEY: key, VALUE: getValue(prop), KIND: t.identifier(prop.kind) })); } function loose(info) { for (var _iterator = info.computedProps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref3; if (_isArray) { if (_i >= _iterator.length) break; _ref3 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref3 = _i.value; } var prop = _ref3; if (prop.kind === "get" || prop.kind === "set") { pushMutatorDefine(info, prop); } else { pushAssign(info.objId, prop, info.body); } } } function spec(info) { var objId = info.objId, body = info.body, computedProps = info.computedProps, state = info.state; for (var _iterator2 = computedProps, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref4; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref4 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref4 = _i2.value; } var prop = _ref4; var key = t.toComputedKey(prop); if (prop.kind === "get" || prop.kind === "set") { pushMutatorDefine(info, prop); } else if (t.isStringLiteral(key, { value: "__proto__" })) { pushAssign(objId, prop, body); } else { if (computedProps.length === 1) { return t.callExpression(state.addHelper("defineProperty"), [info.initPropExpression, key, getValue(prop)]); } else { body.push(t.expressionStatement(t.callExpression(state.addHelper("defineProperty"), [objId, key, getValue(prop)]))); } } } } return { visitor: { ObjectExpression: { exit: function exit(path, state) { var node = path.node, parent = path.parent, scope = path.scope; var hasComputed = false; for (var _iterator3 = node.properties, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) { var _ref5; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref5 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref5 = _i3.value; } var prop = _ref5; hasComputed = prop.computed === true; if (hasComputed) break; } if (!hasComputed) return; var initProps = []; var computedProps = []; var foundComputed = false; for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) { var _ref6; if (_isArray4) { if (_i4 >= _iterator4.length) break; _ref6 = _iterator4[_i4++]; } else { _i4 = _iterator4.next(); if (_i4.done) break; _ref6 = _i4.value; } var _prop = _ref6; if (_prop.computed) { foundComputed = true; } if (foundComputed) { computedProps.push(_prop); } else { initProps.push(_prop); } } var objId = scope.generateUidIdentifierBasedOnNode(parent); var initPropExpression = t.objectExpression(initProps); var body = []; body.push(t.variableDeclaration("var", [t.variableDeclarator(objId, initPropExpression)])); var callback = spec; if (state.opts.loose) callback = loose; var mutatorRef = void 0; var getMutatorId = function getMutatorId() { if (!mutatorRef) { mutatorRef = scope.generateUidIdentifier("mutatorMap"); body.push(t.variableDeclaration("var", [t.variableDeclarator(mutatorRef, t.objectExpression([]))])); } return mutatorRef; }; var single = callback({ scope: scope, objId: objId, body: body, computedProps: computedProps, initPropExpression: initPropExpression, getMutatorId: getMutatorId, state: state }); if (mutatorRef) { body.push(t.expressionStatement(t.callExpression(state.addHelper("defineEnumerableProperties"), [objId, mutatorRef]))); } if (single) { path.replaceWith(single); } else { body.push(t.expressionStatement(objId)); path.replaceWithMultiple(body); } } } } }; }; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 73 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); exports.default = function (_ref) { var t = _ref.types; function variableDeclarationHasPattern(node) { for (var _iterator = node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref2; if (_isArray) { if (_i >= _iterator.length) break; _ref2 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref2 = _i.value; } var declar = _ref2; if (t.isPattern(declar.id)) { return true; } } return false; } function hasRest(pattern) { for (var _iterator2 = pattern.elements, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref3; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref3 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref3 = _i2.value; } var elem = _ref3; if (t.isRestElement(elem)) { return true; } } return false; } var arrayUnpackVisitor = { ReferencedIdentifier: function ReferencedIdentifier(path, state) { if (state.bindings[path.node.name]) { state.deopt = true; path.stop(); } } }; var DestructuringTransformer = function () { function DestructuringTransformer(opts) { (0, _classCallCheck3.default)(this, DestructuringTransformer); this.blockHoist = opts.blockHoist; this.operator = opts.operator; this.arrays = {}; this.nodes = opts.nodes || []; this.scope = opts.scope; this.file = opts.file; this.kind = opts.kind; } DestructuringTransformer.prototype.buildVariableAssignment = function buildVariableAssignment(id, init) { var op = this.operator; if (t.isMemberExpression(id)) op = "="; var node = void 0; if (op) { node = t.expressionStatement(t.assignmentExpression(op, id, init)); } else { node = t.variableDeclaration(this.kind, [t.variableDeclarator(id, init)]); } node._blockHoist = this.blockHoist; return node; }; DestructuringTransformer.prototype.buildVariableDeclaration = function buildVariableDeclaration(id, init) { var declar = t.variableDeclaration("var", [t.variableDeclarator(id, init)]); declar._blockHoist = this.blockHoist; return declar; }; DestructuringTransformer.prototype.push = function push(id, init) { if (t.isObjectPattern(id)) { this.pushObjectPattern(id, init); } else if (t.isArrayPattern(id)) { this.pushArrayPattern(id, init); } else if (t.isAssignmentPattern(id)) { this.pushAssignmentPattern(id, init); } else { this.nodes.push(this.buildVariableAssignment(id, init)); } }; DestructuringTransformer.prototype.toArray = function toArray(node, count) { if (this.file.opts.loose || t.isIdentifier(node) && this.arrays[node.name]) { return node; } else { return this.scope.toArray(node, count); } }; DestructuringTransformer.prototype.pushAssignmentPattern = function pushAssignmentPattern(pattern, valueRef) { var tempValueRef = this.scope.generateUidIdentifierBasedOnNode(valueRef); var declar = t.variableDeclaration("var", [t.variableDeclarator(tempValueRef, valueRef)]); declar._blockHoist = this.blockHoist; this.nodes.push(declar); var tempConditional = t.conditionalExpression(t.binaryExpression("===", tempValueRef, t.identifier("undefined")), pattern.right, tempValueRef); var left = pattern.left; if (t.isPattern(left)) { var tempValueDefault = t.expressionStatement(t.assignmentExpression("=", tempValueRef, tempConditional)); tempValueDefault._blockHoist = this.blockHoist; this.nodes.push(tempValueDefault); this.push(left, tempValueRef); } else { this.nodes.push(this.buildVariableAssignment(left, tempConditional)); } }; DestructuringTransformer.prototype.pushObjectRest = function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) { var keys = []; for (var i = 0; i < pattern.properties.length; i++) { var prop = pattern.properties[i]; if (i >= spreadPropIndex) break; if (t.isRestProperty(prop)) continue; var key = prop.key; if (t.isIdentifier(key) && !prop.computed) key = t.stringLiteral(prop.key.name); keys.push(key); } keys = t.arrayExpression(keys); var value = t.callExpression(this.file.addHelper("objectWithoutProperties"), [objRef, keys]); this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value)); }; DestructuringTransformer.prototype.pushObjectProperty = function pushObjectProperty(prop, propRef) { if (t.isLiteral(prop.key)) prop.computed = true; var pattern = prop.value; var objRef = t.memberExpression(propRef, prop.key, prop.computed); if (t.isPattern(pattern)) { this.push(pattern, objRef); } else { this.nodes.push(this.buildVariableAssignment(pattern, objRef)); } }; DestructuringTransformer.prototype.pushObjectPattern = function pushObjectPattern(pattern, objRef) { if (!pattern.properties.length) { this.nodes.push(t.expressionStatement(t.callExpression(this.file.addHelper("objectDestructuringEmpty"), [objRef]))); } if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) { var temp = this.scope.generateUidIdentifierBasedOnNode(objRef); this.nodes.push(this.buildVariableDeclaration(temp, objRef)); objRef = temp; } for (var i = 0; i < pattern.properties.length; i++) { var prop = pattern.properties[i]; if (t.isRestProperty(prop)) { this.pushObjectRest(pattern, objRef, prop, i); } else { this.pushObjectProperty(prop, objRef); } } }; DestructuringTransformer.prototype.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) { if (!t.isArrayExpression(arr)) return false; if (pattern.elements.length > arr.elements.length) return; if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) return false; for (var _iterator3 = pattern.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) { var _ref4; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref4 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref4 = _i3.value; } var elem = _ref4; if (!elem) return false; if (t.isMemberExpression(elem)) return false; } for (var _iterator4 = arr.elements, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) { var _ref5; if (_isArray4) { if (_i4 >= _iterator4.length) break; _ref5 = _iterator4[_i4++]; } else { _i4 = _iterator4.next(); if (_i4.done) break; _ref5 = _i4.value; } var _elem = _ref5; if (t.isSpreadElement(_elem)) return false; if (t.isCallExpression(_elem)) return false; if (t.isMemberExpression(_elem)) return false; } var bindings = t.getBindingIdentifiers(pattern); var state = { deopt: false, bindings: bindings }; this.scope.traverse(arr, arrayUnpackVisitor, state); return !state.deopt; }; DestructuringTransformer.prototype.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) { for (var i = 0; i < pattern.elements.length; i++) { var elem = pattern.elements[i]; if (t.isRestElement(elem)) { this.push(elem.argument, t.arrayExpression(arr.elements.slice(i))); } else { this.push(elem, arr.elements[i]); } } }; DestructuringTransformer.prototype.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) { if (!pattern.elements) return; if (this.canUnpackArrayPattern(pattern, arrayRef)) { return this.pushUnpackedArrayPattern(pattern, arrayRef); } var count = !hasRest(pattern) && pattern.elements.length; var toArray = this.toArray(arrayRef, count); if (t.isIdentifier(toArray)) { arrayRef = toArray; } else { arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef); this.arrays[arrayRef.name] = true; this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray)); } for (var i = 0; i < pattern.elements.length; i++) { var elem = pattern.elements[i]; if (!elem) continue; var elemRef = void 0; if (t.isRestElement(elem)) { elemRef = this.toArray(arrayRef); elemRef = t.callExpression(t.memberExpression(elemRef, t.identifier("slice")), [t.numericLiteral(i)]); elem = elem.argument; } else { elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true); } this.push(elem, elemRef); } }; DestructuringTransformer.prototype.init = function init(pattern, ref) { if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) { var memo = this.scope.maybeGenerateMemoised(ref, true); if (memo) { this.nodes.push(this.buildVariableDeclaration(memo, ref)); ref = memo; } } this.push(pattern, ref); return this.nodes; }; return DestructuringTransformer; }(); return { visitor: { ExportNamedDeclaration: function ExportNamedDeclaration(path) { var declaration = path.get("declaration"); if (!declaration.isVariableDeclaration()) return; if (!variableDeclarationHasPattern(declaration.node)) return; var specifiers = []; for (var name in path.getOuterBindingIdentifiers(path)) { var id = t.identifier(name); specifiers.push(t.exportSpecifier(id, id)); } path.replaceWith(declaration.node); path.insertAfter(t.exportNamedDeclaration(null, specifiers)); }, ForXStatement: function ForXStatement(path, file) { var node = path.node, scope = path.scope; var left = node.left; if (t.isPattern(left)) { var temp = scope.generateUidIdentifier("ref"); node.left = t.variableDeclaration("var", [t.variableDeclarator(temp)]); path.ensureBlock(); node.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(left, temp)])); return; } if (!t.isVariableDeclaration(left)) return; var pattern = left.declarations[0].id; if (!t.isPattern(pattern)) return; var key = scope.generateUidIdentifier("ref"); node.left = t.variableDeclaration(left.kind, [t.variableDeclarator(key, null)]); var nodes = []; var destructuring = new DestructuringTransformer({ kind: left.kind, file: file, scope: scope, nodes: nodes }); destructuring.init(pattern, key); path.ensureBlock(); var block = node.body; block.body = nodes.concat(block.body); }, CatchClause: function CatchClause(_ref6, file) { var node = _ref6.node, scope = _ref6.scope; var pattern = node.param; if (!t.isPattern(pattern)) return; var ref = scope.generateUidIdentifier("ref"); node.param = ref; var nodes = []; var destructuring = new DestructuringTransformer({ kind: "let", file: file, scope: scope, nodes: nodes }); destructuring.init(pattern, ref); node.body.body = nodes.concat(node.body.body); }, AssignmentExpression: function AssignmentExpression(path, file) { var node = path.node, scope = path.scope; if (!t.isPattern(node.left)) return; var nodes = []; var destructuring = new DestructuringTransformer({ operator: node.operator, file: file, scope: scope, nodes: nodes }); var ref = void 0; if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) { ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref"); nodes.push(t.variableDeclaration("var", [t.variableDeclarator(ref, node.right)])); if (t.isArrayExpression(node.right)) { destructuring.arrays[ref.name] = true; } } destructuring.init(node.left, ref || node.right); if (ref) { nodes.push(t.expressionStatement(ref)); } path.replaceWithMultiple(nodes); }, VariableDeclaration: function VariableDeclaration(path, file) { var node = path.node, scope = path.scope, parent = path.parent; if (t.isForXStatement(parent)) return; if (!parent || !path.container) return; if (!variableDeclarationHasPattern(node)) return; var nodes = []; var declar = void 0; for (var i = 0; i < node.declarations.length; i++) { declar = node.declarations[i]; var patternId = declar.init; var pattern = declar.id; var destructuring = new DestructuringTransformer({ blockHoist: node._blockHoist, nodes: nodes, scope: scope, kind: node.kind, file: file }); if (t.isPattern(pattern)) { destructuring.init(pattern, patternId); if (+i !== node.declarations.length - 1) { t.inherits(nodes[nodes.length - 1], declar); } } else { nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar)); } } var nodesOut = []; for (var _iterator5 = nodes, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) { var _ref7; if (_isArray5) { if (_i5 >= _iterator5.length) break; _ref7 = _iterator5[_i5++]; } else { _i5 = _iterator5.next(); if (_i5.done) break; _ref7 = _i5.value; } var _node = _ref7; var tail = nodesOut[nodesOut.length - 1]; if (tail && t.isVariableDeclaration(tail) && t.isVariableDeclaration(_node) && tail.kind === _node.kind) { var _tail$declarations; (_tail$declarations = tail.declarations).push.apply(_tail$declarations, _node.declarations); } else { nodesOut.push(_node); } } for (var _iterator6 = nodesOut, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) { var _ref8; if (_isArray6) { if (_i6 >= _iterator6.length) break; _ref8 = _iterator6[_i6++]; } else { _i6 = _iterator6.next(); if (_i6.done) break; _ref8 = _i6.value; } var nodeOut = _ref8; if (!nodeOut.declarations) continue; for (var _iterator7 = nodeOut.declarations, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) { var _ref9; if (_isArray7) { if (_i7 >= _iterator7.length) break; _ref9 = _iterator7[_i7++]; } else { _i7 = _iterator7.next(); if (_i7.done) break; _ref9 = _i7.value; } var declaration = _ref9; var name = declaration.id.name; if (scope.bindings[name]) { scope.bindings[name].kind = nodeOut.kind; } } } if (nodesOut.length === 1) { path.replaceWith(nodesOut[0]); } else { path.replaceWithMultiple(nodesOut); } } } }; }; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 74 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function (_ref) { var messages = _ref.messages, template = _ref.template, t = _ref.types; var buildForOfArray = template("\n for (var KEY = 0; KEY < ARR.length; KEY++) BODY;\n "); var buildForOfLoose = template("\n for (var LOOP_OBJECT = OBJECT,\n IS_ARRAY = Array.isArray(LOOP_OBJECT),\n INDEX = 0,\n LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n var ID;\n if (IS_ARRAY) {\n if (INDEX >= LOOP_OBJECT.length) break;\n ID = LOOP_OBJECT[INDEX++];\n } else {\n INDEX = LOOP_OBJECT.next();\n if (INDEX.done) break;\n ID = INDEX.value;\n }\n }\n "); var buildForOf = template("\n var ITERATOR_COMPLETION = true;\n var ITERATOR_HAD_ERROR_KEY = false;\n var ITERATOR_ERROR_KEY = undefined;\n try {\n for (var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY; !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done); ITERATOR_COMPLETION = true) {\n }\n } catch (err) {\n ITERATOR_HAD_ERROR_KEY = true;\n ITERATOR_ERROR_KEY = err;\n } finally {\n try {\n if (!ITERATOR_COMPLETION && ITERATOR_KEY.return) {\n ITERATOR_KEY.return();\n }\n } finally {\n if (ITERATOR_HAD_ERROR_KEY) {\n throw ITERATOR_ERROR_KEY;\n }\n }\n }\n "); function _ForOfStatementArray(path) { var node = path.node, scope = path.scope; var nodes = []; var right = node.right; if (!t.isIdentifier(right) || !scope.hasBinding(right.name)) { var uid = scope.generateUidIdentifier("arr"); nodes.push(t.variableDeclaration("var", [t.variableDeclarator(uid, right)])); right = uid; } var iterationKey = scope.generateUidIdentifier("i"); var loop = buildForOfArray({ BODY: node.body, KEY: iterationKey, ARR: right }); t.inherits(loop, node); t.ensureBlock(loop); var iterationValue = t.memberExpression(right, iterationKey, true); var left = node.left; if (t.isVariableDeclaration(left)) { left.declarations[0].init = iterationValue; loop.body.body.unshift(left); } else { loop.body.body.unshift(t.expressionStatement(t.assignmentExpression("=", left, iterationValue))); } if (path.parentPath.isLabeledStatement()) { loop = t.labeledStatement(path.parentPath.node.label, loop); } nodes.push(loop); return nodes; } return { visitor: { ForOfStatement: function ForOfStatement(path, state) { if (path.get("right").isArrayExpression()) { if (path.parentPath.isLabeledStatement()) { return path.parentPath.replaceWithMultiple(_ForOfStatementArray(path)); } else { return path.replaceWithMultiple(_ForOfStatementArray(path)); } } var callback = spec; if (state.opts.loose) callback = loose; var node = path.node; var build = callback(path, state); var declar = build.declar; var loop = build.loop; var block = loop.body; path.ensureBlock(); if (declar) { block.body.push(declar); } block.body = block.body.concat(node.body.body); t.inherits(loop, node); t.inherits(loop.body, node.body); if (build.replaceParent) { path.parentPath.replaceWithMultiple(build.node); path.remove(); } else { path.replaceWithMultiple(build.node); } } } }; function loose(path, file) { var node = path.node, scope = path.scope, parent = path.parent; var left = node.left; var declar = void 0, id = void 0; if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) { id = left; } else if (t.isVariableDeclaration(left)) { id = scope.generateUidIdentifier("ref"); declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, id)]); } else { throw file.buildCodeFrameError(left, messages.get("unknownForHead", left.type)); } var iteratorKey = scope.generateUidIdentifier("iterator"); var isArrayKey = scope.generateUidIdentifier("isArray"); var loop = buildForOfLoose({ LOOP_OBJECT: iteratorKey, IS_ARRAY: isArrayKey, OBJECT: node.right, INDEX: scope.generateUidIdentifier("i"), ID: id }); if (!declar) { loop.body.body.shift(); } var isLabeledParent = t.isLabeledStatement(parent); var labeled = void 0; if (isLabeledParent) { labeled = t.labeledStatement(parent.label, loop); } return { replaceParent: isLabeledParent, declar: declar, node: labeled || loop, loop: loop }; } function spec(path, file) { var node = path.node, scope = path.scope, parent = path.parent; var left = node.left; var declar = void 0; var stepKey = scope.generateUidIdentifier("step"); var stepValue = t.memberExpression(stepKey, t.identifier("value")); if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) { declar = t.expressionStatement(t.assignmentExpression("=", left, stepValue)); } else if (t.isVariableDeclaration(left)) { declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, stepValue)]); } else { throw file.buildCodeFrameError(left, messages.get("unknownForHead", left.type)); } var iteratorKey = scope.generateUidIdentifier("iterator"); var template = buildForOf({ ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"), ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"), ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"), ITERATOR_KEY: iteratorKey, STEP_KEY: stepKey, OBJECT: node.right, BODY: null }); var isLabeledParent = t.isLabeledStatement(parent); var tryBody = template[3].block.body; var loop = tryBody[0]; if (isLabeledParent) { tryBody[0] = t.labeledStatement(parent.label, loop); } return { replaceParent: isLabeledParent, declar: declar, loop: loop, node: template }; } }; module.exports = exports["default"]; /***/ }), /* 75 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.default = function () { return { visitor: { FunctionExpression: { exit: function exit(path) { if (path.key !== "value" && !path.parentPath.isObjectProperty()) { var replacement = (0, _babelHelperFunctionName2.default)(path); if (replacement) path.replaceWith(replacement); } } }, ObjectProperty: function ObjectProperty(path) { var value = path.get("value"); if (value.isFunction()) { var newNode = (0, _babelHelperFunctionName2.default)(value); if (newNode) value.replaceWith(newNode); } } } }; }; var _babelHelperFunctionName = __webpack_require__(40); var _babelHelperFunctionName2 = _interopRequireDefault(_babelHelperFunctionName); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 76 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function () { return { visitor: { NumericLiteral: function NumericLiteral(_ref) { var node = _ref.node; if (node.extra && /^0[ob]/i.test(node.extra.raw)) { node.extra = undefined; } }, StringLiteral: function StringLiteral(_ref2) { var node = _ref2.node; if (node.extra && /\\[u]/gi.test(node.extra.raw)) { node.extra = undefined; } } } }; }; module.exports = exports["default"]; /***/ }), /* 77 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _keys = __webpack_require__(14); var _keys2 = _interopRequireDefault(_keys); var _create = __webpack_require__(9); var _create2 = _interopRequireDefault(_create); var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _symbol = __webpack_require__(10); var _symbol2 = _interopRequireDefault(_symbol); exports.default = function () { var REASSIGN_REMAP_SKIP = (0, _symbol2.default)(); var reassignmentVisitor = { ReferencedIdentifier: function ReferencedIdentifier(path) { var name = path.node.name; var remap = this.remaps[name]; if (!remap) return; if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return; if (path.parentPath.isCallExpression({ callee: path.node })) { path.replaceWith(t.sequenceExpression([t.numericLiteral(0), remap])); } else if (path.isJSXIdentifier() && t.isMemberExpression(remap)) { var object = remap.object, property = remap.property; path.replaceWith(t.JSXMemberExpression(t.JSXIdentifier(object.name), t.JSXIdentifier(property.name))); } else { path.replaceWith(remap); } this.requeueInParent(path); }, AssignmentExpression: function AssignmentExpression(path) { var node = path.node; if (node[REASSIGN_REMAP_SKIP]) return; var left = path.get("left"); if (left.isIdentifier()) { var name = left.node.name; var exports = this.exports[name]; if (!exports) return; if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return; node[REASSIGN_REMAP_SKIP] = true; for (var _iterator = exports, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var reid = _ref; node = buildExportsAssignment(reid, node).expression; } path.replaceWith(node); this.requeueInParent(path); } else if (left.isObjectPattern()) { for (var _iterator2 = left.node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var property = _ref2; var _name = property.value.name; var _exports = this.exports[_name]; if (!_exports) continue; if (this.scope.getBinding(_name) !== path.scope.getBinding(_name)) return; node[REASSIGN_REMAP_SKIP] = true; path.insertAfter(buildExportsAssignment(t.identifier(_name), t.identifier(_name))); } } else if (left.isArrayPattern()) { for (var _iterator3 = left.node.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) { var _ref3; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref3 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref3 = _i3.value; } var element = _ref3; if (!element) continue; var _name2 = element.name; var _exports2 = this.exports[_name2]; if (!_exports2) continue; if (this.scope.getBinding(_name2) !== path.scope.getBinding(_name2)) return; node[REASSIGN_REMAP_SKIP] = true; path.insertAfter(buildExportsAssignment(t.identifier(_name2), t.identifier(_name2))); } } }, UpdateExpression: function UpdateExpression(path) { var arg = path.get("argument"); if (!arg.isIdentifier()) return; var name = arg.node.name; var exports = this.exports[name]; if (!exports) return; if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return; var node = t.assignmentExpression(path.node.operator[0] + "=", arg.node, t.numericLiteral(1)); if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord() || path.node.prefix) { path.replaceWith(node); this.requeueInParent(path); return; } var nodes = []; nodes.push(node); var operator = void 0; if (path.node.operator === "--") { operator = "+"; } else { operator = "-"; } nodes.push(t.binaryExpression(operator, arg.node, t.numericLiteral(1))); path.replaceWithMultiple(t.sequenceExpression(nodes)); } }; return { inherits: _babelPluginTransformStrictMode2.default, visitor: { ThisExpression: function ThisExpression(path, state) { if (this.ranCommonJS) return; if (state.opts.allowTopLevelThis !== true && !path.findParent(function (path) { return !path.is("shadow") && THIS_BREAK_KEYS.indexOf(path.type) >= 0; })) { path.replaceWith(t.identifier("undefined")); } }, Program: { exit: function exit(path) { this.ranCommonJS = true; var strict = !!this.opts.strict; var noInterop = !!this.opts.noInterop; var scope = path.scope; scope.rename("module"); scope.rename("exports"); scope.rename("require"); var hasExports = false; var hasImports = false; var body = path.get("body"); var imports = (0, _create2.default)(null); var exports = (0, _create2.default)(null); var nonHoistedExportNames = (0, _create2.default)(null); var topNodes = []; var remaps = (0, _create2.default)(null); var requires = (0, _create2.default)(null); function addRequire(source, blockHoist) { var cached = requires[source]; if (cached) return cached; var ref = path.scope.generateUidIdentifier((0, _path2.basename)(source, (0, _path2.extname)(source))); var varDecl = t.variableDeclaration("var", [t.variableDeclarator(ref, buildRequire(t.stringLiteral(source)).expression)]); if (imports[source]) { varDecl.loc = imports[source].loc; } if (typeof blockHoist === "number" && blockHoist > 0) { varDecl._blockHoist = blockHoist; } topNodes.push(varDecl); return requires[source] = ref; } function addTo(obj, key, arr) { var existing = obj[key] || []; obj[key] = existing.concat(arr); } for (var _iterator4 = body, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) { var _ref4; if (_isArray4) { if (_i4 >= _iterator4.length) break; _ref4 = _iterator4[_i4++]; } else { _i4 = _iterator4.next(); if (_i4.done) break; _ref4 = _i4.value; } var _path = _ref4; if (_path.isExportDeclaration()) { hasExports = true; var specifiers = [].concat(_path.get("declaration"), _path.get("specifiers")); for (var _iterator6 = specifiers, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) { var _ref6; if (_isArray6) { if (_i6 >= _iterator6.length) break; _ref6 = _iterator6[_i6++]; } else { _i6 = _iterator6.next(); if (_i6.done) break; _ref6 = _i6.value; } var _specifier2 = _ref6; var ids = _specifier2.getBindingIdentifiers(); if (ids.__esModule) { throw _specifier2.buildCodeFrameError("Illegal export \"__esModule\""); } } } if (_path.isImportDeclaration()) { var _importsEntry$specifi; hasImports = true; var key = _path.node.source.value; var importsEntry = imports[key] || { specifiers: [], maxBlockHoist: 0, loc: _path.node.loc }; (_importsEntry$specifi = importsEntry.specifiers).push.apply(_importsEntry$specifi, _path.node.specifiers); if (typeof _path.node._blockHoist === "number") { importsEntry.maxBlockHoist = Math.max(_path.node._blockHoist, importsEntry.maxBlockHoist); } imports[key] = importsEntry; _path.remove(); } else if (_path.isExportDefaultDeclaration()) { var declaration = _path.get("declaration"); if (declaration.isFunctionDeclaration()) { var id = declaration.node.id; var defNode = t.identifier("default"); if (id) { addTo(exports, id.name, defNode); topNodes.push(buildExportsAssignment(defNode, id)); _path.replaceWith(declaration.node); } else { topNodes.push(buildExportsAssignment(defNode, t.toExpression(declaration.node))); _path.remove(); } } else if (declaration.isClassDeclaration()) { var _id = declaration.node.id; var _defNode = t.identifier("default"); if (_id) { addTo(exports, _id.name, _defNode); _path.replaceWithMultiple([declaration.node, buildExportsAssignment(_defNode, _id)]); } else { _path.replaceWith(buildExportsAssignment(_defNode, t.toExpression(declaration.node))); _path.parentPath.requeue(_path.get("expression.left")); } } else { _path.replaceWith(buildExportsAssignment(t.identifier("default"), declaration.node)); _path.parentPath.requeue(_path.get("expression.left")); } } else if (_path.isExportNamedDeclaration()) { var _declaration = _path.get("declaration"); if (_declaration.node) { if (_declaration.isFunctionDeclaration()) { var _id2 = _declaration.node.id; addTo(exports, _id2.name, _id2); topNodes.push(buildExportsAssignment(_id2, _id2)); _path.replaceWith(_declaration.node); } else if (_declaration.isClassDeclaration()) { var _id3 = _declaration.node.id; addTo(exports, _id3.name, _id3); _path.replaceWithMultiple([_declaration.node, buildExportsAssignment(_id3, _id3)]); nonHoistedExportNames[_id3.name] = true; } else if (_declaration.isVariableDeclaration()) { var declarators = _declaration.get("declarations"); for (var _iterator7 = declarators, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) { var _ref7; if (_isArray7) { if (_i7 >= _iterator7.length) break; _ref7 = _iterator7[_i7++]; } else { _i7 = _iterator7.next(); if (_i7.done) break; _ref7 = _i7.value; } var decl = _ref7; var _id4 = decl.get("id"); var init = decl.get("init"); var exportsToInsert = []; if (!init.node) init.replaceWith(t.identifier("undefined")); if (_id4.isIdentifier()) { addTo(exports, _id4.node.name, _id4.node); init.replaceWith(buildExportsAssignment(_id4.node, init.node).expression); nonHoistedExportNames[_id4.node.name] = true; } else if (_id4.isObjectPattern()) { for (var _i8 = 0; _i8 < _id4.node.properties.length; _i8++) { var prop = _id4.node.properties[_i8]; var propValue = prop.value; if (t.isAssignmentPattern(propValue)) { propValue = propValue.left; } else if (t.isRestProperty(prop)) { propValue = prop.argument; } addTo(exports, propValue.name, propValue); exportsToInsert.push(buildExportsAssignment(propValue, propValue)); nonHoistedExportNames[propValue.name] = true; } } else if (_id4.isArrayPattern() && _id4.node.elements) { for (var _i9 = 0; _i9 < _id4.node.elements.length; _i9++) { var elem = _id4.node.elements[_i9]; if (!elem) continue; if (t.isAssignmentPattern(elem)) { elem = elem.left; } else if (t.isRestElement(elem)) { elem = elem.argument; } var name = elem.name; addTo(exports, name, elem); exportsToInsert.push(buildExportsAssignment(elem, elem)); nonHoistedExportNames[name] = true; } } _path.insertAfter(exportsToInsert); } _path.replaceWith(_declaration.node); } continue; } var _specifiers = _path.get("specifiers"); var nodes = []; var _source = _path.node.source; if (_source) { var ref = addRequire(_source.value, _path.node._blockHoist); for (var _iterator8 = _specifiers, _isArray8 = Array.isArray(_iterator8), _i10 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) { var _ref8; if (_isArray8) { if (_i10 >= _iterator8.length) break; _ref8 = _iterator8[_i10++]; } else { _i10 = _iterator8.next(); if (_i10.done) break; _ref8 = _i10.value; } var _specifier3 = _ref8; if (_specifier3.isExportNamespaceSpecifier()) {} else if (_specifier3.isExportDefaultSpecifier()) {} else if (_specifier3.isExportSpecifier()) { if (!noInterop && _specifier3.node.local.name === "default") { topNodes.push(buildExportsFrom(t.stringLiteral(_specifier3.node.exported.name), t.memberExpression(t.callExpression(this.addHelper("interopRequireDefault"), [ref]), _specifier3.node.local))); } else { topNodes.push(buildExportsFrom(t.stringLiteral(_specifier3.node.exported.name), t.memberExpression(ref, _specifier3.node.local))); } nonHoistedExportNames[_specifier3.node.exported.name] = true; } } } else { for (var _iterator9 = _specifiers, _isArray9 = Array.isArray(_iterator9), _i11 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) { var _ref9; if (_isArray9) { if (_i11 >= _iterator9.length) break; _ref9 = _iterator9[_i11++]; } else { _i11 = _iterator9.next(); if (_i11.done) break; _ref9 = _i11.value; } var _specifier4 = _ref9; if (_specifier4.isExportSpecifier()) { addTo(exports, _specifier4.node.local.name, _specifier4.node.exported); nonHoistedExportNames[_specifier4.node.exported.name] = true; nodes.push(buildExportsAssignment(_specifier4.node.exported, _specifier4.node.local)); } } } _path.replaceWithMultiple(nodes); } else if (_path.isExportAllDeclaration()) { var exportNode = buildExportAll({ OBJECT: addRequire(_path.node.source.value, _path.node._blockHoist) }); exportNode.loc = _path.node.loc; topNodes.push(exportNode); _path.remove(); } } for (var source in imports) { var _imports$source = imports[source], specifiers = _imports$source.specifiers, maxBlockHoist = _imports$source.maxBlockHoist; if (specifiers.length) { var uid = addRequire(source, maxBlockHoist); var wildcard = void 0; for (var i = 0; i < specifiers.length; i++) { var specifier = specifiers[i]; if (t.isImportNamespaceSpecifier(specifier)) { if (strict || noInterop) { remaps[specifier.local.name] = uid; } else { var varDecl = t.variableDeclaration("var", [t.variableDeclarator(specifier.local, t.callExpression(this.addHelper("interopRequireWildcard"), [uid]))]); if (maxBlockHoist > 0) { varDecl._blockHoist = maxBlockHoist; } topNodes.push(varDecl); } wildcard = specifier.local; } else if (t.isImportDefaultSpecifier(specifier)) { specifiers[i] = t.importSpecifier(specifier.local, t.identifier("default")); } } for (var _iterator5 = specifiers, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) { var _ref5; if (_isArray5) { if (_i5 >= _iterator5.length) break; _ref5 = _iterator5[_i5++]; } else { _i5 = _iterator5.next(); if (_i5.done) break; _ref5 = _i5.value; } var _specifier = _ref5; if (t.isImportSpecifier(_specifier)) { var target = uid; if (_specifier.imported.name === "default") { if (wildcard) { target = wildcard; } else if (!noInterop) { target = wildcard = path.scope.generateUidIdentifier(uid.name); var _varDecl = t.variableDeclaration("var", [t.variableDeclarator(target, t.callExpression(this.addHelper("interopRequireDefault"), [uid]))]); if (maxBlockHoist > 0) { _varDecl._blockHoist = maxBlockHoist; } topNodes.push(_varDecl); } } remaps[_specifier.local.name] = t.memberExpression(target, t.cloneWithoutLoc(_specifier.imported)); } } } else { var requireNode = buildRequire(t.stringLiteral(source)); requireNode.loc = imports[source].loc; topNodes.push(requireNode); } } if (hasImports && (0, _keys2.default)(nonHoistedExportNames).length) { var maxHoistedExportsNodeAssignmentLength = 100; var nonHoistedExportNamesArr = (0, _keys2.default)(nonHoistedExportNames); var _loop = function _loop(currentExportsNodeAssignmentLength) { var nonHoistedExportNamesChunk = nonHoistedExportNamesArr.slice(currentExportsNodeAssignmentLength, currentExportsNodeAssignmentLength + maxHoistedExportsNodeAssignmentLength); var hoistedExportsNode = t.identifier("undefined"); nonHoistedExportNamesChunk.forEach(function (name) { hoistedExportsNode = buildExportsAssignment(t.identifier(name), hoistedExportsNode).expression; }); var node = t.expressionStatement(hoistedExportsNode); node._blockHoist = 3; topNodes.unshift(node); }; for (var currentExportsNodeAssignmentLength = 0; currentExportsNodeAssignmentLength < nonHoistedExportNamesArr.length; currentExportsNodeAssignmentLength += maxHoistedExportsNodeAssignmentLength) { _loop(currentExportsNodeAssignmentLength); } } if (hasExports && !strict) { var buildTemplate = buildExportsModuleDeclaration; if (this.opts.loose) buildTemplate = buildLooseExportsModuleDeclaration; var declar = buildTemplate(); declar._blockHoist = 3; topNodes.unshift(declar); } path.unshiftContainer("body", topNodes); path.traverse(reassignmentVisitor, { remaps: remaps, scope: scope, exports: exports, requeueInParent: function requeueInParent(newPath) { return path.requeue(newPath); } }); } } } }; }; var _path2 = __webpack_require__(19); var _babelTemplate = __webpack_require__(4); var _babelTemplate2 = _interopRequireDefault(_babelTemplate); var _babelPluginTransformStrictMode = __webpack_require__(216); var _babelPluginTransformStrictMode2 = _interopRequireDefault(_babelPluginTransformStrictMode); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var buildRequire = (0, _babelTemplate2.default)("\n require($0);\n"); var buildExportsModuleDeclaration = (0, _babelTemplate2.default)("\n Object.defineProperty(exports, \"__esModule\", {\n value: true\n });\n"); var buildExportsFrom = (0, _babelTemplate2.default)("\n Object.defineProperty(exports, $0, {\n enumerable: true,\n get: function () {\n return $1;\n }\n });\n"); var buildLooseExportsModuleDeclaration = (0, _babelTemplate2.default)("\n exports.__esModule = true;\n"); var buildExportsAssignment = (0, _babelTemplate2.default)("\n exports.$0 = $1;\n"); var buildExportAll = (0, _babelTemplate2.default)("\n Object.keys(OBJECT).forEach(function (key) {\n if (key === \"default\" || key === \"__esModule\") return;\n Object.defineProperty(exports, key, {\n enumerable: true,\n get: function () {\n return OBJECT[key];\n }\n });\n });\n"); var THIS_BREAK_KEYS = ["FunctionExpression", "FunctionDeclaration", "ClassProperty", "ClassMethod", "ObjectMethod"]; module.exports = exports["default"]; /***/ }), /* 78 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _symbol = __webpack_require__(10); var _symbol2 = _interopRequireDefault(_symbol); exports.default = function (_ref) { var t = _ref.types; function Property(path, node, scope, getObjectRef, file) { var replaceSupers = new _babelHelperReplaceSupers2.default({ getObjectRef: getObjectRef, methodNode: node, methodPath: path, isStatic: true, scope: scope, file: file }); replaceSupers.replace(); } var CONTAINS_SUPER = (0, _symbol2.default)(); return { visitor: { Super: function Super(path) { var parentObj = path.findParent(function (path) { return path.isObjectExpression(); }); if (parentObj) parentObj.node[CONTAINS_SUPER] = true; }, ObjectExpression: { exit: function exit(path, file) { if (!path.node[CONTAINS_SUPER]) return; var objectRef = void 0; var getObjectRef = function getObjectRef() { return objectRef = objectRef || path.scope.generateUidIdentifier("obj"); }; var propPaths = path.get("properties"); for (var _iterator = propPaths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref2; if (_isArray) { if (_i >= _iterator.length) break; _ref2 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref2 = _i.value; } var propPath = _ref2; if (propPath.isObjectProperty()) propPath = propPath.get("value"); Property(propPath, propPath.node, path.scope, getObjectRef, file); } if (objectRef) { path.scope.push({ id: objectRef }); path.replaceWith(t.assignmentExpression("=", objectRef, path.node)); } } } } }; }; var _babelHelperReplaceSupers = __webpack_require__(193); var _babelHelperReplaceSupers2 = _interopRequireDefault(_babelHelperReplaceSupers); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 79 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); exports.default = function () { return { visitor: _babelTraverse.visitors.merge([{ ArrowFunctionExpression: function ArrowFunctionExpression(path) { var params = path.get("params"); for (var _iterator = params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var param = _ref; if (param.isRestElement() || param.isAssignmentPattern()) { path.arrowFunctionToShadowed(); break; } } } }, destructuring.visitor, rest.visitor, def.visitor]) }; }; var _babelTraverse = __webpack_require__(7); var _destructuring = __webpack_require__(334); var destructuring = _interopRequireWildcard(_destructuring); var _default = __webpack_require__(333); var def = _interopRequireWildcard(_default); var _rest = __webpack_require__(335); var rest = _interopRequireWildcard(_rest); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 80 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.default = function () { return { visitor: { ObjectMethod: function ObjectMethod(path) { var node = path.node; if (node.kind === "method") { var func = t.functionExpression(null, node.params, node.body, node.generator, node.async); func.returnType = node.returnType; path.replaceWith(t.objectProperty(node.key, func, node.computed)); } }, ObjectProperty: function ObjectProperty(_ref) { var node = _ref.node; if (node.shorthand) { node.shorthand = false; } } } }; }; var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } module.exports = exports["default"]; /***/ }), /* 81 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); exports.default = function (_ref) { var t = _ref.types; function getSpreadLiteral(spread, scope, state) { if (state.opts.loose && !t.isIdentifier(spread.argument, { name: "arguments" })) { return spread.argument; } else { return scope.toArray(spread.argument, true); } } function hasSpread(nodes) { for (var i = 0; i < nodes.length; i++) { if (t.isSpreadElement(nodes[i])) { return true; } } return false; } function build(props, scope, state) { var nodes = []; var _props = []; function push() { if (!_props.length) return; nodes.push(t.arrayExpression(_props)); _props = []; } for (var _iterator = props, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref2; if (_isArray) { if (_i >= _iterator.length) break; _ref2 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref2 = _i.value; } var prop = _ref2; if (t.isSpreadElement(prop)) { push(); nodes.push(getSpreadLiteral(prop, scope, state)); } else { _props.push(prop); } } push(); return nodes; } return { visitor: { ArrayExpression: function ArrayExpression(path, state) { var node = path.node, scope = path.scope; var elements = node.elements; if (!hasSpread(elements)) return; var nodes = build(elements, scope, state); var first = nodes.shift(); if (!t.isArrayExpression(first)) { nodes.unshift(first); first = t.arrayExpression([]); } path.replaceWith(t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes)); }, CallExpression: function CallExpression(path, state) { var node = path.node, scope = path.scope; var args = node.arguments; if (!hasSpread(args)) return; var calleePath = path.get("callee"); if (calleePath.isSuper()) return; var contextLiteral = t.identifier("undefined"); node.arguments = []; var nodes = void 0; if (args.length === 1 && args[0].argument.name === "arguments") { nodes = [args[0].argument]; } else { nodes = build(args, scope, state); } var first = nodes.shift(); if (nodes.length) { node.arguments.push(t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes)); } else { node.arguments.push(first); } var callee = node.callee; if (calleePath.isMemberExpression()) { var temp = scope.maybeGenerateMemoised(callee.object); if (temp) { callee.object = t.assignmentExpression("=", temp, callee.object); contextLiteral = temp; } else { contextLiteral = callee.object; } t.appendToMemberExpression(callee, t.identifier("apply")); } else { node.callee = t.memberExpression(node.callee, t.identifier("apply")); } if (t.isSuper(contextLiteral)) { contextLiteral = t.thisExpression(); } node.arguments.unshift(contextLiteral); }, NewExpression: function NewExpression(path, state) { var node = path.node, scope = path.scope; var args = node.arguments; if (!hasSpread(args)) return; var nodes = build(args, scope, state); var context = t.arrayExpression([t.nullLiteral()]); args = t.callExpression(t.memberExpression(context, t.identifier("concat")), nodes); path.replaceWith(t.newExpression(t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier("Function"), t.identifier("prototype")), t.identifier("bind")), t.identifier("apply")), [node.callee, args]), [])); } } }; }; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 82 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.default = function () { return { visitor: { RegExpLiteral: function RegExpLiteral(path) { var node = path.node; if (!regex.is(node, "y")) return; path.replaceWith(t.newExpression(t.identifier("RegExp"), [t.stringLiteral(node.pattern), t.stringLiteral(node.flags)])); } } }; }; var _babelHelperRegex = __webpack_require__(192); var regex = _interopRequireWildcard(_babelHelperRegex); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } module.exports = exports["default"]; /***/ }), /* 83 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); exports.default = function (_ref) { var t = _ref.types; function isString(node) { return t.isLiteral(node) && typeof node.value === "string"; } function buildBinaryExpression(left, right) { return t.binaryExpression("+", left, right); } return { visitor: { TaggedTemplateExpression: function TaggedTemplateExpression(path, state) { var node = path.node; var quasi = node.quasi; var args = []; var strings = []; var raw = []; for (var _iterator = quasi.quasis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref2; if (_isArray) { if (_i >= _iterator.length) break; _ref2 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref2 = _i.value; } var elem = _ref2; strings.push(t.stringLiteral(elem.value.cooked)); raw.push(t.stringLiteral(elem.value.raw)); } strings = t.arrayExpression(strings); raw = t.arrayExpression(raw); var templateName = "taggedTemplateLiteral"; if (state.opts.loose) templateName += "Loose"; var templateObject = state.file.addTemplateObject(templateName, strings, raw); args.push(templateObject); args = args.concat(quasi.expressions); path.replaceWith(t.callExpression(node.tag, args)); }, TemplateLiteral: function TemplateLiteral(path, state) { var nodes = []; var expressions = path.get("expressions"); for (var _iterator2 = path.node.quasis, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref3; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref3 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref3 = _i2.value; } var elem = _ref3; nodes.push(t.stringLiteral(elem.value.cooked)); var expr = expressions.shift(); if (expr) { if (state.opts.spec && !expr.isBaseType("string") && !expr.isBaseType("number")) { nodes.push(t.callExpression(t.identifier("String"), [expr.node])); } else { nodes.push(expr.node); } } } nodes = nodes.filter(function (n) { return !t.isLiteral(n, { value: "" }); }); if (!isString(nodes[0]) && !isString(nodes[1])) { nodes.unshift(t.stringLiteral("")); } if (nodes.length > 1) { var root = buildBinaryExpression(nodes.shift(), nodes.shift()); for (var _iterator3 = nodes, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) { var _ref4; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref4 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref4 = _i3.value; } var node = _ref4; root = buildBinaryExpression(root, node); } path.replaceWith(root); } else { path.replaceWith(nodes[0]); } } } }; }; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 84 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _symbol = __webpack_require__(10); var _symbol2 = _interopRequireDefault(_symbol); exports.default = function (_ref) { var t = _ref.types; var IGNORE = (0, _symbol2.default)(); return { visitor: { Scope: function Scope(_ref2) { var scope = _ref2.scope; if (!scope.getBinding("Symbol")) { return; } scope.rename("Symbol"); }, UnaryExpression: function UnaryExpression(path) { var node = path.node, parent = path.parent; if (node[IGNORE]) return; if (path.find(function (path) { return path.node && !!path.node._generated; })) return; if (path.parentPath.isBinaryExpression() && t.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) { var opposite = path.getOpposite(); if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") { return; } } if (node.operator === "typeof") { var call = t.callExpression(this.addHelper("typeof"), [node.argument]); if (path.get("argument").isIdentifier()) { var undefLiteral = t.stringLiteral("undefined"); var unary = t.unaryExpression("typeof", node.argument); unary[IGNORE] = true; path.replaceWith(t.conditionalExpression(t.binaryExpression("===", unary, undefLiteral), undefLiteral, call)); } else { path.replaceWith(call); } } } } }; }; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 85 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.default = function () { return { visitor: { RegExpLiteral: function RegExpLiteral(_ref) { var node = _ref.node; if (!regex.is(node, "u")) return; node.pattern = (0, _regexpuCore2.default)(node.pattern, node.flags); regex.pullFlag(node, "u"); } } }; }; var _regexpuCore = __webpack_require__(612); var _regexpuCore2 = _interopRequireDefault(_regexpuCore); var _babelHelperRegex = __webpack_require__(192); var regex = _interopRequireWildcard(_babelHelperRegex); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 86 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; module.exports = __webpack_require__(606); /***/ }), /* 87 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; module.exports = { "default": __webpack_require__(408), __esModule: true }; /***/ }), /* 88 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.scope = exports.path = undefined; var _weakMap = __webpack_require__(364); var _weakMap2 = _interopRequireDefault(_weakMap); exports.clear = clear; exports.clearPath = clearPath; exports.clearScope = clearScope; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var path = exports.path = new _weakMap2.default(); var scope = exports.scope = new _weakMap2.default(); function clear() { clearPath(); clearScope(); } function clearPath() { exports.path = path = new _weakMap2.default(); } function clearScope() { exports.scope = scope = new _weakMap2.default(); } /***/ }), /* 89 */ /***/ (function(module, exports) { 'use strict'; var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; Object.defineProperty(exports, '__esModule', { value: true }); /* eslint max-len: 0 */ // This is a trick taken from Esprima. It turns out that, on // non-Chrome browsers, to check whether a string is in a set, a // predicate containing a big ugly `switch` statement is faster than // a regular expression, and on Chrome the two are about on par. // This function uses `eval` (non-lexical) to produce such a // predicate from a space-separated string of words. // // It starts by sorting the words by length. function makePredicate(words) { words = words.split(" "); return function (str) { return words.indexOf(str) >= 0; }; } // Reserved word lists for various dialects of the language var reservedWords = { 6: makePredicate("enum await"), strict: makePredicate("implements interface let package private protected public static yield"), strictBind: makePredicate("eval arguments") }; // And the keywords var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super"); // ## Character categories // Big ugly regular expressions that match characters in the // whitespace, identifier, and identifier-start categories. These // are only applied when a character is found to actually have a // code point above 128. // Generated by `bin/generate-identifier-regex.js`. var nonASCIIidentifierStartChars = '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'; var nonASCIIidentifierChars = '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F'; var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"); var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]"); nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the // >0xffff code points that are a valid part of identifiers. The // offset starts at 0x10000, and each pair of numbers represents an // offset to the next range, and then a size of the range. They were // generated by `bin/generate-identifier-regex.js`. // eslint-disable-next-line comma-spacing var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541]; // eslint-disable-next-line comma-spacing var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The // assumption is that looking up astral identifier characters is // rare. function isInAstralSet(code, set) { var pos = 0x10000; for (var i = 0; i < set.length; i += 2) { pos += set[i]; if (pos > code) return false; pos += set[i + 1]; if (pos >= code) return true; } } // Test whether a given character code starts an identifier. function isIdentifierStart(code) { if (code < 65) return code === 36; if (code < 91) return true; if (code < 97) return code === 95; if (code < 123) return true; if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)); return isInAstralSet(code, astralIdentifierStartCodes); } // Test whether a given character is part of an identifier. function isIdentifierChar(code) { if (code < 48) return code === 36; if (code < 58) return true; if (code < 65) return false; if (code < 91) return true; if (code < 97) return code === 95; if (code < 123) return true; if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)); return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes); } // A second optional argument can be given to further configure var defaultOptions = { // Source type ("script" or "module") for different semantics sourceType: "script", // Source filename. sourceFilename: undefined, // Line from which to start counting source. Useful for // integration with other tools. startLine: 1, // When enabled, a return at the top level is not considered an // error. allowReturnOutsideFunction: false, // When enabled, import/export statements are not constrained to // appearing at the top of the program. allowImportExportEverywhere: false, // TODO allowSuperOutsideMethod: false, // An array of plugins to enable plugins: [], // TODO strictMode: null }; // Interpret and default an options object function getOptions(opts) { var options = {}; for (var key in defaultOptions) { options[key] = opts && key in opts ? opts[key] : defaultOptions[key]; } return options; } var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) { return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj); } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj); }; var classCallCheck = function classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }; var inherits = function inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass))); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }; var possibleConstructorReturn = function possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self; }; // ## Token types // The assignment of fine-grained, information-carrying type objects // allows the tokenizer to store the information it has about a // token in a way that is very cheap for the parser to look up. // All token type variables start with an underscore, to make them // easy to recognize. // The `beforeExpr` property is used to disambiguate between regular // expressions and divisions. It is set on all token types that can // be followed by an expression (thus, a slash after them would be a // regular expression). // // `isLoop` marks a keyword as starting a loop, which is important // to know when parsing a label, in order to allow or disallow // continue jumps to that label. var beforeExpr = true; var startsExpr = true; var isLoop = true; var isAssign = true; var prefix = true; var postfix = true; var TokenType = function TokenType(label) { var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; classCallCheck(this, TokenType); this.label = label; this.keyword = conf.keyword; this.beforeExpr = !!conf.beforeExpr; this.startsExpr = !!conf.startsExpr; this.rightAssociative = !!conf.rightAssociative; this.isLoop = !!conf.isLoop; this.isAssign = !!conf.isAssign; this.prefix = !!conf.prefix; this.postfix = !!conf.postfix; this.binop = conf.binop || null; this.updateContext = null; }; var KeywordTokenType = function (_TokenType) { inherits(KeywordTokenType, _TokenType); function KeywordTokenType(name) { var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; classCallCheck(this, KeywordTokenType); options.keyword = name; return possibleConstructorReturn(this, _TokenType.call(this, name, options)); } return KeywordTokenType; }(TokenType); var BinopTokenType = function (_TokenType2) { inherits(BinopTokenType, _TokenType2); function BinopTokenType(name, prec) { classCallCheck(this, BinopTokenType); return possibleConstructorReturn(this, _TokenType2.call(this, name, { beforeExpr: beforeExpr, binop: prec })); } return BinopTokenType; }(TokenType); var types = { num: new TokenType("num", { startsExpr: startsExpr }), regexp: new TokenType("regexp", { startsExpr: startsExpr }), string: new TokenType("string", { startsExpr: startsExpr }), name: new TokenType("name", { startsExpr: startsExpr }), eof: new TokenType("eof"), // Punctuation token types. bracketL: new TokenType("[", { beforeExpr: beforeExpr, startsExpr: startsExpr }), bracketR: new TokenType("]"), braceL: new TokenType("{", { beforeExpr: beforeExpr, startsExpr: startsExpr }), braceBarL: new TokenType("{|", { beforeExpr: beforeExpr, startsExpr: startsExpr }), braceR: new TokenType("}"), braceBarR: new TokenType("|}"), parenL: new TokenType("(", { beforeExpr: beforeExpr, startsExpr: startsExpr }), parenR: new TokenType(")"), comma: new TokenType(",", { beforeExpr: beforeExpr }), semi: new TokenType(";", { beforeExpr: beforeExpr }), colon: new TokenType(":", { beforeExpr: beforeExpr }), doubleColon: new TokenType("::", { beforeExpr: beforeExpr }), dot: new TokenType("."), question: new TokenType("?", { beforeExpr: beforeExpr }), arrow: new TokenType("=>", { beforeExpr: beforeExpr }), template: new TokenType("template"), ellipsis: new TokenType("...", { beforeExpr: beforeExpr }), backQuote: new TokenType("`", { startsExpr: startsExpr }), dollarBraceL: new TokenType("${", { beforeExpr: beforeExpr, startsExpr: startsExpr }), at: new TokenType("@"), // Operators. These carry several kinds of properties to help the // parser use them properly (the presence of these properties is // what categorizes them as operators). // // `binop`, when present, specifies that this operator is a binary // operator, and will refer to its precedence. // // `prefix` and `postfix` mark the operator as a prefix or postfix // unary operator. // // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as // binary operators with a very low precedence, that should result // in AssignmentExpression nodes. eq: new TokenType("=", { beforeExpr: beforeExpr, isAssign: isAssign }), assign: new TokenType("_=", { beforeExpr: beforeExpr, isAssign: isAssign }), incDec: new TokenType("++/--", { prefix: prefix, postfix: postfix, startsExpr: startsExpr }), prefix: new TokenType("prefix", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }), logicalOR: new BinopTokenType("||", 1), logicalAND: new BinopTokenType("&&", 2), bitwiseOR: new BinopTokenType("|", 3), bitwiseXOR: new BinopTokenType("^", 4), bitwiseAND: new BinopTokenType("&", 5), equality: new BinopTokenType("==/!=", 6), relational: new BinopTokenType("</>", 7), bitShift: new BinopTokenType("<</>>", 8), plusMin: new TokenType("+/-", { beforeExpr: beforeExpr, binop: 9, prefix: prefix, startsExpr: startsExpr }), modulo: new BinopTokenType("%", 10), star: new BinopTokenType("*", 10), slash: new BinopTokenType("/", 10), exponent: new TokenType("**", { beforeExpr: beforeExpr, binop: 11, rightAssociative: true }) }; var keywords = { "break": new KeywordTokenType("break"), "case": new KeywordTokenType("case", { beforeExpr: beforeExpr }), "catch": new KeywordTokenType("catch"), "continue": new KeywordTokenType("continue"), "debugger": new KeywordTokenType("debugger"), "default": new KeywordTokenType("default", { beforeExpr: beforeExpr }), "do": new KeywordTokenType("do", { isLoop: isLoop, beforeExpr: beforeExpr }), "else": new KeywordTokenType("else", { beforeExpr: beforeExpr }), "finally": new KeywordTokenType("finally"), "for": new KeywordTokenType("for", { isLoop: isLoop }), "function": new KeywordTokenType("function", { startsExpr: startsExpr }), "if": new KeywordTokenType("if"), "return": new KeywordTokenType("return", { beforeExpr: beforeExpr }), "switch": new KeywordTokenType("switch"), "throw": new KeywordTokenType("throw", { beforeExpr: beforeExpr }), "try": new KeywordTokenType("try"), "var": new KeywordTokenType("var"), "let": new KeywordTokenType("let"), "const": new KeywordTokenType("const"), "while": new KeywordTokenType("while", { isLoop: isLoop }), "with": new KeywordTokenType("with"), "new": new KeywordTokenType("new", { beforeExpr: beforeExpr, startsExpr: startsExpr }), "this": new KeywordTokenType("this", { startsExpr: startsExpr }), "super": new KeywordTokenType("super", { startsExpr: startsExpr }), "class": new KeywordTokenType("class"), "extends": new KeywordTokenType("extends", { beforeExpr: beforeExpr }), "export": new KeywordTokenType("export"), "import": new KeywordTokenType("import", { startsExpr: startsExpr }), "yield": new KeywordTokenType("yield", { beforeExpr: beforeExpr, startsExpr: startsExpr }), "null": new KeywordTokenType("null", { startsExpr: startsExpr }), "true": new KeywordTokenType("true", { startsExpr: startsExpr }), "false": new KeywordTokenType("false", { startsExpr: startsExpr }), "in": new KeywordTokenType("in", { beforeExpr: beforeExpr, binop: 7 }), "instanceof": new KeywordTokenType("instanceof", { beforeExpr: beforeExpr, binop: 7 }), "typeof": new KeywordTokenType("typeof", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }), "void": new KeywordTokenType("void", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }), "delete": new KeywordTokenType("delete", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }) }; // Map keyword names to token types. Object.keys(keywords).forEach(function (name) { types["_" + name] = keywords[name]; }); // Matches a whole line break (where CRLF is considered a single // line break). Used to count lines. var lineBreak = /\r\n?|\n|\u2028|\u2029/; var lineBreakG = new RegExp(lineBreak.source, "g"); function isNewLine(code) { return code === 10 || code === 13 || code === 0x2028 || code === 0x2029; } var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // The algorithm used to determine whether a regexp can appear at a // given point in the program is loosely based on sweet.js' approach. // See https://github.com/mozilla/sweet.js/wiki/design var TokContext = function TokContext(token, isExpr, preserveSpace, override) { classCallCheck(this, TokContext); this.token = token; this.isExpr = !!isExpr; this.preserveSpace = !!preserveSpace; this.override = override; }; var types$1 = { braceStatement: new TokContext("{", false), braceExpression: new TokContext("{", true), templateQuasi: new TokContext("${", true), parenStatement: new TokContext("(", false), parenExpression: new TokContext("(", true), template: new TokContext("`", true, true, function (p) { return p.readTmplToken(); }), functionExpression: new TokContext("function", true) }; // Token-specific context update code types.parenR.updateContext = types.braceR.updateContext = function () { if (this.state.context.length === 1) { this.state.exprAllowed = true; return; } var out = this.state.context.pop(); if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) { this.state.context.pop(); this.state.exprAllowed = false; } else if (out === types$1.templateQuasi) { this.state.exprAllowed = true; } else { this.state.exprAllowed = !out.isExpr; } }; types.name.updateContext = function (prevType) { this.state.exprAllowed = false; if (prevType === types._let || prevType === types._const || prevType === types._var) { if (lineBreak.test(this.input.slice(this.state.end))) { this.state.exprAllowed = true; } } }; types.braceL.updateContext = function (prevType) { this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression); this.state.exprAllowed = true; }; types.dollarBraceL.updateContext = function () { this.state.context.push(types$1.templateQuasi); this.state.exprAllowed = true; }; types.parenL.updateContext = function (prevType) { var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while; this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression); this.state.exprAllowed = true; }; types.incDec.updateContext = function () { // tokExprAllowed stays unchanged }; types._function.updateContext = function () { if (this.curContext() !== types$1.braceStatement) { this.state.context.push(types$1.functionExpression); } this.state.exprAllowed = false; }; types.backQuote.updateContext = function () { if (this.curContext() === types$1.template) { this.state.context.pop(); } else { this.state.context.push(types$1.template); } this.state.exprAllowed = false; }; // These are used when `options.locations` is on, for the // `startLoc` and `endLoc` properties. var Position = function Position(line, col) { classCallCheck(this, Position); this.line = line; this.column = col; }; var SourceLocation = function SourceLocation(start, end) { classCallCheck(this, SourceLocation); this.start = start; this.end = end; }; // The `getLineInfo` function is mostly useful when the // `locations` option is off (for performance reasons) and you // want to find the line/column position for a given character // offset. `input` should be the code string that the offset refers // into. function getLineInfo(input, offset) { for (var line = 1, cur = 0;;) { lineBreakG.lastIndex = cur; var match = lineBreakG.exec(input); if (match && match.index < offset) { ++line; cur = match.index + match[0].length; } else { return new Position(line, offset - cur); } } } var State = function () { function State() { classCallCheck(this, State); } State.prototype.init = function init(options, input) { this.strict = options.strictMode === false ? false : options.sourceType === "module"; this.input = input; this.potentialArrowAt = -1; this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.inClassProperty = this.noAnonFunctionType = false; this.labels = []; this.decorators = []; this.tokens = []; this.comments = []; this.trailingComments = []; this.leadingComments = []; this.commentStack = []; this.pos = this.lineStart = 0; this.curLine = options.startLine; this.type = types.eof; this.value = null; this.start = this.end = this.pos; this.startLoc = this.endLoc = this.curPosition(); this.lastTokEndLoc = this.lastTokStartLoc = null; this.lastTokStart = this.lastTokEnd = this.pos; this.context = [types$1.braceStatement]; this.exprAllowed = true; this.containsEsc = this.containsOctal = false; this.octalPosition = null; this.invalidTemplateEscapePosition = null; this.exportedIdentifiers = []; return this; }; // TODO // TODO // Used to signify the start of a potential arrow function // Flags to track whether we are in a function, a generator. // Labels in scope. // Leading decorators. // Token store. // Comment store. // Comment attachment store // The current position of the tokenizer in the input. // Properties of the current token: // Its type // For tokens that include more information than their type, the value // Its start and end offset // And, if locations are used, the {line, column} object // corresponding to those offsets // Position information for the previous token // The context stack is used to superficially track syntactic // context to predict whether a regular expression is allowed in a // given position. // Used to signal to callers of `readWord1` whether the word // contained any escape sequences. This is needed because words with // escape sequences must not be interpreted as keywords. // TODO // Names of exports store. `default` is stored as a name for both // `export default foo;` and `export { foo as default };`. State.prototype.curPosition = function curPosition() { return new Position(this.curLine, this.pos - this.lineStart); }; State.prototype.clone = function clone(skipArrays) { var state = new State(); for (var key in this) { var val = this[key]; if ((!skipArrays || key === "context") && Array.isArray(val)) { val = val.slice(); } state[key] = val; } return state; }; return State; }(); // Object type used to represent tokens. Note that normally, tokens // simply exist as properties on the parser object. This is only // used for the onToken callback and the external tokenizer. var Token = function Token(state) { classCallCheck(this, Token); this.type = state.type; this.value = state.value; this.start = state.start; this.end = state.end; this.loc = new SourceLocation(state.startLoc, state.endLoc); }; // ## Tokenizer function codePointToString(code) { // UTF-16 Decoding if (code <= 0xFFFF) { return String.fromCharCode(code); } else { return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00); } } var Tokenizer = function () { function Tokenizer(options, input) { classCallCheck(this, Tokenizer); this.state = new State(); this.state.init(options, input); } // Move to the next token Tokenizer.prototype.next = function next() { if (!this.isLookahead) { this.state.tokens.push(new Token(this.state)); } this.state.lastTokEnd = this.state.end; this.state.lastTokStart = this.state.start; this.state.lastTokEndLoc = this.state.endLoc; this.state.lastTokStartLoc = this.state.startLoc; this.nextToken(); }; // TODO Tokenizer.prototype.eat = function eat(type) { if (this.match(type)) { this.next(); return true; } else { return false; } }; // TODO Tokenizer.prototype.match = function match(type) { return this.state.type === type; }; // TODO Tokenizer.prototype.isKeyword = function isKeyword$$1(word) { return isKeyword(word); }; // TODO Tokenizer.prototype.lookahead = function lookahead() { var old = this.state; this.state = old.clone(true); this.isLookahead = true; this.next(); this.isLookahead = false; var curr = this.state.clone(true); this.state = old; return curr; }; // Toggle strict mode. Re-reads the next number or string to please // pedantic tests (`"use strict"; 010;` should fail). Tokenizer.prototype.setStrict = function setStrict(strict) { this.state.strict = strict; if (!this.match(types.num) && !this.match(types.string)) return; this.state.pos = this.state.start; while (this.state.pos < this.state.lineStart) { this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1; --this.state.curLine; } this.nextToken(); }; Tokenizer.prototype.curContext = function curContext() { return this.state.context[this.state.context.length - 1]; }; // Read a single token, updating the parser object's token-related // properties. Tokenizer.prototype.nextToken = function nextToken() { var curContext = this.curContext(); if (!curContext || !curContext.preserveSpace) this.skipSpace(); this.state.containsOctal = false; this.state.octalPosition = null; this.state.start = this.state.pos; this.state.startLoc = this.state.curPosition(); if (this.state.pos >= this.input.length) return this.finishToken(types.eof); if (curContext.override) { return curContext.override(this); } else { return this.readToken(this.fullCharCodeAtPos()); } }; Tokenizer.prototype.readToken = function readToken(code) { // Identifier or keyword. '\uXXXX' sequences are allowed in // identifiers, so '\' also dispatches to that. if (isIdentifierStart(code) || code === 92 /* '\' */) { return this.readWord(); } else { return this.getTokenFromCode(code); } }; Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() { var code = this.input.charCodeAt(this.state.pos); if (code <= 0xd7ff || code >= 0xe000) return code; var next = this.input.charCodeAt(this.state.pos + 1); return (code << 10) + next - 0x35fdc00; }; Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) { var comment = { type: block ? "CommentBlock" : "CommentLine", value: text, start: start, end: end, loc: new SourceLocation(startLoc, endLoc) }; if (!this.isLookahead) { this.state.tokens.push(comment); this.state.comments.push(comment); this.addComment(comment); } }; Tokenizer.prototype.skipBlockComment = function skipBlockComment() { var startLoc = this.state.curPosition(); var start = this.state.pos; var end = this.input.indexOf("*/", this.state.pos += 2); if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment"); this.state.pos = end + 2; lineBreakG.lastIndex = start; var match = void 0; while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) { ++this.state.curLine; this.state.lineStart = match.index + match[0].length; } this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition()); }; Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) { var start = this.state.pos; var startLoc = this.state.curPosition(); var ch = this.input.charCodeAt(this.state.pos += startSkip); while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) { ++this.state.pos; ch = this.input.charCodeAt(this.state.pos); } this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition()); }; // Called at the start of the parse and after every token. Skips // whitespace and comments, and. Tokenizer.prototype.skipSpace = function skipSpace() { loop: while (this.state.pos < this.input.length) { var ch = this.input.charCodeAt(this.state.pos); switch (ch) { case 32:case 160: // ' ' ++this.state.pos; break; case 13: if (this.input.charCodeAt(this.state.pos + 1) === 10) { ++this.state.pos; } case 10:case 8232:case 8233: ++this.state.pos; ++this.state.curLine; this.state.lineStart = this.state.pos; break; case 47: // '/' switch (this.input.charCodeAt(this.state.pos + 1)) { case 42: // '*' this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break loop; } break; default: if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) { ++this.state.pos; } else { break loop; } } } }; // Called at the end of every token. Sets `end`, `val`, and // maintains `context` and `exprAllowed`, and skips the space after // the token, so that the next one's `start` will point at the // right position. Tokenizer.prototype.finishToken = function finishToken(type, val) { this.state.end = this.state.pos; this.state.endLoc = this.state.curPosition(); var prevType = this.state.type; this.state.type = type; this.state.value = val; this.updateContext(prevType); }; // ### Token reading // This is the function that is called to fetch the next token. It // is somewhat obscure, because it works in character codes rather // than characters, and because operator parsing has been inlined // into it. // // All in the name of speed. // Tokenizer.prototype.readToken_dot = function readToken_dot() { var next = this.input.charCodeAt(this.state.pos + 1); if (next >= 48 && next <= 57) { return this.readNumber(true); } var next2 = this.input.charCodeAt(this.state.pos + 2); if (next === 46 && next2 === 46) { // 46 = dot '.' this.state.pos += 3; return this.finishToken(types.ellipsis); } else { ++this.state.pos; return this.finishToken(types.dot); } }; Tokenizer.prototype.readToken_slash = function readToken_slash() { // '/' if (this.state.exprAllowed) { ++this.state.pos; return this.readRegexp(); } var next = this.input.charCodeAt(this.state.pos + 1); if (next === 61) { return this.finishOp(types.assign, 2); } else { return this.finishOp(types.slash, 1); } }; Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) { // '%*' var type = code === 42 ? types.star : types.modulo; var width = 1; var next = this.input.charCodeAt(this.state.pos + 1); if (next === 42) { // '*' width++; next = this.input.charCodeAt(this.state.pos + 2); type = types.exponent; } if (next === 61) { width++; type = types.assign; } return this.finishOp(type, width); }; Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) { // '|&' var next = this.input.charCodeAt(this.state.pos + 1); if (next === code) return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2); if (next === 61) return this.finishOp(types.assign, 2); if (code === 124 && next === 125 && this.hasPlugin("flow")) return this.finishOp(types.braceBarR, 2); return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1); }; Tokenizer.prototype.readToken_caret = function readToken_caret() { // '^' var next = this.input.charCodeAt(this.state.pos + 1); if (next === 61) { return this.finishOp(types.assign, 2); } else { return this.finishOp(types.bitwiseXOR, 1); } }; Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) { // '+-' var next = this.input.charCodeAt(this.state.pos + 1); if (next === code) { if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) { // A `-->` line comment this.skipLineComment(3); this.skipSpace(); return this.nextToken(); } return this.finishOp(types.incDec, 2); } if (next === 61) { return this.finishOp(types.assign, 2); } else { return this.finishOp(types.plusMin, 1); } }; Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) { // '<>' var next = this.input.charCodeAt(this.state.pos + 1); var size = 1; if (next === code) { size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2; if (this.input.charCodeAt(this.state.pos + size) === 61) return this.finishOp(types.assign, size + 1); return this.finishOp(types.bitShift, size); } if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) { if (this.inModule) this.unexpected(); // `<!--`, an XML-style comment that should be interpreted as a line comment this.skipLineComment(4); this.skipSpace(); return this.nextToken(); } if (next === 61) { // <= | >= size = 2; } return this.finishOp(types.relational, size); }; Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) { // '=!' var next = this.input.charCodeAt(this.state.pos + 1); if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2); if (code === 61 && next === 62) { // '=>' this.state.pos += 2; return this.finishToken(types.arrow); } return this.finishOp(code === 61 ? types.eq : types.prefix, 1); }; Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) { switch (code) { // The interpretation of a dot depends on whether it is followed // by a digit or another two dots. case 46: // '.' return this.readToken_dot(); // Punctuation tokens. case 40: ++this.state.pos;return this.finishToken(types.parenL); case 41: ++this.state.pos;return this.finishToken(types.parenR); case 59: ++this.state.pos;return this.finishToken(types.semi); case 44: ++this.state.pos;return this.finishToken(types.comma); case 91: ++this.state.pos;return this.finishToken(types.bracketL); case 93: ++this.state.pos;return this.finishToken(types.bracketR); case 123: if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) { return this.finishOp(types.braceBarL, 2); } else { ++this.state.pos; return this.finishToken(types.braceL); } case 125: ++this.state.pos;return this.finishToken(types.braceR); case 58: if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) { return this.finishOp(types.doubleColon, 2); } else { ++this.state.pos; return this.finishToken(types.colon); } case 63: ++this.state.pos;return this.finishToken(types.question); case 64: ++this.state.pos;return this.finishToken(types.at); case 96: // '`' ++this.state.pos; return this.finishToken(types.backQuote); case 48: // '0' var next = this.input.charCodeAt(this.state.pos + 1); if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number // Anything else beginning with a digit is an integer, octal // number, or float. case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57: // 1-9 return this.readNumber(false); // Quotes produce strings. case 34:case 39: // '"', "'" return this.readString(code); // Operators are parsed inline in tiny state machines. '=' (61) is // often referred to. `finishOp` simply skips the amount of // characters it is given as second argument, and returns a token // of the type given by its first argument. case 47: // '/' return this.readToken_slash(); case 37:case 42: // '%*' return this.readToken_mult_modulo(code); case 124:case 38: // '|&' return this.readToken_pipe_amp(code); case 94: // '^' return this.readToken_caret(); case 43:case 45: // '+-' return this.readToken_plus_min(code); case 60:case 62: // '<>' return this.readToken_lt_gt(code); case 61:case 33: // '=!' return this.readToken_eq_excl(code); case 126: // '~' return this.finishOp(types.prefix, 1); } this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'"); }; Tokenizer.prototype.finishOp = function finishOp(type, size) { var str = this.input.slice(this.state.pos, this.state.pos + size); this.state.pos += size; return this.finishToken(type, str); }; Tokenizer.prototype.readRegexp = function readRegexp() { var start = this.state.pos; var escaped = void 0, inClass = void 0; for (;;) { if (this.state.pos >= this.input.length) this.raise(start, "Unterminated regular expression"); var ch = this.input.charAt(this.state.pos); if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); } if (escaped) { escaped = false; } else { if (ch === "[") { inClass = true; } else if (ch === "]" && inClass) { inClass = false; } else if (ch === "/" && !inClass) { break; } escaped = ch === "\\"; } ++this.state.pos; } var content = this.input.slice(start, this.state.pos); ++this.state.pos; // Need to use `readWord1` because '\uXXXX' sequences are allowed // here (don't ask). var mods = this.readWord1(); if (mods) { var validFlags = /^[gmsiyu]*$/; if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag"); } return this.finishToken(types.regexp, { pattern: content, flags: mods }); }; // Read an integer in the given radix. Return null if zero digits // were read, the integer value otherwise. When `len` is given, this // will return `null` unless the integer has exactly `len` digits. Tokenizer.prototype.readInt = function readInt(radix, len) { var start = this.state.pos; var total = 0; for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) { var code = this.input.charCodeAt(this.state.pos); var val = void 0; if (code >= 97) { val = code - 97 + 10; // a } else if (code >= 65) { val = code - 65 + 10; // A } else if (code >= 48 && code <= 57) { val = code - 48; // 0-9 } else { val = Infinity; } if (val >= radix) break; ++this.state.pos; total = total * radix + val; } if (this.state.pos === start || len != null && this.state.pos - start !== len) return null; return total; }; Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) { this.state.pos += 2; // 0x var val = this.readInt(radix); if (val == null) this.raise(this.state.start + 2, "Expected number in radix " + radix); if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number"); return this.finishToken(types.num, val); }; // Read an integer, octal integer, or floating-point number. Tokenizer.prototype.readNumber = function readNumber(startsWithDot) { var start = this.state.pos; var octal = this.input.charCodeAt(start) === 48; // '0' var isFloat = false; if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number"); if (octal && this.state.pos == start + 1) octal = false; // number === 0 var next = this.input.charCodeAt(this.state.pos); if (next === 46 && !octal) { // '.' ++this.state.pos; this.readInt(10); isFloat = true; next = this.input.charCodeAt(this.state.pos); } if ((next === 69 || next === 101) && !octal) { // 'eE' next = this.input.charCodeAt(++this.state.pos); if (next === 43 || next === 45) ++this.state.pos; // '+-' if (this.readInt(10) === null) this.raise(start, "Invalid number"); isFloat = true; } if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number"); var str = this.input.slice(start, this.state.pos); var val = void 0; if (isFloat) { val = parseFloat(str); } else if (!octal || str.length === 1) { val = parseInt(str, 10); } else if (this.state.strict) { this.raise(start, "Invalid number"); } else if (/[89]/.test(str)) { val = parseInt(str, 10); } else { val = parseInt(str, 8); } return this.finishToken(types.num, val); }; // Read a string value, interpreting backslash-escapes. Tokenizer.prototype.readCodePoint = function readCodePoint(throwOnInvalid) { var ch = this.input.charCodeAt(this.state.pos); var code = void 0; if (ch === 123) { // '{' var codePos = ++this.state.pos; code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, throwOnInvalid); ++this.state.pos; if (code === null) { --this.state.invalidTemplateEscapePosition; // to point to the '\'' instead of the 'u' } else if (code > 0x10FFFF) { if (throwOnInvalid) { this.raise(codePos, "Code point out of bounds"); } else { this.state.invalidTemplateEscapePosition = codePos - 2; return null; } } } else { code = this.readHexChar(4, throwOnInvalid); } return code; }; Tokenizer.prototype.readString = function readString(quote) { var out = "", chunkStart = ++this.state.pos; for (;;) { if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated string constant"); var ch = this.input.charCodeAt(this.state.pos); if (ch === quote) break; if (ch === 92) { // '\' out += this.input.slice(chunkStart, this.state.pos); out += this.readEscapedChar(false); chunkStart = this.state.pos; } else { if (isNewLine(ch)) this.raise(this.state.start, "Unterminated string constant"); ++this.state.pos; } } out += this.input.slice(chunkStart, this.state.pos++); return this.finishToken(types.string, out); }; // Reads template string tokens. Tokenizer.prototype.readTmplToken = function readTmplToken() { var out = "", chunkStart = this.state.pos, containsInvalid = false; for (;;) { if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated template"); var ch = this.input.charCodeAt(this.state.pos); if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) { // '`', '${' if (this.state.pos === this.state.start && this.match(types.template)) { if (ch === 36) { this.state.pos += 2; return this.finishToken(types.dollarBraceL); } else { ++this.state.pos; return this.finishToken(types.backQuote); } } out += this.input.slice(chunkStart, this.state.pos); return this.finishToken(types.template, containsInvalid ? null : out); } if (ch === 92) { // '\' out += this.input.slice(chunkStart, this.state.pos); var escaped = this.readEscapedChar(true); if (escaped === null) { containsInvalid = true; } else { out += escaped; } chunkStart = this.state.pos; } else if (isNewLine(ch)) { out += this.input.slice(chunkStart, this.state.pos); ++this.state.pos; switch (ch) { case 13: if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; case 10: out += "\n"; break; default: out += String.fromCharCode(ch); break; } ++this.state.curLine; this.state.lineStart = this.state.pos; chunkStart = this.state.pos; } else { ++this.state.pos; } } }; // Used to read escaped characters Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) { var throwOnInvalid = !inTemplate; var ch = this.input.charCodeAt(++this.state.pos); ++this.state.pos; switch (ch) { case 110: return "\n"; // 'n' -> '\n' case 114: return "\r"; // 'r' -> '\r' case 120: { // 'x' var code = this.readHexChar(2, throwOnInvalid); return code === null ? null : String.fromCharCode(code); } case 117: { // 'u' var _code = this.readCodePoint(throwOnInvalid); return _code === null ? null : codePointToString(_code); } case 116: return "\t"; // 't' -> '\t' case 98: return "\b"; // 'b' -> '\b' case 118: return "\x0B"; // 'v' -> '\u000b' case 102: return "\f"; // 'f' -> '\f' case 13: if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; // '\r\n' case 10: // ' \n' this.state.lineStart = this.state.pos; ++this.state.curLine; return ""; default: if (ch >= 48 && ch <= 55) { var codePos = this.state.pos - 1; var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0]; var octal = parseInt(octalStr, 8); if (octal > 255) { octalStr = octalStr.slice(0, -1); octal = parseInt(octalStr, 8); } if (octal > 0) { if (inTemplate) { this.state.invalidTemplateEscapePosition = codePos; return null; } else if (this.state.strict) { this.raise(codePos, "Octal literal in strict mode"); } else if (!this.state.containsOctal) { // These properties are only used to throw an error for an octal which occurs // in a directive which occurs prior to a "use strict" directive. this.state.containsOctal = true; this.state.octalPosition = codePos; } } this.state.pos += octalStr.length - 1; return String.fromCharCode(octal); } return String.fromCharCode(ch); } }; // Used to read character escape sequences ('\x', '\u'). Tokenizer.prototype.readHexChar = function readHexChar(len, throwOnInvalid) { var codePos = this.state.pos; var n = this.readInt(16, len); if (n === null) { if (throwOnInvalid) { this.raise(codePos, "Bad character escape sequence"); } else { this.state.pos = codePos - 1; this.state.invalidTemplateEscapePosition = codePos - 1; } } return n; }; // Read an identifier, and return it as a string. Sets `this.state.containsEsc` // to whether the word contained a '\u' escape. // // Incrementally adds only escaped chars, adding other chunks as-is // as a micro-optimization. Tokenizer.prototype.readWord1 = function readWord1() { this.state.containsEsc = false; var word = "", first = true, chunkStart = this.state.pos; while (this.state.pos < this.input.length) { var ch = this.fullCharCodeAtPos(); if (isIdentifierChar(ch)) { this.state.pos += ch <= 0xffff ? 1 : 2; } else if (ch === 92) { // "\" this.state.containsEsc = true; word += this.input.slice(chunkStart, this.state.pos); var escStart = this.state.pos; if (this.input.charCodeAt(++this.state.pos) !== 117) { // "u" this.raise(this.state.pos, 'Expecting Unicode escape sequence \\uXXXX'); } ++this.state.pos; var esc = this.readCodePoint(true); if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) { this.raise(escStart, "Invalid Unicode escape"); } word += codePointToString(esc); chunkStart = this.state.pos; } else { break; } first = false; } return word + this.input.slice(chunkStart, this.state.pos); }; // Read an identifier or keyword token. Will check for reserved // words when necessary. Tokenizer.prototype.readWord = function readWord() { var word = this.readWord1(); var type = types.name; if (!this.state.containsEsc && this.isKeyword(word)) { type = keywords[word]; } return this.finishToken(type, word); }; Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) { if (prevType === types.colon) { var parent = this.curContext(); if (parent === types$1.braceStatement || parent === types$1.braceExpression) { return !parent.isExpr; } } if (prevType === types._return) { return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start)); } if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) { return true; } if (prevType === types.braceL) { return this.curContext() === types$1.braceStatement; } return !this.state.exprAllowed; }; Tokenizer.prototype.updateContext = function updateContext(prevType) { var type = this.state.type; var update = void 0; if (type.keyword && prevType === types.dot) { this.state.exprAllowed = false; } else if (update = type.updateContext) { update.call(this, prevType); } else { this.state.exprAllowed = type.beforeExpr; } }; return Tokenizer; }(); var plugins = {}; var frozenDeprecatedWildcardPluginList = ["jsx", "doExpressions", "objectRestSpread", "decorators", "classProperties", "exportExtensions", "asyncGenerators", "functionBind", "functionSent", "dynamicImport", "flow"]; var Parser = function (_Tokenizer) { inherits(Parser, _Tokenizer); function Parser(options, input) { classCallCheck(this, Parser); options = getOptions(options); var _this = possibleConstructorReturn(this, _Tokenizer.call(this, options, input)); _this.options = options; _this.inModule = _this.options.sourceType === "module"; _this.input = input; _this.plugins = _this.loadPlugins(_this.options.plugins); _this.filename = options.sourceFilename; // If enabled, skip leading hashbang line. if (_this.state.pos === 0 && _this.input[0] === "#" && _this.input[1] === "!") { _this.skipLineComment(2); } return _this; } Parser.prototype.isReservedWord = function isReservedWord(word) { if (word === "await") { return this.inModule; } else { return reservedWords[6](word); } }; Parser.prototype.hasPlugin = function hasPlugin(name) { if (this.plugins["*"] && frozenDeprecatedWildcardPluginList.indexOf(name) > -1) { return true; } return !!this.plugins[name]; }; Parser.prototype.extend = function extend(name, f) { this[name] = f(this[name]); }; Parser.prototype.loadAllPlugins = function loadAllPlugins() { var _this2 = this; // ensure flow plugin loads last, also ensure estree is not loaded with * var pluginNames = Object.keys(plugins).filter(function (name) { return name !== "flow" && name !== "estree"; }); pluginNames.push("flow"); pluginNames.forEach(function (name) { var plugin = plugins[name]; if (plugin) plugin(_this2); }); }; Parser.prototype.loadPlugins = function loadPlugins(pluginList) { // TODO: Deprecate "*" option in next major version of Babylon if (pluginList.indexOf("*") >= 0) { this.loadAllPlugins(); return { "*": true }; } var pluginMap = {}; if (pluginList.indexOf("flow") >= 0) { // ensure flow plugin loads last pluginList = pluginList.filter(function (plugin) { return plugin !== "flow"; }); pluginList.push("flow"); } if (pluginList.indexOf("estree") >= 0) { // ensure estree plugin loads first pluginList = pluginList.filter(function (plugin) { return plugin !== "estree"; }); pluginList.unshift("estree"); } for (var _iterator = pluginList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var name = _ref; if (!pluginMap[name]) { pluginMap[name] = true; var plugin = plugins[name]; if (plugin) plugin(this); } } return pluginMap; }; Parser.prototype.parse = function parse() { var file = this.startNode(); var program = this.startNode(); this.nextToken(); return this.parseTopLevel(file, program); }; return Parser; }(Tokenizer); var pp = Parser.prototype; // ## Parser utilities // TODO pp.addExtra = function (node, key, val) { if (!node) return; var extra = node.extra = node.extra || {}; extra[key] = val; }; // TODO pp.isRelational = function (op) { return this.match(types.relational) && this.state.value === op; }; // TODO pp.expectRelational = function (op) { if (this.isRelational(op)) { this.next(); } else { this.unexpected(null, types.relational); } }; // Tests whether parsed token is a contextual keyword. pp.isContextual = function (name) { return this.match(types.name) && this.state.value === name; }; // Consumes contextual keyword if possible. pp.eatContextual = function (name) { return this.state.value === name && this.eat(types.name); }; // Asserts that following token is given contextual keyword. pp.expectContextual = function (name, message) { if (!this.eatContextual(name)) this.unexpected(null, message); }; // Test whether a semicolon can be inserted at the current position. pp.canInsertSemicolon = function () { return this.match(types.eof) || this.match(types.braceR) || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start)); }; // TODO pp.isLineTerminator = function () { return this.eat(types.semi) || this.canInsertSemicolon(); }; // Consume a semicolon, or, failing that, see if we are allowed to // pretend that there is a semicolon at this position. pp.semicolon = function () { if (!this.isLineTerminator()) this.unexpected(null, types.semi); }; // Expect a token of a given type. If found, consume it, otherwise, // raise an unexpected token error at given pos. pp.expect = function (type, pos) { return this.eat(type) || this.unexpected(pos, type); }; // Raise an unexpected token error. Can take the expected token type // instead of a message string. pp.unexpected = function (pos) { var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token"; if (messageOrType && (typeof messageOrType === "undefined" ? "undefined" : _typeof(messageOrType)) === "object" && messageOrType.label) { messageOrType = "Unexpected token, expected " + messageOrType.label; } this.raise(pos != null ? pos : this.state.start, messageOrType); }; /* eslint max-len: 0 */ var pp$1 = Parser.prototype; // ### Statement parsing // Parse a program. Initializes the parser, reads any number of // statements, and wraps them in a Program node. Optionally takes a // `program` argument. If present, the statements will be appended // to its body instead of creating a new node. pp$1.parseTopLevel = function (file, program) { program.sourceType = this.options.sourceType; this.parseBlockBody(program, true, true, types.eof); file.program = this.finishNode(program, "Program"); file.comments = this.state.comments; file.tokens = this.state.tokens; return this.finishNode(file, "File"); }; var loopLabel = { kind: "loop" }; var switchLabel = { kind: "switch" }; // TODO pp$1.stmtToDirective = function (stmt) { var expr = stmt.expression; var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start); var directive = this.startNodeAt(stmt.start, stmt.loc.start); var raw = this.input.slice(expr.start, expr.end); var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes this.addExtra(directiveLiteral, "raw", raw); this.addExtra(directiveLiteral, "rawValue", val); directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end); return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end); }; // Parse a single statement. // // If expecting a statement and finding a slash operator, parse a // regular expression literal. This is to handle cases like // `if (foo) /blah/.exec(foo)`, where looking at the previous token // does not help. pp$1.parseStatement = function (declaration, topLevel) { if (this.match(types.at)) { this.parseDecorators(true); } var starttype = this.state.type; var node = this.startNode(); // Most types of statements are recognized by the keyword they // start with. Many are trivial to parse, some require a bit of // complexity. switch (starttype) { case types._break:case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword); case types._debugger: return this.parseDebuggerStatement(node); case types._do: return this.parseDoStatement(node); case types._for: return this.parseForStatement(node); case types._function: if (!declaration) this.unexpected(); return this.parseFunctionStatement(node); case types._class: if (!declaration) this.unexpected(); return this.parseClass(node, true); case types._if: return this.parseIfStatement(node); case types._return: return this.parseReturnStatement(node); case types._switch: return this.parseSwitchStatement(node); case types._throw: return this.parseThrowStatement(node); case types._try: return this.parseTryStatement(node); case types._let: case types._const: if (!declaration) this.unexpected(); // NOTE: falls through to _var case types._var: return this.parseVarStatement(node, starttype); case types._while: return this.parseWhileStatement(node); case types._with: return this.parseWithStatement(node); case types.braceL: return this.parseBlock(); case types.semi: return this.parseEmptyStatement(node); case types._export: case types._import: if (this.hasPlugin("dynamicImport") && this.lookahead().type === types.parenL) break; if (!this.options.allowImportExportEverywhere) { if (!topLevel) { this.raise(this.state.start, "'import' and 'export' may only appear at the top level"); } if (!this.inModule) { this.raise(this.state.start, "'import' and 'export' may appear only with 'sourceType: \"module\"'"); } } return starttype === types._import ? this.parseImport(node) : this.parseExport(node); case types.name: if (this.state.value === "async") { // peek ahead and see if next token is a function var state = this.state.clone(); this.next(); if (this.match(types._function) && !this.canInsertSemicolon()) { this.expect(types._function); return this.parseFunction(node, true, false, true); } else { this.state = state; } } } // If the statement does not start with a statement keyword or a // brace, it's an ExpressionStatement or LabeledStatement. We // simply start parsing an expression, and afterwards, if the // next token is a colon and the expression was a simple // Identifier node, we switch to interpreting it as a label. var maybeName = this.state.value; var expr = this.parseExpression(); if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) { return this.parseLabeledStatement(node, maybeName, expr); } else { return this.parseExpressionStatement(node, expr); } }; pp$1.takeDecorators = function (node) { if (this.state.decorators.length) { node.decorators = this.state.decorators; this.state.decorators = []; } }; pp$1.parseDecorators = function (allowExport) { while (this.match(types.at)) { var decorator = this.parseDecorator(); this.state.decorators.push(decorator); } if (allowExport && this.match(types._export)) { return; } if (!this.match(types._class)) { this.raise(this.state.start, "Leading decorators must be attached to a class declaration"); } }; pp$1.parseDecorator = function () { if (!this.hasPlugin("decorators")) { this.unexpected(); } var node = this.startNode(); this.next(); node.expression = this.parseMaybeAssign(); return this.finishNode(node, "Decorator"); }; pp$1.parseBreakContinueStatement = function (node, keyword) { var isBreak = keyword === "break"; this.next(); if (this.isLineTerminator()) { node.label = null; } else if (!this.match(types.name)) { this.unexpected(); } else { node.label = this.parseIdentifier(); this.semicolon(); } // Verify that there is an actual destination to break or // continue to. var i = void 0; for (i = 0; i < this.state.labels.length; ++i) { var lab = this.state.labels[i]; if (node.label == null || lab.name === node.label.name) { if (lab.kind != null && (isBreak || lab.kind === "loop")) break; if (node.label && isBreak) break; } } if (i === this.state.labels.length) this.raise(node.start, "Unsyntactic " + keyword); return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement"); }; pp$1.parseDebuggerStatement = function (node) { this.next(); this.semicolon(); return this.finishNode(node, "DebuggerStatement"); }; pp$1.parseDoStatement = function (node) { this.next(); this.state.labels.push(loopLabel); node.body = this.parseStatement(false); this.state.labels.pop(); this.expect(types._while); node.test = this.parseParenExpression(); this.eat(types.semi); return this.finishNode(node, "DoWhileStatement"); }; // Disambiguating between a `for` and a `for`/`in` or `for`/`of` // loop is non-trivial. Basically, we have to parse the init `var` // statement or expression, disallowing the `in` operator (see // the second parameter to `parseExpression`), and then check // whether the next token is `in` or `of`. When there is no init // part (semicolon immediately after the opening parenthesis), it // is a regular `for` loop. pp$1.parseForStatement = function (node) { this.next(); this.state.labels.push(loopLabel); var forAwait = false; if (this.hasPlugin("asyncGenerators") && this.state.inAsync && this.isContextual("await")) { forAwait = true; this.next(); } this.expect(types.parenL); if (this.match(types.semi)) { if (forAwait) { this.unexpected(); } return this.parseFor(node, null); } if (this.match(types._var) || this.match(types._let) || this.match(types._const)) { var _init = this.startNode(); var varKind = this.state.type; this.next(); this.parseVar(_init, true, varKind); this.finishNode(_init, "VariableDeclaration"); if (this.match(types._in) || this.isContextual("of")) { if (_init.declarations.length === 1 && !_init.declarations[0].init) { return this.parseForIn(node, _init, forAwait); } } if (forAwait) { this.unexpected(); } return this.parseFor(node, _init); } var refShorthandDefaultPos = { start: 0 }; var init = this.parseExpression(true, refShorthandDefaultPos); if (this.match(types._in) || this.isContextual("of")) { var description = this.isContextual("of") ? "for-of statement" : "for-in statement"; this.toAssignable(init, undefined, description); this.checkLVal(init, undefined, undefined, description); return this.parseForIn(node, init, forAwait); } else if (refShorthandDefaultPos.start) { this.unexpected(refShorthandDefaultPos.start); } if (forAwait) { this.unexpected(); } return this.parseFor(node, init); }; pp$1.parseFunctionStatement = function (node) { this.next(); return this.parseFunction(node, true); }; pp$1.parseIfStatement = function (node) { this.next(); node.test = this.parseParenExpression(); node.consequent = this.parseStatement(false); node.alternate = this.eat(types._else) ? this.parseStatement(false) : null; return this.finishNode(node, "IfStatement"); }; pp$1.parseReturnStatement = function (node) { if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) { this.raise(this.state.start, "'return' outside of function"); } this.next(); // In `return` (and `break`/`continue`), the keywords with // optional arguments, we eagerly look for a semicolon or the // possibility to insert one. if (this.isLineTerminator()) { node.argument = null; } else { node.argument = this.parseExpression(); this.semicolon(); } return this.finishNode(node, "ReturnStatement"); }; pp$1.parseSwitchStatement = function (node) { this.next(); node.discriminant = this.parseParenExpression(); node.cases = []; this.expect(types.braceL); this.state.labels.push(switchLabel); // Statements under must be grouped (by label) in SwitchCase // nodes. `cur` is used to keep the node that we are currently // adding statements to. var cur = void 0; for (var sawDefault; !this.match(types.braceR);) { if (this.match(types._case) || this.match(types._default)) { var isCase = this.match(types._case); if (cur) this.finishNode(cur, "SwitchCase"); node.cases.push(cur = this.startNode()); cur.consequent = []; this.next(); if (isCase) { cur.test = this.parseExpression(); } else { if (sawDefault) this.raise(this.state.lastTokStart, "Multiple default clauses"); sawDefault = true; cur.test = null; } this.expect(types.colon); } else { if (cur) { cur.consequent.push(this.parseStatement(true)); } else { this.unexpected(); } } } if (cur) this.finishNode(cur, "SwitchCase"); this.next(); // Closing brace this.state.labels.pop(); return this.finishNode(node, "SwitchStatement"); }; pp$1.parseThrowStatement = function (node) { this.next(); if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, "Illegal newline after throw"); node.argument = this.parseExpression(); this.semicolon(); return this.finishNode(node, "ThrowStatement"); }; // Reused empty array added for node fields that are always empty. var empty = []; pp$1.parseTryStatement = function (node) { this.next(); node.block = this.parseBlock(); node.handler = null; if (this.match(types._catch)) { var clause = this.startNode(); this.next(); this.expect(types.parenL); clause.param = this.parseBindingAtom(); this.checkLVal(clause.param, true, Object.create(null), "catch clause"); this.expect(types.parenR); clause.body = this.parseBlock(); node.handler = this.finishNode(clause, "CatchClause"); } node.guardedHandlers = empty; node.finalizer = this.eat(types._finally) ? this.parseBlock() : null; if (!node.handler && !node.finalizer) { this.raise(node.start, "Missing catch or finally clause"); } return this.finishNode(node, "TryStatement"); }; pp$1.parseVarStatement = function (node, kind) { this.next(); this.parseVar(node, false, kind); this.semicolon(); return this.finishNode(node, "VariableDeclaration"); }; pp$1.parseWhileStatement = function (node) { this.next(); node.test = this.parseParenExpression(); this.state.labels.push(loopLabel); node.body = this.parseStatement(false); this.state.labels.pop(); return this.finishNode(node, "WhileStatement"); }; pp$1.parseWithStatement = function (node) { if (this.state.strict) this.raise(this.state.start, "'with' in strict mode"); this.next(); node.object = this.parseParenExpression(); node.body = this.parseStatement(false); return this.finishNode(node, "WithStatement"); }; pp$1.parseEmptyStatement = function (node) { this.next(); return this.finishNode(node, "EmptyStatement"); }; pp$1.parseLabeledStatement = function (node, maybeName, expr) { for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var _label = _ref; if (_label.name === maybeName) { this.raise(expr.start, "Label '" + maybeName + "' is already declared"); } } var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null; for (var i = this.state.labels.length - 1; i >= 0; i--) { var label = this.state.labels[i]; if (label.statementStart === node.start) { label.statementStart = this.state.start; label.kind = kind; } else { break; } } this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start }); node.body = this.parseStatement(true); this.state.labels.pop(); node.label = expr; return this.finishNode(node, "LabeledStatement"); }; pp$1.parseExpressionStatement = function (node, expr) { node.expression = expr; this.semicolon(); return this.finishNode(node, "ExpressionStatement"); }; // Parse a semicolon-enclosed block of statements, handling `"use // strict"` declarations when `allowStrict` is true (used for // function bodies). pp$1.parseBlock = function (allowDirectives) { var node = this.startNode(); this.expect(types.braceL); this.parseBlockBody(node, allowDirectives, false, types.braceR); return this.finishNode(node, "BlockStatement"); }; pp$1.isValidDirective = function (stmt) { return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized; }; pp$1.parseBlockBody = function (node, allowDirectives, topLevel, end) { node.body = []; node.directives = []; var parsedNonDirective = false; var oldStrict = void 0; var octalPosition = void 0; while (!this.eat(end)) { if (!parsedNonDirective && this.state.containsOctal && !octalPosition) { octalPosition = this.state.octalPosition; } var stmt = this.parseStatement(true, topLevel); if (allowDirectives && !parsedNonDirective && this.isValidDirective(stmt)) { var directive = this.stmtToDirective(stmt); node.directives.push(directive); if (oldStrict === undefined && directive.value.value === "use strict") { oldStrict = this.state.strict; this.setStrict(true); if (octalPosition) { this.raise(octalPosition, "Octal literal in strict mode"); } } continue; } parsedNonDirective = true; node.body.push(stmt); } if (oldStrict === false) { this.setStrict(false); } }; // Parse a regular `for` loop. The disambiguation code in // `parseStatement` will already have parsed the init statement or // expression. pp$1.parseFor = function (node, init) { node.init = init; this.expect(types.semi); node.test = this.match(types.semi) ? null : this.parseExpression(); this.expect(types.semi); node.update = this.match(types.parenR) ? null : this.parseExpression(); this.expect(types.parenR); node.body = this.parseStatement(false); this.state.labels.pop(); return this.finishNode(node, "ForStatement"); }; // Parse a `for`/`in` and `for`/`of` loop, which are almost // same from parser's perspective. pp$1.parseForIn = function (node, init, forAwait) { var type = void 0; if (forAwait) { this.eatContextual("of"); type = "ForAwaitStatement"; } else { type = this.match(types._in) ? "ForInStatement" : "ForOfStatement"; this.next(); } node.left = init; node.right = this.parseExpression(); this.expect(types.parenR); node.body = this.parseStatement(false); this.state.labels.pop(); return this.finishNode(node, type); }; // Parse a list of variable declarations. pp$1.parseVar = function (node, isFor, kind) { node.declarations = []; node.kind = kind.keyword; for (;;) { var decl = this.startNode(); this.parseVarHead(decl); if (this.eat(types.eq)) { decl.init = this.parseMaybeAssign(isFor); } else if (kind === types._const && !(this.match(types._in) || this.isContextual("of"))) { this.unexpected(); } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) { this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value"); } else { decl.init = null; } node.declarations.push(this.finishNode(decl, "VariableDeclarator")); if (!this.eat(types.comma)) break; } return node; }; pp$1.parseVarHead = function (decl) { decl.id = this.parseBindingAtom(); this.checkLVal(decl.id, true, undefined, "variable declaration"); }; // Parse a function declaration or literal (depending on the // `isStatement` parameter). pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) { var oldInMethod = this.state.inMethod; this.state.inMethod = false; this.initFunction(node, isAsync); if (this.match(types.star)) { if (node.async && !this.hasPlugin("asyncGenerators")) { this.unexpected(); } else { node.generator = true; this.next(); } } if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) { this.unexpected(); } if (this.match(types.name) || this.match(types._yield)) { node.id = this.parseBindingIdentifier(); } this.parseFunctionParams(node); this.parseFunctionBody(node, allowExpressionBody); this.state.inMethod = oldInMethod; return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression"); }; pp$1.parseFunctionParams = function (node) { this.expect(types.parenL); node.params = this.parseBindingList(types.parenR); }; // Parse a class declaration or literal (depending on the // `isStatement` parameter). pp$1.parseClass = function (node, isStatement, optionalId) { this.next(); this.takeDecorators(node); this.parseClassId(node, isStatement, optionalId); this.parseClassSuper(node); this.parseClassBody(node); return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression"); }; pp$1.isClassProperty = function () { return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR); }; pp$1.isClassMethod = function () { return this.match(types.parenL); }; pp$1.isNonstaticConstructor = function (method) { return !method.computed && !method.static && (method.key.name === "constructor" || // Identifier method.key.value === "constructor" // Literal ); }; pp$1.parseClassBody = function (node) { // class bodies are implicitly strict var oldStrict = this.state.strict; this.state.strict = true; var hadConstructorCall = false; var hadConstructor = false; var decorators = []; var classBody = this.startNode(); classBody.body = []; this.expect(types.braceL); while (!this.eat(types.braceR)) { if (this.eat(types.semi)) { if (decorators.length > 0) { this.raise(this.state.lastTokEnd, "Decorators must not be followed by a semicolon"); } continue; } if (this.match(types.at)) { decorators.push(this.parseDecorator()); continue; } var method = this.startNode(); // steal the decorators if there are any if (decorators.length) { method.decorators = decorators; decorators = []; } method.static = false; if (this.match(types.name) && this.state.value === "static") { var key = this.parseIdentifier(true); // eats 'static' if (this.isClassMethod()) { // a method named 'static' method.kind = "method"; method.computed = false; method.key = key; this.parseClassMethod(classBody, method, false, false); continue; } else if (this.isClassProperty()) { // a property named 'static' method.computed = false; method.key = key; classBody.body.push(this.parseClassProperty(method)); continue; } // otherwise something static method.static = true; } if (this.eat(types.star)) { // a generator method.kind = "method"; this.parsePropertyName(method); if (this.isNonstaticConstructor(method)) { this.raise(method.key.start, "Constructor can't be a generator"); } if (!method.computed && method.static && (method.key.name === "prototype" || method.key.value === "prototype")) { this.raise(method.key.start, "Classes may not have static property named prototype"); } this.parseClassMethod(classBody, method, true, false); } else { var isSimple = this.match(types.name); var _key = this.parsePropertyName(method); if (!method.computed && method.static && (method.key.name === "prototype" || method.key.value === "prototype")) { this.raise(method.key.start, "Classes may not have static property named prototype"); } if (this.isClassMethod()) { // a normal method if (this.isNonstaticConstructor(method)) { if (hadConstructor) { this.raise(_key.start, "Duplicate constructor in the same class"); } else if (method.decorators) { this.raise(method.start, "You can't attach decorators to a class constructor"); } hadConstructor = true; method.kind = "constructor"; } else { method.kind = "method"; } this.parseClassMethod(classBody, method, false, false); } else if (this.isClassProperty()) { // a normal property if (this.isNonstaticConstructor(method)) { this.raise(method.key.start, "Classes may not have a non-static field named 'constructor'"); } classBody.body.push(this.parseClassProperty(method)); } else if (isSimple && _key.name === "async" && !this.isLineTerminator()) { // an async method var isGenerator = this.hasPlugin("asyncGenerators") && this.eat(types.star); method.kind = "method"; this.parsePropertyName(method); if (this.isNonstaticConstructor(method)) { this.raise(method.key.start, "Constructor can't be an async function"); } this.parseClassMethod(classBody, method, isGenerator, true); } else if (isSimple && (_key.name === "get" || _key.name === "set") && !(this.isLineTerminator() && this.match(types.star))) { // `get\n*` is an uninitialized property named 'get' followed by a generator. // a getter or setter method.kind = _key.name; this.parsePropertyName(method); if (this.isNonstaticConstructor(method)) { this.raise(method.key.start, "Constructor can't have get/set modifier"); } this.parseClassMethod(classBody, method, false, false); this.checkGetterSetterParamCount(method); } else if (this.hasPlugin("classConstructorCall") && isSimple && _key.name === "call" && this.match(types.name) && this.state.value === "constructor") { // a (deprecated) call constructor if (hadConstructorCall) { this.raise(method.start, "Duplicate constructor call in the same class"); } else if (method.decorators) { this.raise(method.start, "You can't attach decorators to a class constructor"); } hadConstructorCall = true; method.kind = "constructorCall"; this.parsePropertyName(method); // consume "constructor" and make it the method's name this.parseClassMethod(classBody, method, false, false); } else if (this.isLineTerminator()) { // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token) if (this.isNonstaticConstructor(method)) { this.raise(method.key.start, "Classes may not have a non-static field named 'constructor'"); } classBody.body.push(this.parseClassProperty(method)); } else { this.unexpected(); } } } if (decorators.length) { this.raise(this.state.start, "You have trailing decorators with no method"); } node.body = this.finishNode(classBody, "ClassBody"); this.state.strict = oldStrict; }; pp$1.parseClassProperty = function (node) { this.state.inClassProperty = true; if (this.match(types.eq)) { if (!this.hasPlugin("classProperties")) this.unexpected(); this.next(); node.value = this.parseMaybeAssign(); } else { node.value = null; } this.semicolon(); this.state.inClassProperty = false; return this.finishNode(node, "ClassProperty"); }; pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) { this.parseMethod(method, isGenerator, isAsync); classBody.body.push(this.finishNode(method, "ClassMethod")); }; pp$1.parseClassId = function (node, isStatement, optionalId) { if (this.match(types.name)) { node.id = this.parseIdentifier(); } else { if (optionalId || !isStatement) { node.id = null; } else { this.unexpected(); } } }; pp$1.parseClassSuper = function (node) { node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null; }; // Parses module export declaration. pp$1.parseExport = function (node) { this.next(); // export * from '...' if (this.match(types.star)) { var specifier = this.startNode(); this.next(); if (this.hasPlugin("exportExtensions") && this.eatContextual("as")) { specifier.exported = this.parseIdentifier(); node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")]; this.parseExportSpecifiersMaybe(node); this.parseExportFrom(node, true); } else { this.parseExportFrom(node, true); return this.finishNode(node, "ExportAllDeclaration"); } } else if (this.hasPlugin("exportExtensions") && this.isExportDefaultSpecifier()) { var _specifier = this.startNode(); _specifier.exported = this.parseIdentifier(true); node.specifiers = [this.finishNode(_specifier, "ExportDefaultSpecifier")]; if (this.match(types.comma) && this.lookahead().type === types.star) { this.expect(types.comma); var _specifier2 = this.startNode(); this.expect(types.star); this.expectContextual("as"); _specifier2.exported = this.parseIdentifier(); node.specifiers.push(this.finishNode(_specifier2, "ExportNamespaceSpecifier")); } else { this.parseExportSpecifiersMaybe(node); } this.parseExportFrom(node, true); } else if (this.eat(types._default)) { // export default ... var expr = this.startNode(); var needsSemi = false; if (this.eat(types._function)) { expr = this.parseFunction(expr, true, false, false, true); } else if (this.match(types._class)) { expr = this.parseClass(expr, true, true); } else { needsSemi = true; expr = this.parseMaybeAssign(); } node.declaration = expr; if (needsSemi) this.semicolon(); this.checkExport(node, true, true); return this.finishNode(node, "ExportDefaultDeclaration"); } else if (this.shouldParseExportDeclaration()) { node.specifiers = []; node.source = null; node.declaration = this.parseExportDeclaration(node); } else { // export { x, y as z } [from '...'] node.declaration = null; node.specifiers = this.parseExportSpecifiers(); this.parseExportFrom(node); } this.checkExport(node, true); return this.finishNode(node, "ExportNamedDeclaration"); }; pp$1.parseExportDeclaration = function () { return this.parseStatement(true); }; pp$1.isExportDefaultSpecifier = function () { if (this.match(types.name)) { return this.state.value !== "async"; } if (!this.match(types._default)) { return false; } var lookahead = this.lookahead(); return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === "from"; }; pp$1.parseExportSpecifiersMaybe = function (node) { if (this.eat(types.comma)) { node.specifiers = node.specifiers.concat(this.parseExportSpecifiers()); } }; pp$1.parseExportFrom = function (node, expect) { if (this.eatContextual("from")) { node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected(); this.checkExport(node); } else { if (expect) { this.unexpected(); } else { node.source = null; } } this.semicolon(); }; pp$1.shouldParseExportDeclaration = function () { return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "let" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isContextual("async"); }; pp$1.checkExport = function (node, checkNames, isDefault) { if (checkNames) { // Check for duplicate exports if (isDefault) { // Default exports this.checkDuplicateExports(node, "default"); } else if (node.specifiers && node.specifiers.length) { // Named exports for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var specifier = _ref2; this.checkDuplicateExports(specifier, specifier.exported.name); } } else if (node.declaration) { // Exported declarations if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") { this.checkDuplicateExports(node, node.declaration.id.name); } else if (node.declaration.type === "VariableDeclaration") { for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) { var _ref3; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref3 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref3 = _i3.value; } var declaration = _ref3; this.checkDeclaration(declaration.id); } } } } if (this.state.decorators.length) { var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression"); if (!node.declaration || !isClass) { this.raise(node.start, "You can only use decorators on an export when exporting a class"); } this.takeDecorators(node.declaration); } }; pp$1.checkDeclaration = function (node) { if (node.type === "ObjectPattern") { for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) { var _ref4; if (_isArray4) { if (_i4 >= _iterator4.length) break; _ref4 = _iterator4[_i4++]; } else { _i4 = _iterator4.next(); if (_i4.done) break; _ref4 = _i4.value; } var prop = _ref4; this.checkDeclaration(prop); } } else if (node.type === "ArrayPattern") { for (var _iterator5 = node.elements, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) { var _ref5; if (_isArray5) { if (_i5 >= _iterator5.length) break; _ref5 = _iterator5[_i5++]; } else { _i5 = _iterator5.next(); if (_i5.done) break; _ref5 = _i5.value; } var elem = _ref5; if (elem) { this.checkDeclaration(elem); } } } else if (node.type === "ObjectProperty") { this.checkDeclaration(node.value); } else if (node.type === "RestElement" || node.type === "RestProperty") { this.checkDeclaration(node.argument); } else if (node.type === "Identifier") { this.checkDuplicateExports(node, node.name); } }; pp$1.checkDuplicateExports = function (node, name) { if (this.state.exportedIdentifiers.indexOf(name) > -1) { this.raiseDuplicateExportError(node, name); } this.state.exportedIdentifiers.push(name); }; pp$1.raiseDuplicateExportError = function (node, name) { this.raise(node.start, name === "default" ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique."); }; // Parses a comma-separated list of module exports. pp$1.parseExportSpecifiers = function () { var nodes = []; var first = true; var needsFrom = void 0; // export { x, y as z } [from '...'] this.expect(types.braceL); while (!this.eat(types.braceR)) { if (first) { first = false; } else { this.expect(types.comma); if (this.eat(types.braceR)) break; } var isDefault = this.match(types._default); if (isDefault && !needsFrom) needsFrom = true; var node = this.startNode(); node.local = this.parseIdentifier(isDefault); node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone(); nodes.push(this.finishNode(node, "ExportSpecifier")); } // https://github.com/ember-cli/ember-cli/pull/3739 if (needsFrom && !this.isContextual("from")) { this.unexpected(); } return nodes; }; // Parses import declaration. pp$1.parseImport = function (node) { this.eat(types._import); // import '...' if (this.match(types.string)) { node.specifiers = []; node.source = this.parseExprAtom(); } else { node.specifiers = []; this.parseImportSpecifiers(node); this.expectContextual("from"); node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected(); } this.semicolon(); return this.finishNode(node, "ImportDeclaration"); }; // Parses a comma-separated list of module imports. pp$1.parseImportSpecifiers = function (node) { var first = true; if (this.match(types.name)) { // import defaultObj, { x, y as z } from '...' var startPos = this.state.start; var startLoc = this.state.startLoc; node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc)); if (!this.eat(types.comma)) return; } if (this.match(types.star)) { var specifier = this.startNode(); this.next(); this.expectContextual("as"); specifier.local = this.parseIdentifier(); this.checkLVal(specifier.local, true, undefined, "import namespace specifier"); node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier")); return; } this.expect(types.braceL); while (!this.eat(types.braceR)) { if (first) { first = false; } else { // Detect an attempt to deep destructure if (this.eat(types.colon)) { this.unexpected(null, "ES2015 named imports do not destructure. Use another statement for destructuring after the import."); } this.expect(types.comma); if (this.eat(types.braceR)) break; } this.parseImportSpecifier(node); } }; pp$1.parseImportSpecifier = function (node) { var specifier = this.startNode(); specifier.imported = this.parseIdentifier(true); if (this.eatContextual("as")) { specifier.local = this.parseIdentifier(); } else { this.checkReservedWord(specifier.imported.name, specifier.start, true, true); specifier.local = specifier.imported.__clone(); } this.checkLVal(specifier.local, true, undefined, "import specifier"); node.specifiers.push(this.finishNode(specifier, "ImportSpecifier")); }; pp$1.parseImportSpecifierDefault = function (id, startPos, startLoc) { var node = this.startNodeAt(startPos, startLoc); node.local = id; this.checkLVal(node.local, true, undefined, "default import specifier"); return this.finishNode(node, "ImportDefaultSpecifier"); }; var pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern // if possible. pp$2.toAssignable = function (node, isBinding, contextDescription) { if (node) { switch (node.type) { case "Identifier": case "ObjectPattern": case "ArrayPattern": case "AssignmentPattern": break; case "ObjectExpression": node.type = "ObjectPattern"; for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var prop = _ref; if (prop.type === "ObjectMethod") { if (prop.kind === "get" || prop.kind === "set") { this.raise(prop.key.start, "Object pattern can't contain getter or setter"); } else { this.raise(prop.key.start, "Object pattern can't contain methods"); } } else { this.toAssignable(prop, isBinding, "object destructuring pattern"); } } break; case "ObjectProperty": this.toAssignable(node.value, isBinding, contextDescription); break; case "SpreadProperty": node.type = "RestProperty"; var arg = node.argument; this.toAssignable(arg, isBinding, contextDescription); break; case "ArrayExpression": node.type = "ArrayPattern"; this.toAssignableList(node.elements, isBinding, contextDescription); break; case "AssignmentExpression": if (node.operator === "=") { node.type = "AssignmentPattern"; delete node.operator; } else { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); } break; case "MemberExpression": if (!isBinding) break; default: { var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression"); this.raise(node.start, message); } } } return node; }; // Convert list of expression atoms to binding list. pp$2.toAssignableList = function (exprList, isBinding, contextDescription) { var end = exprList.length; if (end) { var last = exprList[end - 1]; if (last && last.type === "RestElement") { --end; } else if (last && last.type === "SpreadElement") { last.type = "RestElement"; var arg = last.argument; this.toAssignable(arg, isBinding, contextDescription); if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") { this.unexpected(arg.start); } --end; } } for (var i = 0; i < end; i++) { var elt = exprList[i]; if (elt) this.toAssignable(elt, isBinding, contextDescription); } return exprList; }; // Convert list of expression atoms to a list of pp$2.toReferencedList = function (exprList) { return exprList; }; // Parses spread element. pp$2.parseSpread = function (refShorthandDefaultPos) { var node = this.startNode(); this.next(); node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos); return this.finishNode(node, "SpreadElement"); }; pp$2.parseRest = function () { var node = this.startNode(); this.next(); node.argument = this.parseBindingIdentifier(); return this.finishNode(node, "RestElement"); }; pp$2.shouldAllowYieldIdentifier = function () { return this.match(types._yield) && !this.state.strict && !this.state.inGenerator; }; pp$2.parseBindingIdentifier = function () { return this.parseIdentifier(this.shouldAllowYieldIdentifier()); }; // Parses lvalue (assignable) atom. pp$2.parseBindingAtom = function () { switch (this.state.type) { case types._yield: if (this.state.strict || this.state.inGenerator) this.unexpected(); // fall-through case types.name: return this.parseIdentifier(true); case types.bracketL: var node = this.startNode(); this.next(); node.elements = this.parseBindingList(types.bracketR, true); return this.finishNode(node, "ArrayPattern"); case types.braceL: return this.parseObj(true); default: this.unexpected(); } }; pp$2.parseBindingList = function (close, allowEmpty) { var elts = []; var first = true; while (!this.eat(close)) { if (first) { first = false; } else { this.expect(types.comma); } if (allowEmpty && this.match(types.comma)) { elts.push(null); } else if (this.eat(close)) { break; } else if (this.match(types.ellipsis)) { elts.push(this.parseAssignableListItemTypes(this.parseRest())); this.expect(close); break; } else { var decorators = []; while (this.match(types.at)) { decorators.push(this.parseDecorator()); } var left = this.parseMaybeDefault(); if (decorators.length) { left.decorators = decorators; } this.parseAssignableListItemTypes(left); elts.push(this.parseMaybeDefault(left.start, left.loc.start, left)); } } return elts; }; pp$2.parseAssignableListItemTypes = function (param) { return param; }; // Parses assignment pattern around given atom if possible. pp$2.parseMaybeDefault = function (startPos, startLoc, left) { startLoc = startLoc || this.state.startLoc; startPos = startPos || this.state.start; left = left || this.parseBindingAtom(); if (!this.eat(types.eq)) return left; var node = this.startNodeAt(startPos, startLoc); node.left = left; node.right = this.parseMaybeAssign(); return this.finishNode(node, "AssignmentPattern"); }; // Verify that a node is an lval — something that can be assigned // to. pp$2.checkLVal = function (expr, isBinding, checkClashes, contextDescription) { switch (expr.type) { case "Identifier": this.checkReservedWord(expr.name, expr.start, false, true); if (checkClashes) { // we need to prefix this with an underscore for the cases where we have a key of // `__proto__`. there's a bug in old V8 where the following wouldn't work: // // > var obj = Object.create(null); // undefined // > obj.__proto__ // null // > obj.__proto__ = true; // true // > obj.__proto__ // null var key = "_" + expr.name; if (checkClashes[key]) { this.raise(expr.start, "Argument name clash in strict mode"); } else { checkClashes[key] = true; } } break; case "MemberExpression": if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression"); break; case "ObjectPattern": for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var prop = _ref2; if (prop.type === "ObjectProperty") prop = prop.value; this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern"); } break; case "ArrayPattern": for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) { var _ref3; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref3 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref3 = _i3.value; } var elem = _ref3; if (elem) this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern"); } break; case "AssignmentPattern": this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern"); break; case "RestProperty": this.checkLVal(expr.argument, isBinding, checkClashes, "rest property"); break; case "RestElement": this.checkLVal(expr.argument, isBinding, checkClashes, "rest element"); break; default: { var message = (isBinding ? /* istanbul ignore next */"Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression"); this.raise(expr.start, message); } } }; /* eslint max-len: 0 */ // A recursive descent parser operates by defining functions for all // syntactic elements, and recursively calling those, each function // advancing the input stream and returning an AST node. Precedence // of constructs (for example, the fact that `!x[1]` means `!(x[1])` // instead of `(!x)[1]` is handled by the fact that the parser // function that parses unary prefix operators is called first, and // in turn calls the function that parses `[]` subscripts — that // way, it'll receive the node for `x[1]` already parsed, and wraps // *that* in the unary operator node. // // Acorn uses an [operator precedence parser][opp] to handle binary // operator precedence, because it is much more compact than using // the technique outlined above, which uses different, nesting // functions to specify precedence, for all of the ten binary // precedence levels that JavaScript defines. // // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser var pp$3 = Parser.prototype; // Check if property name clashes with already added. // Object/class getters and setters are not allowed to clash — // either with each other or with an init property — and in // strict mode, init properties are also not allowed to be repeated. pp$3.checkPropClash = function (prop, propHash) { if (prop.computed || prop.kind) return; var key = prop.key; // It is either an Identifier or a String/NumericLiteral var name = key.type === "Identifier" ? key.name : String(key.value); if (name === "__proto__") { if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property"); propHash.proto = true; } }; // Convenience method to parse an Expression only pp$3.getExpression = function () { this.nextToken(); var expr = this.parseExpression(); if (!this.match(types.eof)) { this.unexpected(); } return expr; }; // ### Expression parsing // These nest, from the most general expression type at the top to // 'atomic', nondivisible expression types at the bottom. Most of // the functions will simply let the function (s) below them parse, // and, *if* the syntactic construct they handle is present, wrap // the AST node that the inner parser gave them in another node. // Parse a full expression. The optional arguments are used to // forbid the `in` operator (in for loops initialization expressions) // and provide reference for storing '=' operator inside shorthand // property assignment in contexts where both object expression // and object pattern might appear (so it's possible to raise // delayed syntax error at correct position). pp$3.parseExpression = function (noIn, refShorthandDefaultPos) { var startPos = this.state.start; var startLoc = this.state.startLoc; var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos); if (this.match(types.comma)) { var node = this.startNodeAt(startPos, startLoc); node.expressions = [expr]; while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos)); } this.toReferencedList(node.expressions); return this.finishNode(node, "SequenceExpression"); } return expr; }; // Parse an assignment expression. This includes applications of // operators like `+=`. pp$3.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) { var startPos = this.state.start; var startLoc = this.state.startLoc; if (this.match(types._yield) && this.state.inGenerator) { var _left = this.parseYield(); if (afterLeftParse) _left = afterLeftParse.call(this, _left, startPos, startLoc); return _left; } var failOnShorthandAssign = void 0; if (refShorthandDefaultPos) { failOnShorthandAssign = false; } else { refShorthandDefaultPos = { start: 0 }; failOnShorthandAssign = true; } if (this.match(types.parenL) || this.match(types.name)) { this.state.potentialArrowAt = this.state.start; } var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos); if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc); if (this.state.type.isAssign) { var node = this.startNodeAt(startPos, startLoc); node.operator = this.state.value; node.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left; refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly this.checkLVal(left, undefined, undefined, "assignment expression"); if (left.extra && left.extra.parenthesized) { var errorMsg = void 0; if (left.type === "ObjectPattern") { errorMsg = "`({a}) = 0` use `({a} = 0)`"; } else if (left.type === "ArrayPattern") { errorMsg = "`([a]) = 0` use `([a] = 0)`"; } if (errorMsg) { this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg); } } this.next(); node.right = this.parseMaybeAssign(noIn); return this.finishNode(node, "AssignmentExpression"); } else if (failOnShorthandAssign && refShorthandDefaultPos.start) { this.unexpected(refShorthandDefaultPos.start); } return left; }; // Parse a ternary conditional (`?:`) operator. pp$3.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) { var startPos = this.state.start; var startLoc = this.state.startLoc; var expr = this.parseExprOps(noIn, refShorthandDefaultPos); if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr; return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos); }; pp$3.parseConditional = function (expr, noIn, startPos, startLoc) { if (this.eat(types.question)) { var node = this.startNodeAt(startPos, startLoc); node.test = expr; node.consequent = this.parseMaybeAssign(); this.expect(types.colon); node.alternate = this.parseMaybeAssign(noIn); return this.finishNode(node, "ConditionalExpression"); } return expr; }; // Start the precedence parser. pp$3.parseExprOps = function (noIn, refShorthandDefaultPos) { var startPos = this.state.start; var startLoc = this.state.startLoc; var expr = this.parseMaybeUnary(refShorthandDefaultPos); if (refShorthandDefaultPos && refShorthandDefaultPos.start) { return expr; } else { return this.parseExprOp(expr, startPos, startLoc, -1, noIn); } }; // Parse binary operators with the operator precedence parsing // algorithm. `left` is the left-hand side of the operator. // `minPrec` provides context that allows the function to stop and // defer further parser to one of its callers when it encounters an // operator that has a lower precedence than the set it is parsing. pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) { var prec = this.state.type.binop; if (prec != null && (!noIn || !this.match(types._in))) { if (prec > minPrec) { var node = this.startNodeAt(leftStartPos, leftStartLoc); node.left = left; node.operator = this.state.value; if (node.operator === "**" && left.type === "UnaryExpression" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) { this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses."); } var op = this.state.type; this.next(); var startPos = this.state.start; var startLoc = this.state.startLoc; node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn); this.finishNode(node, op === types.logicalOR || op === types.logicalAND ? "LogicalExpression" : "BinaryExpression"); return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn); } } return left; }; // Parse unary operators, both prefix and postfix. pp$3.parseMaybeUnary = function (refShorthandDefaultPos) { if (this.state.type.prefix) { var node = this.startNode(); var update = this.match(types.incDec); node.operator = this.state.value; node.prefix = true; this.next(); var argType = this.state.type; node.argument = this.parseMaybeUnary(); this.addExtra(node, "parenthesizedArgument", argType === types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized)); if (refShorthandDefaultPos && refShorthandDefaultPos.start) { this.unexpected(refShorthandDefaultPos.start); } if (update) { this.checkLVal(node.argument, undefined, undefined, "prefix operation"); } else if (this.state.strict && node.operator === "delete" && node.argument.type === "Identifier") { this.raise(node.start, "Deleting local variable in strict mode"); } return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression"); } var startPos = this.state.start; var startLoc = this.state.startLoc; var expr = this.parseExprSubscripts(refShorthandDefaultPos); if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr; while (this.state.type.postfix && !this.canInsertSemicolon()) { var _node = this.startNodeAt(startPos, startLoc); _node.operator = this.state.value; _node.prefix = false; _node.argument = expr; this.checkLVal(expr, undefined, undefined, "postfix operation"); this.next(); expr = this.finishNode(_node, "UpdateExpression"); } return expr; }; // Parse call, dot, and `[]`-subscript expressions. pp$3.parseExprSubscripts = function (refShorthandDefaultPos) { var startPos = this.state.start; var startLoc = this.state.startLoc; var potentialArrowAt = this.state.potentialArrowAt; var expr = this.parseExprAtom(refShorthandDefaultPos); if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) { return expr; } if (refShorthandDefaultPos && refShorthandDefaultPos.start) { return expr; } return this.parseSubscripts(expr, startPos, startLoc); }; pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) { for (;;) { if (!noCalls && this.eat(types.doubleColon)) { var node = this.startNodeAt(startPos, startLoc); node.object = base; node.callee = this.parseNoCallExpr(); return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls); } else if (this.eat(types.dot)) { var _node2 = this.startNodeAt(startPos, startLoc); _node2.object = base; _node2.property = this.parseIdentifier(true); _node2.computed = false; base = this.finishNode(_node2, "MemberExpression"); } else if (this.eat(types.bracketL)) { var _node3 = this.startNodeAt(startPos, startLoc); _node3.object = base; _node3.property = this.parseExpression(); _node3.computed = true; this.expect(types.bracketR); base = this.finishNode(_node3, "MemberExpression"); } else if (!noCalls && this.match(types.parenL)) { var possibleAsync = this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon(); this.next(); var _node4 = this.startNodeAt(startPos, startLoc); _node4.callee = base; _node4.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync); if (_node4.callee.type === "Import" && _node4.arguments.length !== 1) { this.raise(_node4.start, "import() requires exactly one argument"); } base = this.finishNode(_node4, "CallExpression"); if (possibleAsync && this.shouldParseAsyncArrow()) { return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4); } else { this.toReferencedList(_node4.arguments); } } else if (this.match(types.backQuote)) { var _node5 = this.startNodeAt(startPos, startLoc); _node5.tag = base; _node5.quasi = this.parseTemplate(true); base = this.finishNode(_node5, "TaggedTemplateExpression"); } else { return base; } } }; pp$3.parseCallExpressionArguments = function (close, possibleAsyncArrow) { var elts = []; var innerParenStart = void 0; var first = true; while (!this.eat(close)) { if (first) { first = false; } else { this.expect(types.comma); if (this.eat(close)) break; } // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params if (this.match(types.parenL) && !innerParenStart) { innerParenStart = this.state.start; } elts.push(this.parseExprListItem(false, possibleAsyncArrow ? { start: 0 } : undefined, possibleAsyncArrow ? { start: 0 } : undefined)); } // we found an async arrow function so let's not allow any inner parens if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) { this.unexpected(); } return elts; }; pp$3.shouldParseAsyncArrow = function () { return this.match(types.arrow); }; pp$3.parseAsyncArrowFromCallExpression = function (node, call) { this.expect(types.arrow); return this.parseArrowExpression(node, call.arguments, true); }; // Parse a no-call expression (like argument of `new` or `::` operators). pp$3.parseNoCallExpr = function () { var startPos = this.state.start; var startLoc = this.state.startLoc; return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true); }; // Parse an atomic expression — either a single token that is an // expression, an expression started by a keyword like `function` or // `new`, or an expression wrapped in punctuation like `()`, `[]`, // or `{}`. pp$3.parseExprAtom = function (refShorthandDefaultPos) { var canBeArrow = this.state.potentialArrowAt === this.state.start; var node = void 0; switch (this.state.type) { case types._super: if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) { this.raise(this.state.start, "'super' outside of function or class"); } node = this.startNode(); this.next(); if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) { this.unexpected(); } if (this.match(types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) { this.raise(node.start, "super() outside of class constructor"); } return this.finishNode(node, "Super"); case types._import: if (!this.hasPlugin("dynamicImport")) this.unexpected(); node = this.startNode(); this.next(); if (!this.match(types.parenL)) { this.unexpected(null, types.parenL); } return this.finishNode(node, "Import"); case types._this: node = this.startNode(); this.next(); return this.finishNode(node, "ThisExpression"); case types._yield: if (this.state.inGenerator) this.unexpected(); case types.name: node = this.startNode(); var allowAwait = this.state.value === "await" && this.state.inAsync; var allowYield = this.shouldAllowYieldIdentifier(); var id = this.parseIdentifier(allowAwait || allowYield); if (id.name === "await") { if (this.state.inAsync || this.inModule) { return this.parseAwait(node); } } else if (id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) { this.next(); return this.parseFunction(node, false, false, true); } else if (canBeArrow && id.name === "async" && this.match(types.name)) { var params = [this.parseIdentifier()]; this.expect(types.arrow); // let foo = bar => {}; return this.parseArrowExpression(node, params, true); } if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) { return this.parseArrowExpression(node, [id]); } return id; case types._do: if (this.hasPlugin("doExpressions")) { var _node6 = this.startNode(); this.next(); var oldInFunction = this.state.inFunction; var oldLabels = this.state.labels; this.state.labels = []; this.state.inFunction = false; _node6.body = this.parseBlock(false, true); this.state.inFunction = oldInFunction; this.state.labels = oldLabels; return this.finishNode(_node6, "DoExpression"); } case types.regexp: var value = this.state.value; node = this.parseLiteral(value.value, "RegExpLiteral"); node.pattern = value.pattern; node.flags = value.flags; return node; case types.num: return this.parseLiteral(this.state.value, "NumericLiteral"); case types.string: return this.parseLiteral(this.state.value, "StringLiteral"); case types._null: node = this.startNode(); this.next(); return this.finishNode(node, "NullLiteral"); case types._true:case types._false: node = this.startNode(); node.value = this.match(types._true); this.next(); return this.finishNode(node, "BooleanLiteral"); case types.parenL: return this.parseParenAndDistinguishExpression(null, null, canBeArrow); case types.bracketL: node = this.startNode(); this.next(); node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos); this.toReferencedList(node.elements); return this.finishNode(node, "ArrayExpression"); case types.braceL: return this.parseObj(false, refShorthandDefaultPos); case types._function: return this.parseFunctionExpression(); case types.at: this.parseDecorators(); case types._class: node = this.startNode(); this.takeDecorators(node); return this.parseClass(node, false); case types._new: return this.parseNew(); case types.backQuote: return this.parseTemplate(false); case types.doubleColon: node = this.startNode(); this.next(); node.object = null; var callee = node.callee = this.parseNoCallExpr(); if (callee.type === "MemberExpression") { return this.finishNode(node, "BindExpression"); } else { this.raise(callee.start, "Binding should be performed on object property."); } default: this.unexpected(); } }; pp$3.parseFunctionExpression = function () { var node = this.startNode(); var meta = this.parseIdentifier(true); if (this.state.inGenerator && this.eat(types.dot) && this.hasPlugin("functionSent")) { return this.parseMetaProperty(node, meta, "sent"); } else { return this.parseFunction(node, false); } }; pp$3.parseMetaProperty = function (node, meta, propertyName) { node.meta = meta; node.property = this.parseIdentifier(true); if (node.property.name !== propertyName) { this.raise(node.property.start, "The only valid meta property for new is " + meta.name + "." + propertyName); } return this.finishNode(node, "MetaProperty"); }; pp$3.parseLiteral = function (value, type, startPos, startLoc) { startPos = startPos || this.state.start; startLoc = startLoc || this.state.startLoc; var node = this.startNodeAt(startPos, startLoc); this.addExtra(node, "rawValue", value); this.addExtra(node, "raw", this.input.slice(startPos, this.state.end)); node.value = value; this.next(); return this.finishNode(node, type); }; pp$3.parseParenExpression = function () { this.expect(types.parenL); var val = this.parseExpression(); this.expect(types.parenR); return val; }; pp$3.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow) { startPos = startPos || this.state.start; startLoc = startLoc || this.state.startLoc; var val = void 0; this.expect(types.parenL); var innerStartPos = this.state.start; var innerStartLoc = this.state.startLoc; var exprList = []; var refShorthandDefaultPos = { start: 0 }; var refNeedsArrowPos = { start: 0 }; var first = true; var spreadStart = void 0; var optionalCommaStart = void 0; while (!this.match(types.parenR)) { if (first) { first = false; } else { this.expect(types.comma, refNeedsArrowPos.start || null); if (this.match(types.parenR)) { optionalCommaStart = this.state.start; break; } } if (this.match(types.ellipsis)) { var spreadNodeStartPos = this.state.start; var spreadNodeStartLoc = this.state.startLoc; spreadStart = this.state.start; exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc)); break; } else { exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos)); } } var innerEndPos = this.state.start; var innerEndLoc = this.state.startLoc; this.expect(types.parenR); var arrowNode = this.startNodeAt(startPos, startLoc); if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) { for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var param = _ref; if (param.extra && param.extra.parenthesized) this.unexpected(param.extra.parenStart); } return this.parseArrowExpression(arrowNode, exprList); } if (!exprList.length) { this.unexpected(this.state.lastTokStart); } if (optionalCommaStart) this.unexpected(optionalCommaStart); if (spreadStart) this.unexpected(spreadStart); if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start); if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start); if (exprList.length > 1) { val = this.startNodeAt(innerStartPos, innerStartLoc); val.expressions = exprList; this.toReferencedList(val.expressions); this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc); } else { val = exprList[0]; } this.addExtra(val, "parenthesized", true); this.addExtra(val, "parenStart", startPos); return val; }; pp$3.shouldParseArrow = function () { return !this.canInsertSemicolon(); }; pp$3.parseArrow = function (node) { if (this.eat(types.arrow)) { return node; } }; pp$3.parseParenItem = function (node) { return node; }; // New's precedence is slightly tricky. It must allow its argument // to be a `[]` or dot subscript expression, but not a call — at // least, not without wrapping it in parentheses. Thus, it uses the pp$3.parseNew = function () { var node = this.startNode(); var meta = this.parseIdentifier(true); if (this.eat(types.dot)) { var metaProp = this.parseMetaProperty(node, meta, "target"); if (!this.state.inFunction) { this.raise(metaProp.property.start, "new.target can only be used in functions"); } return metaProp; } node.callee = this.parseNoCallExpr(); if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR); this.toReferencedList(node.arguments); } else { node.arguments = []; } return this.finishNode(node, "NewExpression"); }; // Parse template expression. pp$3.parseTemplateElement = function (isTagged) { var elem = this.startNode(); if (this.state.value === null) { if (!isTagged || !this.hasPlugin("templateInvalidEscapes")) { this.raise(this.state.invalidTemplateEscapePosition, "Invalid escape sequence in template"); } else { this.state.invalidTemplateEscapePosition = null; } } elem.value = { raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value }; this.next(); elem.tail = this.match(types.backQuote); return this.finishNode(elem, "TemplateElement"); }; pp$3.parseTemplate = function (isTagged) { var node = this.startNode(); this.next(); node.expressions = []; var curElt = this.parseTemplateElement(isTagged); node.quasis = [curElt]; while (!curElt.tail) { this.expect(types.dollarBraceL); node.expressions.push(this.parseExpression()); this.expect(types.braceR); node.quasis.push(curElt = this.parseTemplateElement(isTagged)); } this.next(); return this.finishNode(node, "TemplateLiteral"); }; // Parse an object literal or binding pattern. pp$3.parseObj = function (isPattern, refShorthandDefaultPos) { var decorators = []; var propHash = Object.create(null); var first = true; var node = this.startNode(); node.properties = []; this.next(); var firstRestLocation = null; while (!this.eat(types.braceR)) { if (first) { first = false; } else { this.expect(types.comma); if (this.eat(types.braceR)) break; } while (this.match(types.at)) { decorators.push(this.parseDecorator()); } var prop = this.startNode(), isGenerator = false, isAsync = false, startPos = void 0, startLoc = void 0; if (decorators.length) { prop.decorators = decorators; decorators = []; } if (this.hasPlugin("objectRestSpread") && this.match(types.ellipsis)) { prop = this.parseSpread(isPattern ? { start: 0 } : undefined); prop.type = isPattern ? "RestProperty" : "SpreadProperty"; if (isPattern) this.toAssignable(prop.argument, true, "object pattern"); node.properties.push(prop); if (isPattern) { var position = this.state.start; if (firstRestLocation !== null) { this.unexpected(firstRestLocation, "Cannot have multiple rest elements when destructuring"); } else if (this.eat(types.braceR)) { break; } else if (this.match(types.comma) && this.lookahead().type === types.braceR) { // TODO: temporary rollback // this.unexpected(position, "A trailing comma is not permitted after the rest element"); continue; } else { firstRestLocation = position; continue; } } else { continue; } } prop.method = false; prop.shorthand = false; if (isPattern || refShorthandDefaultPos) { startPos = this.state.start; startLoc = this.state.startLoc; } if (!isPattern) { isGenerator = this.eat(types.star); } if (!isPattern && this.isContextual("async")) { if (isGenerator) this.unexpected(); var asyncId = this.parseIdentifier(); if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) { prop.key = asyncId; prop.computed = false; } else { isAsync = true; if (this.hasPlugin("asyncGenerators")) isGenerator = this.eat(types.star); this.parsePropertyName(prop); } } else { this.parsePropertyName(prop); } this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos); this.checkPropClash(prop, propHash); if (prop.shorthand) { this.addExtra(prop, "shorthand", true); } node.properties.push(prop); } if (firstRestLocation !== null) { this.unexpected(firstRestLocation, "The rest element has to be the last element when destructuring"); } if (decorators.length) { this.raise(this.state.start, "You have trailing decorators with no property"); } return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression"); }; pp$3.isGetterOrSetterMethod = function (prop, isPattern) { return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || // get "string"() {} this.match(types.num) || // get 1() {} this.match(types.bracketL) || // get ["string"]() {} this.match(types.name) || // get foo() {} this.state.type.keyword // get debugger() {} ); }; // get methods aren't allowed to have any parameters // set methods must have exactly 1 parameter pp$3.checkGetterSetterParamCount = function (method) { var paramCount = method.kind === "get" ? 0 : 1; if (method.params.length !== paramCount) { var start = method.start; if (method.kind === "get") { this.raise(start, "getter should have no params"); } else { this.raise(start, "setter should have exactly one param"); } } }; pp$3.parseObjectMethod = function (prop, isGenerator, isAsync, isPattern) { if (isAsync || isGenerator || this.match(types.parenL)) { if (isPattern) this.unexpected(); prop.kind = "method"; prop.method = true; this.parseMethod(prop, isGenerator, isAsync); return this.finishNode(prop, "ObjectMethod"); } if (this.isGetterOrSetterMethod(prop, isPattern)) { if (isGenerator || isAsync) this.unexpected(); prop.kind = prop.key.name; this.parsePropertyName(prop); this.parseMethod(prop); this.checkGetterSetterParamCount(prop); return this.finishNode(prop, "ObjectMethod"); } }; pp$3.parseObjectProperty = function (prop, startPos, startLoc, isPattern, refShorthandDefaultPos) { if (this.eat(types.colon)) { prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos); return this.finishNode(prop, "ObjectProperty"); } if (!prop.computed && prop.key.type === "Identifier") { this.checkReservedWord(prop.key.name, prop.key.start, true, true); if (isPattern) { prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone()); } else if (this.match(types.eq) && refShorthandDefaultPos) { if (!refShorthandDefaultPos.start) { refShorthandDefaultPos.start = this.state.start; } prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone()); } else { prop.value = prop.key.__clone(); } prop.shorthand = true; return this.finishNode(prop, "ObjectProperty"); } }; pp$3.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) { var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos); if (!node) this.unexpected(); return node; }; pp$3.parsePropertyName = function (prop) { if (this.eat(types.bracketL)) { prop.computed = true; prop.key = this.parseMaybeAssign(); this.expect(types.bracketR); } else { prop.computed = false; var oldInPropertyName = this.state.inPropertyName; this.state.inPropertyName = true; prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true); this.state.inPropertyName = oldInPropertyName; } return prop.key; }; // Initialize empty function node. pp$3.initFunction = function (node, isAsync) { node.id = null; node.generator = false; node.expression = false; node.async = !!isAsync; }; // Parse object or class method. pp$3.parseMethod = function (node, isGenerator, isAsync) { var oldInMethod = this.state.inMethod; this.state.inMethod = node.kind || true; this.initFunction(node, isAsync); this.expect(types.parenL); node.params = this.parseBindingList(types.parenR); node.generator = !!isGenerator; this.parseFunctionBody(node); this.state.inMethod = oldInMethod; return node; }; // Parse arrow function expression with given parameters. pp$3.parseArrowExpression = function (node, params, isAsync) { this.initFunction(node, isAsync); node.params = this.toAssignableList(params, true, "arrow function parameters"); this.parseFunctionBody(node, true); return this.finishNode(node, "ArrowFunctionExpression"); }; pp$3.isStrictBody = function (node, isExpression) { if (!isExpression && node.body.directives.length) { for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var directive = _ref2; if (directive.value.value === "use strict") { return true; } } } return false; }; // Parse function body and check parameters. pp$3.parseFunctionBody = function (node, allowExpression) { var isExpression = allowExpression && !this.match(types.braceL); var oldInAsync = this.state.inAsync; this.state.inAsync = node.async; if (isExpression) { node.body = this.parseMaybeAssign(); node.expression = true; } else { // Start a new scope with regard to labels and the `inFunction` // flag (restore them to their old value afterwards). var oldInFunc = this.state.inFunction; var oldInGen = this.state.inGenerator; var oldLabels = this.state.labels; this.state.inFunction = true;this.state.inGenerator = node.generator;this.state.labels = []; node.body = this.parseBlock(true); node.expression = false; this.state.inFunction = oldInFunc;this.state.inGenerator = oldInGen;this.state.labels = oldLabels; } this.state.inAsync = oldInAsync; // If this is a strict mode function, verify that argument names // are not repeated, and it does not try to bind the words `eval` // or `arguments`. var isStrict = this.isStrictBody(node, isExpression); // Also check when allowExpression === true for arrow functions var checkLVal = this.state.strict || allowExpression || isStrict; if (isStrict && node.id && node.id.type === "Identifier" && node.id.name === "yield") { this.raise(node.id.start, "Binding yield in strict mode"); } if (checkLVal) { var nameHash = Object.create(null); var oldStrict = this.state.strict; if (isStrict) this.state.strict = true; if (node.id) { this.checkLVal(node.id, true, undefined, "function name"); } for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) { var _ref3; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref3 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref3 = _i3.value; } var param = _ref3; if (isStrict && param.type !== "Identifier") { this.raise(param.start, "Non-simple parameter in strict mode"); } this.checkLVal(param, true, nameHash, "function parameter list"); } this.state.strict = oldStrict; } }; // Parses a comma-separated list of expressions, and returns them as // an array. `close` is the token type that ends the list, and // `allowEmpty` can be turned on to allow subsequent commas with // nothing in between them to be parsed as `null` (which is needed // for array literals). pp$3.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) { var elts = []; var first = true; while (!this.eat(close)) { if (first) { first = false; } else { this.expect(types.comma); if (this.eat(close)) break; } elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos)); } return elts; }; pp$3.parseExprListItem = function (allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) { var elt = void 0; if (allowEmpty && this.match(types.comma)) { elt = null; } else if (this.match(types.ellipsis)) { elt = this.parseSpread(refShorthandDefaultPos); } else { elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos); } return elt; }; // Parse the next token as an identifier. If `liberal` is true (used // when parsing properties), it will also convert keywords into // identifiers. pp$3.parseIdentifier = function (liberal) { var node = this.startNode(); if (!liberal) { this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false); } if (this.match(types.name)) { node.name = this.state.value; } else if (this.state.type.keyword) { node.name = this.state.type.keyword; } else { this.unexpected(); } if (!liberal && node.name === "await" && this.state.inAsync) { this.raise(node.start, "invalid use of await inside of an async function"); } node.loc.identifierName = node.name; this.next(); return this.finishNode(node, "Identifier"); }; pp$3.checkReservedWord = function (word, startLoc, checkKeywords, isBinding) { if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) { this.raise(startLoc, word + " is a reserved word"); } if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) { this.raise(startLoc, word + " is a reserved word in strict mode"); } }; // Parses await expression inside async function. pp$3.parseAwait = function (node) { // istanbul ignore next: this condition is checked at the call site so won't be hit here if (!this.state.inAsync) { this.unexpected(); } if (this.match(types.star)) { this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead."); } node.argument = this.parseMaybeUnary(); return this.finishNode(node, "AwaitExpression"); }; // Parses yield expression inside generator. pp$3.parseYield = function () { var node = this.startNode(); this.next(); if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) { node.delegate = false; node.argument = null; } else { node.delegate = this.eat(types.star); node.argument = this.parseMaybeAssign(); } return this.finishNode(node, "YieldExpression"); }; // Start an AST node, attaching a start offset. var pp$4 = Parser.prototype; var commentKeys = ["leadingComments", "trailingComments", "innerComments"]; var Node = function () { function Node(pos, loc, filename) { classCallCheck(this, Node); this.type = ""; this.start = pos; this.end = 0; this.loc = new SourceLocation(loc); if (filename) this.loc.filename = filename; } Node.prototype.__clone = function __clone() { var node2 = new Node(); for (var key in this) { // Do not clone comments that are already attached to the node if (commentKeys.indexOf(key) < 0) { node2[key] = this[key]; } } return node2; }; return Node; }(); pp$4.startNode = function () { return new Node(this.state.start, this.state.startLoc, this.filename); }; pp$4.startNodeAt = function (pos, loc) { return new Node(pos, loc, this.filename); }; function finishNodeAt(node, type, pos, loc) { node.type = type; node.end = pos; node.loc.end = loc; this.processComment(node); return node; } // Finish an AST node, adding `type` and `end` properties. pp$4.finishNode = function (node, type) { return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc); }; // Finish node at given position pp$4.finishNodeAt = function (node, type, pos, loc) { return finishNodeAt.call(this, node, type, pos, loc); }; var pp$5 = Parser.prototype; // This function is used to raise exceptions on parse errors. It // takes an offset integer (into the current `input`) to indicate // the location of the error, attaches the position to the end // of the error message, and then raises a `SyntaxError` with that // message. pp$5.raise = function (pos, message) { var loc = getLineInfo(this.input, pos); message += " (" + loc.line + ":" + loc.column + ")"; var err = new SyntaxError(message); err.pos = pos; err.loc = loc; throw err; }; /* eslint max-len: 0 */ /** * Based on the comment attachment algorithm used in espree and estraverse. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ function last(stack) { return stack[stack.length - 1]; } var pp$6 = Parser.prototype; pp$6.addComment = function (comment) { if (this.filename) comment.loc.filename = this.filename; this.state.trailingComments.push(comment); this.state.leadingComments.push(comment); }; pp$6.processComment = function (node) { if (node.type === "Program" && node.body.length > 0) return; var stack = this.state.commentStack; var firstChild = void 0, lastChild = void 0, trailingComments = void 0, i = void 0, j = void 0; if (this.state.trailingComments.length > 0) { // If the first comment in trailingComments comes after the // current node, then we're good - all comments in the array will // come after the node and so it's safe to add them as official // trailingComments. if (this.state.trailingComments[0].start >= node.end) { trailingComments = this.state.trailingComments; this.state.trailingComments = []; } else { // Otherwise, if the first comment doesn't come after the // current node, that means we have a mix of leading and trailing // comments in the array and that leadingComments contains the // same items as trailingComments. Reset trailingComments to // zero items and we'll handle this by evaluating leadingComments // later. this.state.trailingComments.length = 0; } } else { var lastInStack = last(stack); if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) { trailingComments = lastInStack.trailingComments; lastInStack.trailingComments = null; } } // Eating the stack. if (stack.length > 0 && last(stack).start >= node.start) { firstChild = stack.pop(); } while (stack.length > 0 && last(stack).start >= node.start) { lastChild = stack.pop(); } if (!lastChild && firstChild) lastChild = firstChild; // Attach comments that follow a trailing comma on the last // property in an object literal or a trailing comma in function arguments // as trailing comments if (firstChild && this.state.leadingComments.length > 0) { var lastComment = last(this.state.leadingComments); if (firstChild.type === "ObjectProperty") { if (lastComment.start >= node.start) { if (this.state.commentPreviousNode) { for (j = 0; j < this.state.leadingComments.length; j++) { if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) { this.state.leadingComments.splice(j, 1); j--; } } if (this.state.leadingComments.length > 0) { firstChild.trailingComments = this.state.leadingComments; this.state.leadingComments = []; } } } } else if (node.type === "CallExpression" && node.arguments && node.arguments.length) { var lastArg = last(node.arguments); if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) { if (this.state.commentPreviousNode) { if (this.state.leadingComments.length > 0) { lastArg.trailingComments = this.state.leadingComments; this.state.leadingComments = []; } } } } } if (lastChild) { if (lastChild.leadingComments) { if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) { node.leadingComments = lastChild.leadingComments; lastChild.leadingComments = null; } else { // A leading comment for an anonymous class had been stolen by its first ClassMethod, // so this takes back the leading comment. // See also: https://github.com/eslint/espree/issues/158 for (i = lastChild.leadingComments.length - 2; i >= 0; --i) { if (lastChild.leadingComments[i].end <= node.start) { node.leadingComments = lastChild.leadingComments.splice(0, i + 1); break; } } } } } else if (this.state.leadingComments.length > 0) { if (last(this.state.leadingComments).end <= node.start) { if (this.state.commentPreviousNode) { for (j = 0; j < this.state.leadingComments.length; j++) { if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) { this.state.leadingComments.splice(j, 1); j--; } } } if (this.state.leadingComments.length > 0) { node.leadingComments = this.state.leadingComments; this.state.leadingComments = []; } } else { // https://github.com/eslint/espree/issues/2 // // In special cases, such as return (without a value) and // debugger, all comments will end up as leadingComments and // will otherwise be eliminated. This step runs when the // commentStack is empty and there are comments left // in leadingComments. // // This loop figures out the stopping point between the actual // leading and trailing comments by finding the location of the // first comment that comes after the given node. for (i = 0; i < this.state.leadingComments.length; i++) { if (this.state.leadingComments[i].end > node.start) { break; } } // Split the array based on the location of the first comment // that comes after the node. Keep in mind that this could // result in an empty array, and if so, the array must be // deleted. node.leadingComments = this.state.leadingComments.slice(0, i); if (node.leadingComments.length === 0) { node.leadingComments = null; } // Similarly, trailing comments are attached later. The variable // must be reset to null if there are no trailing comments. trailingComments = this.state.leadingComments.slice(i); if (trailingComments.length === 0) { trailingComments = null; } } } this.state.commentPreviousNode = node; if (trailingComments) { if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) { node.innerComments = trailingComments; } else { node.trailingComments = trailingComments; } } stack.push(node); }; var pp$7 = Parser.prototype; pp$7.estreeParseRegExpLiteral = function (_ref) { var pattern = _ref.pattern, flags = _ref.flags; var regex = null; try { regex = new RegExp(pattern, flags); } catch (e) { // In environments that don't support these flags value will // be null as the regex can't be represented natively. } var node = this.estreeParseLiteral(regex); node.regex = { pattern: pattern, flags: flags }; return node; }; pp$7.estreeParseLiteral = function (value) { return this.parseLiteral(value, "Literal"); }; pp$7.directiveToStmt = function (directive) { var directiveLiteral = directive.value; var stmt = this.startNodeAt(directive.start, directive.loc.start); var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start); expression.value = directiveLiteral.value; expression.raw = directiveLiteral.extra.raw; stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end); stmt.directive = directiveLiteral.extra.raw.slice(1, -1); return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end); }; function isSimpleProperty(node) { return node && node.type === "Property" && node.kind === "init" && node.method === false; } var estreePlugin = function estreePlugin(instance) { instance.extend("checkDeclaration", function (inner) { return function (node) { if (isSimpleProperty(node)) { this.checkDeclaration(node.value); } else { inner.call(this, node); } }; }); instance.extend("checkGetterSetterParamCount", function () { return function (prop) { var paramCount = prop.kind === "get" ? 0 : 1; if (prop.value.params.length !== paramCount) { var start = prop.start; if (prop.kind === "get") { this.raise(start, "getter should have no params"); } else { this.raise(start, "setter should have exactly one param"); } } }; }); instance.extend("checkLVal", function (inner) { return function (expr, isBinding, checkClashes) { var _this = this; switch (expr.type) { case "ObjectPattern": expr.properties.forEach(function (prop) { _this.checkLVal(prop.type === "Property" ? prop.value : prop, isBinding, checkClashes, "object destructuring pattern"); }); break; default: for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) { args[_key - 3] = arguments[_key]; } inner.call.apply(inner, [this, expr, isBinding, checkClashes].concat(args)); } }; }); instance.extend("checkPropClash", function () { return function (prop, propHash) { if (prop.computed || !isSimpleProperty(prop)) return; var key = prop.key; // It is either an Identifier or a String/NumericLiteral var name = key.type === "Identifier" ? key.name : String(key.value); if (name === "__proto__") { if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property"); propHash.proto = true; } }; }); instance.extend("isStrictBody", function () { return function (node, isExpression) { if (!isExpression && node.body.body.length > 0) { for (var _iterator = node.body.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) { var _ref2; if (_isArray) { if (_i >= _iterator.length) break; _ref2 = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref2 = _i.value; } var directive = _ref2; if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") { if (directive.expression.value === "use strict") return true; } else { // Break for the first non literal expression break; } } } return false; }; }); instance.extend("isValidDirective", function () { return function (stmt) { return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized); }; }); instance.extend("stmtToDirective", function (inner) { return function (stmt) { var directive = inner.call(this, stmt); var value = stmt.expression.value; // Reset value to the actual value as in estree mode we want // the stmt to have the real value and not the raw value directive.value.value = value; return directive; }; }); instance.extend("parseBlockBody", function (inner) { return function (node) { var _this2 = this; for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) { args[_key2 - 1] = arguments[_key2]; } inner.call.apply(inner, [this, node].concat(args)); node.directives.reverse().forEach(function (directive) { node.body.unshift(_this2.directiveToStmt(directive)); }); delete node.directives; }; }); instance.extend("parseClassMethod", function () { return function (classBody, method, isGenerator, isAsync) { this.parseMethod(method, isGenerator, isAsync); if (method.typeParameters) { method.value.typeParameters = method.typeParameters; delete method.typeParameters; } classBody.body.push(this.finishNode(method, "MethodDefinition")); }; }); instance.extend("parseExprAtom", function (inner) { return function () { switch (this.state.type) { case types.regexp: return this.estreeParseRegExpLiteral(this.state.value); case types.num: case types.string: return this.estreeParseLiteral(this.state.value); case types._null: return this.estreeParseLiteral(null); case types._true: return this.estreeParseLiteral(true); case types._false: return this.estreeParseLiteral(false); default: for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) { args[_key3] = arguments[_key3]; } return inner.call.apply(inner, [this].concat(args)); } }; }); instance.extend("parseLiteral", function (inner) { return function () { for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) { args[_key4] = arguments[_key4]; } var node = inner.call.apply(inner, [this].concat(args)); node.raw = node.extra.raw; delete node.extra; return node; }; }); instance.extend("parseMethod", function (inner) { return function (node) { var funcNode = this.startNode(); funcNode.kind = node.kind; // provide kind, so inner method correctly sets state for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) { args[_key5 - 1] = arguments[_key5]; } funcNode = inner.call.apply(inner, [this, funcNode].concat(args)); delete funcNode.kind; node.value = this.finishNode(funcNode, "FunctionExpression"); return node; }; }); instance.extend("parseObjectMethod", function (inner) { return function () { for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) { args[_key6] = arguments[_key6]; } var node = inner.call.apply(inner, [this].concat(args)); if (node) { if (node.kind === "method") node.kind = "init"; node.type = "Property"; } return node; }; }); instance.extend("parseObjectProperty", function (inner) { return function () { for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) { args[_key7] = arguments[_key7]; } var node = inner.call.apply(inner, [this].concat(args)); if (node) { node.kind = "init"; node.type = "Property"; } return node; }; }); instance.extend("toAssignable", function (inner) { return function (node, isBinding) { for (var _len8 = arguments.length, args = Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) { args[_key8 - 2] = arguments[_key8]; } if (isSimpleProperty(node)) { this.toAssignable.apply(this, [node.value, isBinding].concat(args)); return node; } else if (node.type === "ObjectExpression") { node.type = "ObjectPattern"; for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) { var _ref3; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref3 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref3 = _i2.value; } var prop = _ref3; if (prop.kind === "get" || prop.kind === "set") { this.raise(prop.key.start, "Object pattern can't contain getter or setter"); } else if (prop.method) { this.raise(prop.key.start, "Object pattern can't contain methods"); } else { this.toAssignable(prop, isBinding, "object destructuring pattern"); } } return node; } return inner.call.apply(inner, [this, node, isBinding].concat(args)); }; }); }; /* eslint max-len: 0 */ var primitiveTypes = ["any", "mixed", "empty", "bool", "boolean", "number", "string", "void", "null"]; var pp$8 = Parser.prototype; pp$8.flowParseTypeInitialiser = function (tok) { var oldInType = this.state.inType; this.state.inType = true; this.expect(tok || types.colon); var type = this.flowParseType(); this.state.inType = oldInType; return type; }; pp$8.flowParsePredicate = function () { var node = this.startNode(); var moduloLoc = this.state.startLoc; var moduloPos = this.state.start; this.expect(types.modulo); var checksLoc = this.state.startLoc; this.expectContextual("checks"); // Force '%' and 'checks' to be adjacent if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) { this.raise(moduloPos, "Spaces between ´%´ and ´checks´ are not allowed here."); } if (this.eat(types.parenL)) { node.expression = this.parseExpression(); this.expect(types.parenR); return this.finishNode(node, "DeclaredPredicate"); } else { return this.finishNode(node, "InferredPredicate"); } }; pp$8.flowParseTypeAndPredicateInitialiser = function () { var oldInType = this.state.inType; this.state.inType = true; this.expect(types.colon); var type = null; var predicate = null; if (this.match(types.modulo)) { this.state.inType = oldInType; predicate = this.flowParsePredicate(); } else { type = this.flowParseType(); this.state.inType = oldInType; if (this.match(types.modulo)) { predicate = this.flowParsePredicate(); } } return [type, predicate]; }; pp$8.flowParseDeclareClass = function (node) { this.next(); this.flowParseInterfaceish(node, true); return this.finishNode(node, "DeclareClass"); }; pp$8.flowParseDeclareFunction = function (node) { this.next(); var id = node.id = this.parseIdentifier(); var typeNode = this.startNode(); var typeContainer = this.startNode(); if (this.isRelational("<")) { typeNode.typeParameters = this.flowParseTypeParameterDeclaration(); } else { typeNode.typeParameters = null; } this.expect(types.parenL); var tmp = this.flowParseFunctionTypeParams(); typeNode.params = tmp.params; typeNode.rest = tmp.rest; this.expect(types.parenR); var predicate = null; var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser(); typeNode.returnType = _flowParseTypeAndPred[0]; predicate = _flowParseTypeAndPred[1]; typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation"); typeContainer.predicate = predicate; id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation"); this.finishNode(id, id.type); this.semicolon(); return this.finishNode(node, "DeclareFunction"); }; pp$8.flowParseDeclare = function (node) { if (this.match(types._class)) { return this.flowParseDeclareClass(node); } else if (this.match(types._function)) { return this.flowParseDeclareFunction(node); } else if (this.match(types._var)) { return this.flowParseDeclareVariable(node); } else if (this.isContextual("module")) { if (this.lookahead().type === types.dot) { return this.flowParseDeclareModuleExports(node); } else { return this.flowParseDeclareModule(node); } } else if (this.isContextual("type")) { return this.flowParseDeclareTypeAlias(node); } else if (this.isContextual("opaque")) { return this.flowParseDeclareOpaqueType(node); } else if (this.isContextual("interface")) { return this.flowParseDeclareInterface(node); } else if (this.match(types._export)) { return this.flowParseDeclareExportDeclaration(node); } else { this.unexpected(); } }; pp$8.flowParseDeclareExportDeclaration = function (node) { this.expect(types._export); if (this.isContextual("opaque") // declare export opaque ... ) { node.declaration = this.flowParseDeclare(this.startNode()); node.default = false; return this.finishNode(node, "DeclareExportDeclaration"); } throw this.unexpected(); }; pp$8.flowParseDeclareVariable = function (node) { this.next(); node.id = this.flowParseTypeAnnotatableIdentifier(); this.semicolon(); return this.finishNode(node, "DeclareVariable"); }; pp$8.flowParseDeclareModule = function (node) { this.next(); if (this.match(types.string)) { node.id = this.parseExprAtom(); } else { node.id = this.parseIdentifier(); } var bodyNode = node.body = this.startNode(); var body = bodyNode.body = []; this.expect(types.braceL); while (!this.match(types.braceR)) { var _bodyNode = this.startNode(); if (this.match(types._import)) { var lookahead = this.lookahead(); if (lookahead.value !== "type" && lookahead.value !== "typeof") { this.unexpected(null, "Imports within a `declare module` body must always be `import type` or `import typeof`"); } this.parseImport(_bodyNode); } else { this.expectContextual("declare", "Only declares and type imports are allowed inside declare module"); _bodyNode = this.flowParseDeclare(_bodyNode, true); } body.push(_bodyNode); } this.expect(types.braceR); this.finishNode(bodyNode, "BlockStatement"); return this.finishNode(node, "DeclareModule"); }; pp$8.flowParseDeclareModuleExports = function (node) { this.expectContextual("module"); this.expect(types.dot); this.expectContextual("exports"); node.typeAnnotation = this.flowParseTypeAnnotation(); this.semicolon(); return this.finishNode(node, "DeclareModuleExports"); }; pp$8.flowParseDeclareTypeAlias = function (node) { this.next(); this.flowParseTypeAlias(node); return this.finishNode(node, "DeclareTypeAlias"); }; pp$8.flowParseDeclareOpaqueType = function (node) { this.next(); this.flowParseOpaqueType(node, true); return this.finishNode(node, "DeclareOpaqueType"); }; pp$8.flowParseDeclareInterface = function (node) { this.next(); this.flowParseInterfaceish(node); return this.finishNode(node, "DeclareInterface"); }; // Interfaces pp$8.flowParseInterfaceish = function (node) { node.id = this.parseIdentifier(); if (this.isRelational("<")) { node.typeParameters = this.flowParseTypeParameterDeclaration(); } else { node.typeParameters = null; } node.extends = []; node.mixins = []; if (this.eat(types._extends)) { do { node.extends.push(this.flowParseInterfaceExtends()); } while (this.eat(types.comma)); } if (this.isContextual("mixins")) { this.next(); do { node.mixins.push(this.flowParseInterfaceExtends()); } while (this.eat(types.comma)); } node.body = this.flowParseObjectType(true, false, false); }; pp$8.flowParseInterfaceExtends = function () { var node = this.startNode(); node.id = this.flowParseQualifiedTypeIdentifier(); if (this.isRelational("<")) { node.typeParameters = this.flowParseTypeParameterInstantiation(); } else { node.typeParameters = null; } return this.finishNode(node, "InterfaceExtends"); }; pp$8.flowParseInterface = function (node) { this.flowParseInterfaceish(node, false); return this.finishNode(node, "InterfaceDeclaration"); }; pp$8.flowParseRestrictedIdentifier = function (liberal) { if (primitiveTypes.indexOf(this.state.value) > -1) { this.raise(this.state.start, "Cannot overwrite primitive type " + this.state.value); } return this.parseIdentifier(liberal); }; // Type aliases pp$8.flowParseTypeAlias = function (node) { node.id = this.flowParseRestrictedIdentifier(); if (this.isRelational("<")) { node.typeParameters = this.flowParseTypeParameterDeclaration(); } else { node.typeParameters = null; } node.right = this.flowParseTypeInitialiser(types.eq); this.semicolon(); return this.finishNode(node, "TypeAlias"); }; // Opaque type aliases pp$8.flowParseOpaqueType = function (node, declare) { this.expectContextual("type"); node.id = this.flowParseRestrictedIdentifier(); if (this.isRelational("<")) { node.typeParameters = this.flowParseTypeParameterDeclaration(); } else { node.typeParameters = null; } // Parse the supertype node.supertype = null; if (this.match(types.colon)) { node.supertype = this.flowParseTypeInitialiser(types.colon); } node.impltype = null; if (!declare) { node.impltype = this.flowParseTypeInitialiser(types.eq); } this.semicolon(); return this.finishNode(node, "OpaqueType"); }; // Type annotations pp$8.flowParseTypeParameter = function () { var node = this.startNode(); var variance = this.flowParseVariance(); var ident = this.flowParseTypeAnnotatableIdentifier(); node.name = ident.name; node.variance = variance; node.bound = ident.typeAnnotation; if (this.match(types.eq)) { this.eat(types.eq); node.default = this.flowParseType(); } return this.finishNode(node, "TypeParameter"); }; pp$8.flowParseTypeParameterDeclaration = function () { var oldInType = this.state.inType; var node = this.startNode(); node.params = []; this.state.inType = true; // istanbul ignore else: this condition is already checked at all call sites if (this.isRelational("<") || this.match(types.jsxTagStart)) { this.next(); } else { this.unexpected(); } do { node.params.push(this.flowParseTypeParameter()); if (!this.isRelational(">")) { this.expect(types.comma); } } while (!this.isRelational(">")); this.expectRelational(">"); this.state.inType = oldInType; return this.finishNode(node, "TypeParameterDeclaration"); }; pp$8.flowParseTypeParameterInstantiation = function () { var node = this.startNode(); var oldInType = this.state.inType; node.params = []; this.state.inType = true; this.expectRelational("<"); while (!this.isRelational(">")) { node.params.push(this.flowParseType()); if (!this.isRelational(">")) { this.expect(types.comma); } } this.expectRelational(">"); this.state.inType = oldInType; return this.finishNode(node, "TypeParameterInstantiation"); }; pp$8.flowParseObjectPropertyKey = function () { return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true); }; pp$8.flowParseObjectTypeIndexer = function (node, isStatic, variance) { node.static = isStatic; this.expect(types.bracketL); if (this.lookahead().type === types.colon) { node.id = this.flowParseObjectPropertyKey(); node.key = this.flowParseTypeInitialiser(); } else { node.id = null; node.key = this.flowParseType(); } this.expect(types.bracketR); node.value = this.flowParseTypeInitialiser(); node.variance = variance; this.flowObjectTypeSemicolon(); return this.finishNode(node, "ObjectTypeIndexer"); }; pp$8.flowParseObjectTypeMethodish = function (node) { node.params = []; node.rest = null; node.typeParameters = null; if (this.isRelational("<")) { node.typeParameters = this.flowParseTypeParameterDeclaration(); } this.expect(types.parenL); while (!this.match(types.parenR) && !this.match(types.ellipsis)) { node.params.push(this.flowParseFunctionTypeParam()); if (!this.match(types.parenR)) { this.expect(types.comma); } } if (this.eat(types.ellipsis)) { node.rest = this.flowParseFunctionTypeParam(); } this.expect(types.parenR); node.returnType = this.flowParseTypeInitialiser(); return this.finishNode(node, "FunctionTypeAnnotation"); }; pp$8.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) { var node = this.startNodeAt(startPos, startLoc); node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc)); node.static = isStatic; node.key = key; node.optional = false; this.flowObjectTypeSemicolon(); return this.finishNode(node, "ObjectTypeProperty"); }; pp$8.flowParseObjectTypeCallProperty = function (node, isStatic) { var valueNode = this.startNode(); node.static = isStatic; node.value = this.flowParseObjectTypeMethodish(valueNode); this.flowObjectTypeSemicolon(); return this.finishNode(node, "ObjectTypeCallProperty"); }; pp$8.flowParseObjectType = function (allowStatic, allowExact, allowSpread) { var oldInType = this.state.inType; this.state.inType = true; var nodeStart = this.startNode(); var node = void 0; var propertyKey = void 0; var isStatic = false; nodeStart.callProperties = []; nodeStart.properties = []; nodeStart.indexers = []; var endDelim = void 0; var exact = void 0; if (allowExact && this.match(types.braceBarL)) { this.expect(types.braceBarL); endDelim = types.braceBarR; exact = true; } else { this.expect(types.braceL); endDelim = types.braceR; exact = false; } nodeStart.exact = exact; while (!this.match(endDelim)) { var optional = false; var startPos = this.state.start; var startLoc = this.state.startLoc; node = this.startNode(); if (allowStatic && this.isContextual("static") && this.lookahead().type !== types.colon) { this.next(); isStatic = true; } var variancePos = this.state.start; var variance = this.flowParseVariance(); if (this.match(types.bracketL)) { nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance)); } else if (this.match(types.parenL) || this.isRelational("<")) { if (variance) { this.unexpected(variancePos); } nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic)); } else { if (this.match(types.ellipsis)) { if (!allowSpread) { this.unexpected(null, "Spread operator cannot appear in class or interface definitions"); } if (variance) { this.unexpected(variance.start, "Spread properties cannot have variance"); } this.expect(types.ellipsis); node.argument = this.flowParseType(); this.flowObjectTypeSemicolon(); nodeStart.properties.push(this.finishNode(node, "ObjectTypeSpreadProperty")); } else { propertyKey = this.flowParseObjectPropertyKey(); if (this.isRelational("<") || this.match(types.parenL)) { // This is a method property if (variance) { this.unexpected(variance.start); } nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey)); } else { if (this.eat(types.question)) { optional = true; } node.key = propertyKey; node.value = this.flowParseTypeInitialiser(); node.optional = optional; node.static = isStatic; node.variance = variance; this.flowObjectTypeSemicolon(); nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty")); } } } isStatic = false; } this.expect(endDelim); var out = this.finishNode(nodeStart, "ObjectTypeAnnotation"); this.state.inType = oldInType; return out; }; pp$8.flowObjectTypeSemicolon = function () { if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) { this.unexpected(); } }; pp$8.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) { startPos = startPos || this.state.start; startLoc = startLoc || this.state.startLoc; var node = id || this.parseIdentifier(); while (this.eat(types.dot)) { var node2 = this.startNodeAt(startPos, startLoc); node2.qualification = node; node2.id = this.parseIdentifier(); node = this.finishNode(node2, "QualifiedTypeIdentifier"); } return node; }; pp$8.flowParseGenericType = function (startPos, startLoc, id) { var node = this.startNodeAt(startPos, startLoc); node.typeParameters = null; node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id); if (this.isRelational("<")) { node.typeParameters = this.flowParseTypeParameterInstantiation(); } return this.finishNode(node, "GenericTypeAnnotation"); }; pp$8.flowParseTypeofType = function () { var node = this.startNode(); this.expect(types._typeof); node.argument = this.flowParsePrimaryType(); return this.finishNode(node, "TypeofTypeAnnotation"); }; pp$8.flowParseTupleType = function () { var node = this.startNode(); node.types = []; this.expect(types.bracketL); // We allow trailing commas while (this.state.pos < this.input.length && !this.match(types.bracketR)) { node.types.push(this.flowParseType()); if (this.match(types.bracketR)) break; this.expect(types.comma); } this.expect(types.bracketR); return this.finishNode(node, "TupleTypeAnnotation"); }; pp$8.flowParseFunctionTypeParam = function () { var name = null; var optional = false; var typeAnnotation = null; var node = this.startNode(); var lh = this.lookahead(); if (lh.type === types.colon || lh.type === types.question) { name = this.parseIdentifier(); if (this.eat(types.question)) { optional = true; } typeAnnotation = this.flowParseTypeInitialiser(); } else { typeAnnotation = this.flowParseType(); } node.name = name; node.optional = optional; node.typeAnnotation = typeAnnotation; return this.finishNode(node, "FunctionTypeParam"); }; pp$8.reinterpretTypeAsFunctionTypeParam = function (type) { var node = this.startNodeAt(type.start, type.loc.start); node.name = null; node.optional = false; node.typeAnnotation = type; return this.finishNode(node, "FunctionTypeParam"); }; pp$8.flowParseFunctionTypeParams = function () { var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; var ret = { params: params, rest: null }; while (!this.match(types.parenR) && !this.match(types.ellipsis)) { ret.params.push(this.flowParseFunctionTypeParam()); if (!this.match(types.parenR)) { this.expect(types.comma); } } if (this.eat(types.ellipsis)) { ret.rest = this.flowParseFunctionTypeParam(); } return ret; }; pp$8.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) { switch (id.name) { case "any": return this.finishNode(node, "AnyTypeAnnotation"); case "void": return this.finishNode(node, "VoidTypeAnnotation"); case "bool": case "boolean": return this.finishNode(node, "BooleanTypeAnnotation"); case "mixed": return this.finishNode(node, "MixedTypeAnnotation"); case "empty": return this.finishNode(node, "EmptyTypeAnnotation"); case "number": return this.finishNode(node, "NumberTypeAnnotation"); case "string": return this.finishNode(node, "StringTypeAnnotation"); default: return this.flowParseGenericType(startPos, startLoc, id); } }; // The parsing of types roughly parallels the parsing of expressions, and // primary types are kind of like primary expressions...they're the // primitives with which other types are constructed. pp$8.flowParsePrimaryType = function () { var startPos = this.state.start; var startLoc = this.state.startLoc; var node = this.startNode(); var tmp = void 0; var type = void 0; var isGroupedType = false; var oldNoAnonFunctionType = this.state.noAnonFunctionType; switch (this.state.type) { case types.name: return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier()); case types.braceL: return this.flowParseObjectType(false, false, true); case types.braceBarL: return this.flowParseObjectType(false, true, true); case types.bracketL: return this.flowParseTupleType(); case types.relational: if (this.state.value === "<") { node.typeParameters = this.flowParseTypeParameterDeclaration(); this.expect(types.parenL); tmp = this.flowParseFunctionTypeParams(); node.params = tmp.params; node.rest = tmp.rest; this.expect(types.parenR); this.expect(types.arrow); node.returnType = this.flowParseType(); return this.finishNode(node, "FunctionTypeAnnotation"); } break; case types.parenL: this.next(); // Check to see if this is actually a grouped type if (!this.match(types.parenR) && !this.match(types.ellipsis)) { if (this.match(types.name)) { var token = this.lookahead().type; isGroupedType = token !== types.question && token !== types.colon; } else { isGroupedType = true; } } if (isGroupedType) { this.state.noAnonFunctionType = false; type = this.flowParseType(); this.state.noAnonFunctionType = oldNoAnonFunctionType; // A `,` or a `) =>` means this is an anonymous function type if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) { this.expect(types.parenR); return type; } else { // Eat a comma if there is one this.eat(types.comma); } } if (type) { tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]); } else { tmp = this.flowParseFunctionTypeParams(); } node.params = tmp.params; node.rest = tmp.rest; this.expect(types.parenR); this.expect(types.arrow); node.returnType = this.flowParseType(); node.typeParameters = null; return this.finishNode(node, "FunctionTypeAnnotation"); case types.string: return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation"); case types._true:case types._false: node.value = this.match(types._true); this.next(); return this.finishNode(node, "BooleanLiteralTypeAnnotation"); case types.plusMin: if (this.state.value === "-") { this.next(); if (!this.match(types.num)) this.unexpected(null, "Unexpected token, expected number"); return this.parseLiteral(-this.state.value, "NumericLiteralTypeAnnotation", node.start, node.loc.start); } this.unexpected(); case types.num: return this.parseLiteral(this.state.value, "NumericLiteralTypeAnnotation"); case types._null: node.value = this.match(types._null); this.next(); return this.finishNode(node, "NullLiteralTypeAnnotation"); case types._this: node.value = this.match(types._this); this.next(); return this.finishNode(node, "ThisTypeAnnotation"); case types.star: this.next(); return this.finishNode(node, "ExistentialTypeParam"); default: if (this.state.type.keyword === "typeof") { return this.flowParseTypeofType(); } } this.unexpected(); }; pp$8.flowParsePostfixType = function () { var startPos = this.state.start, startLoc = this.state.startLoc; var type = this.flowParsePrimaryType(); while (!this.canInsertSemicolon() && this.match(types.bracketL)) { var node = this.startNodeAt(startPos, startLoc); node.elementType = type; this.expect(types.bracketL); this.expect(types.bracketR); type = this.finishNode(node, "ArrayTypeAnnotation"); } return type; }; pp$8.flowParsePrefixType = function () { var node = this.startNode(); if (this.eat(types.question)) { node.typeAnnotation = this.flowParsePrefixType(); return this.finishNode(node, "NullableTypeAnnotation"); } else { return this.flowParsePostfixType(); } }; pp$8.flowParseAnonFunctionWithoutParens = function () { var param = this.flowParsePrefixType(); if (!this.state.noAnonFunctionType && this.eat(types.arrow)) { var node = this.startNodeAt(param.start, param.loc.start); node.params = [this.reinterpretTypeAsFunctionTypeParam(param)]; node.rest = null; node.returnType = this.flowParseType(); node.typeParameters = null; return this.finishNode(node, "FunctionTypeAnnotation"); } return param; }; pp$8.flowParseIntersectionType = function () { var node = this.startNode(); this.eat(types.bitwiseAND); var type = this.flowParseAnonFunctionWithoutParens(); node.types = [type]; while (this.eat(types.bitwiseAND)) { node.types.push(this.flowParseAnonFunctionWithoutParens()); } return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation"); }; pp$8.flowParseUnionType = function () { var node = this.startNode(); this.eat(types.bitwiseOR); var type = this.flowParseIntersectionType(); node.types = [type]; while (this.eat(types.bitwiseOR)) { node.types.push(this.flowParseIntersectionType()); } return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation"); }; pp$8.flowParseType = function () { var oldInType = this.state.inType; this.state.inType = true; var type = this.flowParseUnionType(); this.state.inType = oldInType; return type; }; pp$8.flowParseTypeAnnotation = function () { var node = this.startNode(); node.typeAnnotation = this.flowParseTypeInitialiser(); return this.finishNode(node, "TypeAnnotation"); }; pp$8.flowParseTypeAndPredicateAnnotation = function () { var node = this.startNode(); var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser(); node.typeAnnotation = _flowParseTypeAndPred2[0]; node.predicate = _flowParseTypeAndPred2[1]; return this.finishNode(node, "TypeAnnotation"); }; pp$8.flowParseTypeAnnotatableIdentifier = function () { var ident = this.flowParseRestrictedIdentifier(); if (this.match(types.colon)) { ident.typeAnnotation = this.flowParseTypeAnnotation(); this.finishNode(ident, ident.type); } return ident; }; pp$8.typeCastToParameter = function (node) { node.expression.typeAnnotation = node.typeAnnotation; return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end); }; pp$8.flowParseVariance = function () { var variance = null; if (this.match(types.plusMin)) { if (this.state.value === "+") { variance = "plus"; } else if (this.state.value === "-") { variance = "minus"; } this.next(); } return variance; }; var flowPlugin = function flowPlugin(instance) { // plain function return types: function name(): string {} instance.extend("parseFunctionBody", function (inner) { return function (node, allowExpression) { if (this.match(types.colon) && !allowExpression) { // if allowExpression is true then we're parsing an arrow function and if // there's a return type then it's been handled elsewhere node.returnType = this.flowParseTypeAndPredicateAnnotation(); } return inner.call(this, node, allowExpression); }; }); // interfaces instance.extend("parseStatement", function (inner) { return function (declaration, topLevel) { // strict mode handling of `interface` since it's a reserved word if (this.state.strict && this.match(types.name) && this.state.value === "interface") { var node = this.startNode(); this.next(); return this.flowParseInterface(node); } else { return inner.call(this, declaration, topLevel); } }; }); // declares, interfaces and type aliases instance.extend("parseExpressionStatement", function (inner) { return function (node, expr) { if (expr.type === "Identifier") { if (expr.name === "declare") { if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) { return this.flowParseDeclare(node); } } else if (this.match(types.name)) { if (expr.name === "interface") { return this.flowParseInterface(node); } else if (expr.name === "type") { return this.flowParseTypeAlias(node); } else if (expr.name === "opaque") { return this.flowParseOpaqueType(node, false); } } } return inner.call(this, node, expr); }; }); // export type instance.extend("shouldParseExportDeclaration", function (inner) { return function () { return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || inner.call(this); }; }); instance.extend("isExportDefaultSpecifier", function (inner) { return function () { if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque")) { return false; } return inner.call(this); }; }); instance.extend("parseConditional", function (inner) { return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) { // only do the expensive clone if there is a question mark // and if we come from inside parens if (refNeedsArrowPos && this.match(types.question)) { var state = this.state.clone(); try { return inner.call(this, expr, noIn, startPos, startLoc); } catch (err) { if (err instanceof SyntaxError) { this.state = state; refNeedsArrowPos.start = err.pos || this.state.start; return expr; } else { // istanbul ignore next: no such error is expected throw err; } } } return inner.call(this, expr, noIn, startPos, startLoc); }; }); instance.extend("parseParenItem", function (inner) { return function (node, startPos, startLoc) { node = inner.call(this, node, startPos, startLoc); if (this.eat(types.question)) { node.optional = true; } if (this.match(types.colon)) { var typeCastNode = this.startNodeAt(startPos, startLoc); typeCastNode.expression = node; typeCastNode.typeAnnotation = this.flowParseTypeAnnotation(); return this.finishNode(typeCastNode, "TypeCastExpression"); } return node; }; }); instance.extend("parseExport", function (inner) { return function (node) { node = inner.call(this, node); if (node.type === "ExportNamedDeclaration") { node.exportKind = node.exportKind || "value"; } return node; }; }); instance.extend("parseExportDeclaration", function (inner) { return function (node) { if (this.isContextual("type")) { node.exportKind = "type"; var declarationNode = this.startNode(); this.next(); if (this.match(types.braceL)) { // export type { foo, bar }; node.specifiers = this.parseExportSpecifiers(); this.parseExportFrom(node); return null; } else { // export type Foo = Bar; return this.flowParseTypeAlias(declarationNode); } } else if (this.isContextual("opaque")) { node.exportKind = "type"; var _declarationNode = this.startNode(); this.next(); // export opaque type Foo = Bar; return this.flowParseOpaqueType(_declarationNode, false); } else if (this.isContextual("interface")) { node.exportKind = "type"; var _declarationNode2 = this.startNode(); this.next(); return this.flowParseInterface(_declarationNode2); } else { return inner.call(this, node); } }; }); instance.extend("parseClassId", function (inner) { return function (node) { inner.apply(this, arguments); if (this.isRelational("<")) { node.typeParameters = this.flowParseTypeParameterDeclaration(); } }; }); // don't consider `void` to be a keyword as then it'll use the void token type // and set startExpr instance.extend("isKeyword", function (inner) { return function (name) { if (this.state.inType && name === "void") { return false; } else { return inner.call(this, name); } }; }); // ensure that inside flow types, we bypass the jsx parser plugin instance.extend("readToken", function (inner) { return function (code) { if (this.state.inType && (code === 62 || code === 60)) { return this.finishOp(types.relational, 1); } else { return inner.call(this, code); } }; }); // don't lex any token as a jsx one inside a flow type instance.extend("jsx_readToken", function (inner) { return function () { if (!this.state.inType) return inner.call(this); }; }); instance.extend("toAssignable", function (inner) { return function (node, isBinding, contextDescription) { if (node.type === "TypeCastExpression") { return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription); } else { return inner.call(this, node, isBinding, contextDescription); } }; }); // turn type casts that we found in function parameter head into type annotated params instance.extend("toAssignableList", function (inner) { return function (exprList, isBinding, contextDescription) { for (var i = 0; i < exprList.length; i++) { var expr = exprList[i]; if (expr && expr.type === "TypeCastExpression") { exprList[i] = this.typeCastToParameter(expr); } } return inner.call(this, exprList, isBinding, contextDescription); }; }); // this is a list of nodes, from something like a call expression, we need to filter the // type casts that we've found that are illegal in this context instance.extend("toReferencedList", function () { return function (exprList) { for (var i = 0; i < exprList.length; i++) { var expr = exprList[i]; if (expr && expr._exprListItem && expr.type === "TypeCastExpression") { this.raise(expr.start, "Unexpected type cast"); } } return exprList; }; }); // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents // the position where this function is called instance.extend("parseExprListItem", function (inner) { return function () { var container = this.startNode(); for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) { args[_key] = arguments[_key]; } var node = inner.call.apply(inner, [this].concat(args)); if (this.match(types.colon)) { container._exprListItem = true; container.expression = node; container.typeAnnotation = this.flowParseTypeAnnotation(); return this.finishNode(container, "TypeCastExpression"); } else { return node; } }; }); instance.extend("checkLVal", function (inner) { return function (node) { if (node.type !== "TypeCastExpression") { return inner.apply(this, arguments); } }; }); // parse class property type annotations instance.extend("parseClassProperty", function (inner) { return function (node) { delete node.variancePos; if (this.match(types.colon)) { node.typeAnnotation = this.flowParseTypeAnnotation(); } return inner.call(this, node); }; }); // determine whether or not we're currently in the position where a class method would appear instance.extend("isClassMethod", function (inner) { return function () { return this.isRelational("<") || inner.call(this); }; }); // determine whether or not we're currently in the position where a class property would appear instance.extend("isClassProperty", function (inner) { return function () { return this.match(types.colon) || inner.call(this); }; }); instance.extend("isNonstaticConstructor", function (inner) { return function (method) { return !this.match(types.colon) && inner.call(this, method); }; }); // parse type parameters for class methods instance.extend("parseClassMethod", function (inner) { return function (classBody, method) { if (method.variance) { this.unexpected(method.variancePos); } delete method.variance; delete method.variancePos; if (this.isRelational("<")) { method.typeParameters = this.flowParseTypeParameterDeclaration(); } for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) { args[_key2 - 2] = arguments[_key2]; } inner.call.apply(inner, [this, classBody, method].concat(args)); }; }); // parse a the super class type parameters and implements instance.extend("parseClassSuper", function (inner) { return function (node, isStatement) { inner.call(this, node, isStatement); if (node.superClass && this.isRelational("<")) { node.superTypeParameters = this.flowParseTypeParameterInstantiation(); } if (this.isContextual("implements")) { this.next(); var implemented = node.implements = []; do { var _node = this.startNode(); _node.id = this.parseIdentifier(); if (this.isRelational("<")) { _node.typeParameters = this.flowParseTypeParameterInstantiation(); } else { _node.typeParameters = null; } implemented.push(this.finishNode(_node, "ClassImplements")); } while (this.eat(types.comma)); } }; }); instance.extend("parsePropertyName", function (inner) { return function (node) { var variancePos = this.state.start; var variance = this.flowParseVariance(); var key = inner.call(this, node); node.variance = variance; node.variancePos = variancePos; return key; }; }); // parse type parameters for object method shorthand instance.extend("parseObjPropValue", function (inner) { return function (prop) { if (prop.variance) { this.unexpected(prop.variancePos); } delete prop.variance; delete prop.variancePos; var typeParameters = void 0; // method shorthand if (this.isRelational("<")) { typeParameters = this.flowParseTypeParameterDeclaration(); if (!this.match(types.parenL)) this.unexpected(); } inner.apply(this, arguments); // add typeParameters if we found them if (typeParameters) { (prop.value || prop).typeParameters = typeParameters; } }; }); instance.extend("parseAssignableListItemTypes", function () { return function (param) { if (this.eat(types.question)) { param.optional = true; } if (this.match(types.colon)) { param.typeAnnotation = this.flowParseTypeAnnotation(); } this.finishNode(param, param.type); return param; }; }); instance.extend("parseMaybeDefault", function (inner) { return function () { for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) { args[_key3] = arguments[_key3]; } var node = inner.apply(this, args); if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) { this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`"); } return node; }; }); // parse typeof and type imports instance.extend("parseImportSpecifiers", function (inner) { return function (node) { node.importKind = "value"; var kind = null; if (this.match(types._typeof)) { kind = "typeof"; } else if (this.isContextual("type")) { kind = "type"; } if (kind) { var lh = this.lookahead(); if (lh.type === types.name && lh.value !== "from" || lh.type === types.braceL || lh.type === types.star) { this.next(); node.importKind = kind; } } inner.call(this, node); }; }); // parse import-type/typeof shorthand instance.extend("parseImportSpecifier", function () { return function (node) { var specifier = this.startNode(); var firstIdentLoc = this.state.start; var firstIdent = this.parseIdentifier(true); var specifierTypeKind = null; if (firstIdent.name === "type") { specifierTypeKind = "type"; } else if (firstIdent.name === "typeof") { specifierTypeKind = "typeof"; } var isBinding = false; if (this.isContextual("as")) { var as_ident = this.parseIdentifier(true); if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) { // `import {type as ,` or `import {type as }` specifier.imported = as_ident; specifier.importKind = specifierTypeKind; specifier.local = as_ident.__clone(); } else { // `import {type as foo` specifier.imported = firstIdent; specifier.importKind = null; specifier.local = this.parseIdentifier(); } } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) { // `import {type foo` specifier.imported = this.parseIdentifier(true); specifier.importKind = specifierTypeKind; if (this.eatContextual("as")) { specifier.local = this.parseIdentifier(); } else { isBinding = true; specifier.local = specifier.imported.__clone(); } } else { isBinding = true; specifier.imported = firstIdent; specifier.importKind = null; specifier.local = specifier.imported.__clone(); } if ((node.importKind === "type" || node.importKind === "typeof") && (specifier.importKind === "type" || specifier.importKind === "typeof")) { this.raise(firstIdentLoc, "`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`"); } if (isBinding) this.checkReservedWord(specifier.local.name, specifier.start, true, true); this.checkLVal(specifier.local, true, undefined, "import specifier"); node.specifiers.push(this.finishNode(specifier, "ImportSpecifier")); }; }); // parse function type parameters - function foo<T>() {} instance.extend("parseFunctionParams", function (inner) { return function (node) { if (this.isRelational("<")) { node.typeParameters = this.flowParseTypeParameterDeclaration(); } inner.call(this, node); }; }); // parse flow type annotations on variable declarator heads - let foo: string = bar instance.extend("parseVarHead", function (inner) { return function (decl) { inner.call(this, decl); if (this.match(types.colon)) { decl.id.typeAnnotation = this.flowParseTypeAnnotation(); this.finishNode(decl.id, decl.id.type); } }; }); // parse the return type of an async arrow function - let foo = (async (): number => {}); instance.extend("parseAsyncArrowFromCallExpression", function (inner) { return function (node, call) { if (this.match(types.colon)) { var oldNoAnonFunctionType = this.state.noAnonFunctionType; this.state.noAnonFunctionType = true; node.returnType = this.flowParseTypeAnnotation(); this.state.noAnonFunctionType = oldNoAnonFunctionType; } return inner.call(this, node, call); }; }); // todo description instance.extend("shouldParseAsyncArrow", function (inner) { return function () { return this.match(types.colon) || inner.call(this); }; }); // We need to support type parameter declarations for arrow functions. This // is tricky. There are three situations we need to handle // // 1. This is either JSX or an arrow function. We'll try JSX first. If that // fails, we'll try an arrow function. If that fails, we'll throw the JSX // error. // 2. This is an arrow function. We'll parse the type parameter declaration, // parse the rest, make sure the rest is an arrow function, and go from // there // 3. This is neither. Just call the inner function instance.extend("parseMaybeAssign", function (inner) { return function () { var jsxError = null; for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) { args[_key4] = arguments[_key4]; } if (types.jsxTagStart && this.match(types.jsxTagStart)) { var state = this.state.clone(); try { return inner.apply(this, args); } catch (err) { if (err instanceof SyntaxError) { this.state = state; // Remove `tc.j_expr` and `tc.j_oTag` from context added // by parsing `jsxTagStart` to stop the JSX plugin from // messing with the tokens this.state.context.length -= 2; jsxError = err; } else { // istanbul ignore next: no such error is expected throw err; } } } if (jsxError != null || this.isRelational("<")) { var arrowExpression = void 0; var typeParameters = void 0; try { typeParameters = this.flowParseTypeParameterDeclaration(); arrowExpression = inner.apply(this, args); arrowExpression.typeParameters = typeParameters; arrowExpression.start = typeParameters.start; arrowExpression.loc.start = typeParameters.loc.start; } catch (err) { throw jsxError || err; } if (arrowExpression.type === "ArrowFunctionExpression") { return arrowExpression; } else if (jsxError != null) { throw jsxError; } else { this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration"); } } return inner.apply(this, args); }; }); // handle return types for arrow functions instance.extend("parseArrow", function (inner) { return function (node) { if (this.match(types.colon)) { var state = this.state.clone(); try { var oldNoAnonFunctionType = this.state.noAnonFunctionType; this.state.noAnonFunctionType = true; var returnType = this.flowParseTypeAndPredicateAnnotation(); this.state.noAnonFunctionType = oldNoAnonFunctionType; if (this.canInsertSemicolon()) this.unexpected(); if (!this.match(types.arrow)) this.unexpected(); // assign after it is clear it is an arrow node.returnType = returnType; } catch (err) { if (err instanceof SyntaxError) { this.state = state; } else { // istanbul ignore next: no such error is expected throw err; } } } return inner.call(this, node); }; }); instance.extend("shouldParseArrow", function (inner) { return function () { return this.match(types.colon) || inner.call(this); }; }); }; // Adapted from String.fromcodepoint to export the function without modifying String /*! https://mths.be/fromcodepoint v0.2.1 by @mathias */ // The MIT License (MIT) // Copyright (c) Mathias Bynens // // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and // associated documentation files (the "Software"), to deal in the Software without restriction, // including without limitation the rights to use, copy, modify, merge, publish, distribute, // sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in all copies or // substantial portions of the Software. // // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT // NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. var fromCodePoint = String.fromCodePoint; if (!fromCodePoint) { var stringFromCharCode = String.fromCharCode; var floor = Math.floor; fromCodePoint = function fromCodePoint() { var MAX_SIZE = 0x4000; var codeUnits = []; var highSurrogate = void 0; var lowSurrogate = void 0; var index = -1; var length = arguments.length; if (!length) { return ""; } var result = ""; while (++index < length) { var codePoint = Number(arguments[index]); if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity` codePoint < 0 || // not a valid Unicode code point codePoint > 0x10FFFF || // not a valid Unicode code point floor(codePoint) != codePoint // not an integer ) { throw RangeError("Invalid code point: " + codePoint); } if (codePoint <= 0xFFFF) { // BMP code point codeUnits.push(codePoint); } else { // Astral code point; split in surrogate halves // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae codePoint -= 0x10000; highSurrogate = (codePoint >> 10) + 0xD800; lowSurrogate = codePoint % 0x400 + 0xDC00; codeUnits.push(highSurrogate, lowSurrogate); } if (index + 1 == length || codeUnits.length > MAX_SIZE) { result += stringFromCharCode.apply(null, codeUnits); codeUnits.length = 0; } } return result; }; } var fromCodePoint$1 = fromCodePoint; var XHTMLEntities = { quot: "\"", amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: '\u0152', oelig: '\u0153', Scaron: '\u0160', scaron: '\u0161', Yuml: '\u0178', fnof: '\u0192', circ: '\u02C6', tilde: '\u02DC', Alpha: '\u0391', Beta: '\u0392', Gamma: '\u0393', Delta: '\u0394', Epsilon: '\u0395', Zeta: '\u0396', Eta: '\u0397', Theta: '\u0398', Iota: '\u0399', Kappa: '\u039A', Lambda: '\u039B', Mu: '\u039C', Nu: '\u039D', Xi: '\u039E', Omicron: '\u039F', Pi: '\u03A0', Rho: '\u03A1', Sigma: '\u03A3', Tau: '\u03A4', Upsilon: '\u03A5', Phi: '\u03A6', Chi: '\u03A7', Psi: '\u03A8', Omega: '\u03A9', alpha: '\u03B1', beta: '\u03B2', gamma: '\u03B3', delta: '\u03B4', epsilon: '\u03B5', zeta: '\u03B6', eta: '\u03B7', theta: '\u03B8', iota: '\u03B9', kappa: '\u03BA', lambda: '\u03BB', mu: '\u03BC', nu: '\u03BD', xi: '\u03BE', omicron: '\u03BF', pi: '\u03C0', rho: '\u03C1', sigmaf: '\u03C2', sigma: '\u03C3', tau: '\u03C4', upsilon: '\u03C5', phi: '\u03C6', chi: '\u03C7', psi: '\u03C8', omega: '\u03C9', thetasym: '\u03D1', upsih: '\u03D2', piv: '\u03D6', ensp: '\u2002', emsp: '\u2003', thinsp: '\u2009', zwnj: '\u200C', zwj: '\u200D', lrm: '\u200E', rlm: '\u200F', ndash: '\u2013', mdash: '\u2014', lsquo: '\u2018', rsquo: '\u2019', sbquo: '\u201A', ldquo: '\u201C', rdquo: '\u201D', bdquo: '\u201E', dagger: '\u2020', Dagger: '\u2021', bull: '\u2022', hellip: '\u2026', permil: '\u2030', prime: '\u2032', Prime: '\u2033', lsaquo: '\u2039', rsaquo: '\u203A', oline: '\u203E', frasl: '\u2044', euro: '\u20AC', image: '\u2111', weierp: '\u2118', real: '\u211C', trade: '\u2122', alefsym: '\u2135', larr: '\u2190', uarr: '\u2191', rarr: '\u2192', darr: '\u2193', harr: '\u2194', crarr: '\u21B5', lArr: '\u21D0', uArr: '\u21D1', rArr: '\u21D2', dArr: '\u21D3', hArr: '\u21D4', forall: '\u2200', part: '\u2202', exist: '\u2203', empty: '\u2205', nabla: '\u2207', isin: '\u2208', notin: '\u2209', ni: '\u220B', prod: '\u220F', sum: '\u2211', minus: '\u2212', lowast: '\u2217', radic: '\u221A', prop: '\u221D', infin: '\u221E', ang: '\u2220', and: '\u2227', or: '\u2228', cap: '\u2229', cup: '\u222A', "int": '\u222B', there4: '\u2234', sim: '\u223C', cong: '\u2245', asymp: '\u2248', ne: '\u2260', equiv: '\u2261', le: '\u2264', ge: '\u2265', sub: '\u2282', sup: '\u2283', nsub: '\u2284', sube: '\u2286', supe: '\u2287', oplus: '\u2295', otimes: '\u2297', perp: '\u22A5', sdot: '\u22C5', lceil: '\u2308', rceil: '\u2309', lfloor: '\u230A', rfloor: '\u230B', lang: '\u2329', rang: '\u232A', loz: '\u25CA', spades: '\u2660', clubs: '\u2663', hearts: '\u2665', diams: '\u2666' }; var HEX_NUMBER = /^[\da-fA-F]+$/; var DECIMAL_NUMBER = /^\d+$/; types$1.j_oTag = new TokContext("<tag", false); types$1.j_cTag = new TokContext("</tag", false); types$1.j_expr = new TokContext("<tag>...</tag>", true, true); types.jsxName = new TokenType("jsxName"); types.jsxText = new TokenType("jsxText", { beforeExpr: true }); types.jsxTagStart = new TokenType("jsxTagStart", { startsExpr: true }); types.jsxTagEnd = new TokenType("jsxTagEnd"); types.jsxTagStart.updateContext = function () { this.state.context.push(types$1.j_expr); // treat as beginning of JSX expression this.state.context.push(types$1.j_oTag); // start opening tag context this.state.exprAllowed = false; }; types.jsxTagEnd.updateContext = function (prevType) { var out = this.state.context.pop(); if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) { this.state.context.pop(); this.state.exprAllowed = this.curContext() === types$1.j_expr; } else { this.state.exprAllowed = true; } }; var pp$9 = Parser.prototype; // Reads inline JSX contents token. pp$9.jsxReadToken = function () { var out = ""; var chunkStart = this.state.pos; for (;;) { if (this.state.pos >= this.input.length) { this.raise(this.state.start, "Unterminated JSX contents"); } var ch = this.input.charCodeAt(this.state.pos); switch (ch) { case 60: // "<" case 123: // "{" if (this.state.pos === this.state.start) { if (ch === 60 && this.state.exprAllowed) { ++this.state.pos; return this.finishToken(types.jsxTagStart); } return this.getTokenFromCode(ch); } out += this.input.slice(chunkStart, this.state.pos); return this.finishToken(types.jsxText, out); case 38: // "&" out += this.input.slice(chunkStart, this.state.pos); out += this.jsxReadEntity(); chunkStart = this.state.pos; break; default: if (isNewLine(ch)) { out += this.input.slice(chunkStart, this.state.pos); out += this.jsxReadNewLine(true); chunkStart = this.state.pos; } else { ++this.state.pos; } } } }; pp$9.jsxReadNewLine = function (normalizeCRLF) { var ch = this.input.charCodeAt(this.state.pos); var out = void 0; ++this.state.pos; if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) { ++this.state.pos; out = normalizeCRLF ? "\n" : "\r\n"; } else { out = String.fromCharCode(ch); } ++this.state.curLine; this.state.lineStart = this.state.pos; return out; }; pp$9.jsxReadString = function (quote) { var out = ""; var chunkStart = ++this.state.pos; for (;;) { if (this.state.pos >= this.input.length) { this.raise(this.state.start, "Unterminated string constant"); } var ch = this.input.charCodeAt(this.state.pos); if (ch === quote) break; if (ch === 38) { // "&" out += this.input.slice(chunkStart, this.state.pos); out += this.jsxReadEntity(); chunkStart = this.state.pos; } else if (isNewLine(ch)) { out += this.input.slice(chunkStart, this.state.pos); out += this.jsxReadNewLine(false); chunkStart = this.state.pos; } else { ++this.state.pos; } } out += this.input.slice(chunkStart, this.state.pos++); return this.finishToken(types.string, out); }; pp$9.jsxReadEntity = function () { var str = ""; var count = 0; var entity = void 0; var ch = this.input[this.state.pos]; var startPos = ++this.state.pos; while (this.state.pos < this.input.length && count++ < 10) { ch = this.input[this.state.pos++]; if (ch === ";") { if (str[0] === "#") { if (str[1] === "x") { str = str.substr(2); if (HEX_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 16)); } else { str = str.substr(1); if (DECIMAL_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 10)); } } else { entity = XHTMLEntities[str]; } break; } str += ch; } if (!entity) { this.state.pos = startPos; return "&"; } return entity; }; // Read a JSX identifier (valid tag or attribute name). // // Optimized version since JSX identifiers can"t contain // escape characters and so can be read as single slice. // Also assumes that first character was already checked // by isIdentifierStart in readToken. pp$9.jsxReadWord = function () { var ch = void 0; var start = this.state.pos; do { ch = this.input.charCodeAt(++this.state.pos); } while (isIdentifierChar(ch) || ch === 45); // "-" return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos)); }; // Transforms JSX element name to string. function getQualifiedJSXName(object) { if (object.type === "JSXIdentifier") { return object.name; } if (object.type === "JSXNamespacedName") { return object.namespace.name + ":" + object.name.name; } if (object.type === "JSXMemberExpression") { return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property); } } // Parse next token as JSX identifier pp$9.jsxParseIdentifier = function () { var node = this.startNode(); if (this.match(types.jsxName)) { node.name = this.state.value; } else if (this.state.type.keyword) { node.name = this.state.type.keyword; } else { this.unexpected(); } this.next(); return this.finishNode(node, "JSXIdentifier"); }; // Parse namespaced identifier. pp$9.jsxParseNamespacedName = function () { var startPos = this.state.start; var startLoc = this.state.startLoc; var name = this.jsxParseIdentifier(); if (!this.eat(types.colon)) return name; var node = this.startNodeAt(startPos, startLoc); node.namespace = name; node.name = this.jsxParseIdentifier(); return this.finishNode(node, "JSXNamespacedName"); }; // Parses element name in any form - namespaced, member // or single identifier. pp$9.jsxParseElementName = function () { var startPos = this.state.start; var startLoc = this.state.startLoc; var node = this.jsxParseNamespacedName(); while (this.eat(types.dot)) { var newNode = this.startNodeAt(startPos, startLoc); newNode.object = node; newNode.property = this.jsxParseIdentifier(); node = this.finishNode(newNode, "JSXMemberExpression"); } return node; }; // Parses any type of JSX attribute value. pp$9.jsxParseAttributeValue = function () { var node = void 0; switch (this.state.type) { case types.braceL: node = this.jsxParseExpressionContainer(); if (node.expression.type === "JSXEmptyExpression") { this.raise(node.start, "JSX attributes must only be assigned a non-empty expression"); } else { return node; } case types.jsxTagStart: case types.string: node = this.parseExprAtom(); node.extra = null; return node; default: this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text"); } }; // JSXEmptyExpression is unique type since it doesn't actually parse anything, // and so it should start at the end of last read token (left brace) and finish // at the beginning of the next one (right brace). pp$9.jsxParseEmptyExpression = function () { var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc); return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc); }; // Parse JSX spread child pp$9.jsxParseSpreadChild = function () { var node = this.startNode(); this.expect(types.braceL); this.expect(types.ellipsis); node.expression = this.parseExpression(); this.expect(types.braceR); return this.finishNode(node, "JSXSpreadChild"); }; // Parses JSX expression enclosed into curly brackets. pp$9.jsxParseExpressionContainer = function () { var node = this.startNode(); this.next(); if (this.match(types.braceR)) { node.expression = this.jsxParseEmptyExpression(); } else { node.expression = this.parseExpression(); } this.expect(types.braceR); return this.finishNode(node, "JSXExpressionContainer"); }; // Parses following JSX attribute name-value pair. pp$9.jsxParseAttribute = function () { var node = this.startNode(); if (this.eat(types.braceL)) { this.expect(types.ellipsis); node.argument = this.parseMaybeAssign(); this.expect(types.braceR); return this.finishNode(node, "JSXSpreadAttribute"); } node.name = this.jsxParseNamespacedName(); node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null; return this.finishNode(node, "JSXAttribute"); }; // Parses JSX opening tag starting after "<". pp$9.jsxParseOpeningElementAt = function (startPos, startLoc) { var node = this.startNodeAt(startPos, startLoc); node.attributes = []; node.name = this.jsxParseElementName(); while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) { node.attributes.push(this.jsxParseAttribute()); } node.selfClosing = this.eat(types.slash); this.expect(types.jsxTagEnd); return this.finishNode(node, "JSXOpeningElement"); }; // Parses JSX closing tag starting after "</". pp$9.jsxParseClosingElementAt = function (startPos, startLoc) { var node = this.startNodeAt(startPos, startLoc); node.name = this.jsxParseElementName(); this.expect(types.jsxTagEnd); return this.finishNode(node, "JSXClosingElement"); }; // Parses entire JSX element, including it"s opening tag // (starting after "<"), attributes, contents and closing tag. pp$9.jsxParseElementAt = function (startPos, startLoc) { var node = this.startNodeAt(startPos, startLoc); var children = []; var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc); var closingElement = null; if (!openingElement.selfClosing) { contents: for (;;) { switch (this.state.type) { case types.jsxTagStart: startPos = this.state.start;startLoc = this.state.startLoc; this.next(); if (this.eat(types.slash)) { closingElement = this.jsxParseClosingElementAt(startPos, startLoc); break contents; } children.push(this.jsxParseElementAt(startPos, startLoc)); break; case types.jsxText: children.push(this.parseExprAtom()); break; case types.braceL: if (this.lookahead().type === types.ellipsis) { children.push(this.jsxParseSpreadChild()); } else { children.push(this.jsxParseExpressionContainer()); } break; // istanbul ignore next - should never happen default: this.unexpected(); } } if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) { this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"); } } node.openingElement = openingElement; node.closingElement = closingElement; node.children = children; if (this.match(types.relational) && this.state.value === "<") { this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag"); } return this.finishNode(node, "JSXElement"); }; // Parses entire JSX element from current position. pp$9.jsxParseElement = function () { var startPos = this.state.start; var startLoc = this.state.startLoc; this.next(); return this.jsxParseElementAt(startPos, startLoc); }; var jsxPlugin = function jsxPlugin(instance) { instance.extend("parseExprAtom", function (inner) { return function (refShortHandDefaultPos) { if (this.match(types.jsxText)) { var node = this.parseLiteral(this.state.value, "JSXText"); // https://github.com/babel/babel/issues/2078 node.extra = null; return node; } else if (this.match(types.jsxTagStart)) { return this.jsxParseElement(); } else { return inner.call(this, refShortHandDefaultPos); } }; }); instance.extend("readToken", function (inner) { return function (code) { if (this.state.inPropertyName) return inner.call(this, code); var context = this.curContext(); if (context === types$1.j_expr) { return this.jsxReadToken(); } if (context === types$1.j_oTag || context === types$1.j_cTag) { if (isIdentifierStart(code)) { return this.jsxReadWord(); } if (code === 62) { ++this.state.pos; return this.finishToken(types.jsxTagEnd); } if ((code === 34 || code === 39) && context === types$1.j_oTag) { return this.jsxReadString(code); } } if (code === 60 && this.state.exprAllowed) { ++this.state.pos; return this.finishToken(types.jsxTagStart); } return inner.call(this, code); }; }); instance.extend("updateContext", function (inner) { return function (prevType) { if (this.match(types.braceL)) { var curContext = this.curContext(); if (curContext === types$1.j_oTag) { this.state.context.push(types$1.braceExpression); } else if (curContext === types$1.j_expr) { this.state.context.push(types$1.templateQuasi); } else { inner.call(this, prevType); } this.state.exprAllowed = true; } else if (this.match(types.slash) && prevType === types.jsxTagStart) { this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore this.state.context.push(types$1.j_cTag); // reconsider as closing tag context this.state.exprAllowed = false; } else { return inner.call(this, prevType); } }; }); }; plugins.estree = estreePlugin; plugins.flow = flowPlugin; plugins.jsx = jsxPlugin; function parse(input, options) { return new Parser(options, input).parse(); } function parseExpression(input, options) { var parser = new Parser(options, input); if (parser.options.strictMode) { parser.state.strict = true; } return parser.getExpression(); } exports.parse = parse; exports.parseExpression = parseExpression; exports.tokTypes = types; /***/ }), /* 90 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) var anObject = __webpack_require__(21); var dPs = __webpack_require__(431); var enumBugKeys = __webpack_require__(141); var IE_PROTO = __webpack_require__(150)('IE_PROTO'); var Empty = function Empty() {/* empty */}; var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype var _createDict = function createDict() { // Thrash, waste and sodomy: IE GC bug var iframe = __webpack_require__(230)('iframe'); var i = enumBugKeys.length; var lt = '<'; var gt = '>'; var iframeDocument; iframe.style.display = 'none'; __webpack_require__(426).appendChild(iframe); iframe.src = 'javascript:'; // eslint-disable-line no-script-url // createDict = iframe.contentWindow.Object; // html.removeChild(iframe); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt); iframeDocument.close(); _createDict = iframeDocument.F; while (i--) { delete _createDict[PROTOTYPE][enumBugKeys[i]]; }return _createDict(); }; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { Empty[PROTOTYPE] = anObject(O); result = new Empty(); Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill result[IE_PROTO] = O; } else result = _createDict(); return Properties === undefined ? result : dPs(result, Properties); }; /***/ }), /* 91 */ /***/ (function(module, exports) { "use strict"; exports.f = {}.propertyIsEnumerable; /***/ }), /* 92 */ /***/ (function(module, exports) { "use strict"; module.exports = function (bitmap, value) { return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value: value }; }; /***/ }), /* 93 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var def = __webpack_require__(23).f; var has = __webpack_require__(28); var TAG = __webpack_require__(13)('toStringTag'); module.exports = function (it, tag, stat) { if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag }); }; /***/ }), /* 94 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 7.1.13 ToObject(argument) var defined = __webpack_require__(140); module.exports = function (it) { return Object(defined(it)); }; /***/ }), /* 95 */ /***/ (function(module, exports) { 'use strict'; var id = 0; var px = Math.random(); module.exports = function (key) { return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36)); }; /***/ }), /* 96 */ /***/ (function(module, exports) { "use strict"; /***/ }), /* 97 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /* Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ (function () { 'use strict'; exports.ast = __webpack_require__(461); exports.code = __webpack_require__(240); exports.keyword = __webpack_require__(462); })(); /* vim: set sw=4 ts=4 et tw=80 : */ /***/ }), /* 98 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var listCacheClear = __webpack_require__(546), listCacheDelete = __webpack_require__(547), listCacheGet = __webpack_require__(548), listCacheHas = __webpack_require__(549), listCacheSet = __webpack_require__(550); /** * Creates an list cache object. * * @private * @constructor * @param {Array} [entries] The key-value pairs to cache. */ function ListCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index < length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } // Add methods to `ListCache`. ListCache.prototype.clear = listCacheClear; ListCache.prototype['delete'] = listCacheDelete; ListCache.prototype.get = listCacheGet; ListCache.prototype.has = listCacheHas; ListCache.prototype.set = listCacheSet; module.exports = ListCache; /***/ }), /* 99 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var ListCache = __webpack_require__(98), stackClear = __webpack_require__(565), stackDelete = __webpack_require__(566), stackGet = __webpack_require__(567), stackHas = __webpack_require__(568), stackSet = __webpack_require__(569); /** * Creates a stack cache object to store key-value pairs. * * @private * @constructor * @param {Array} [entries] The key-value pairs to cache. */ function Stack(entries) { var data = this.__data__ = new ListCache(entries); this.size = data.size; } // Add methods to `Stack`. Stack.prototype.clear = stackClear; Stack.prototype['delete'] = stackDelete; Stack.prototype.get = stackGet; Stack.prototype.has = stackHas; Stack.prototype.set = stackSet; module.exports = Stack; /***/ }), /* 100 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var eq = __webpack_require__(46); /** * Gets the index at which the `key` is found in `array` of key-value pairs. * * @private * @param {Array} array The array to inspect. * @param {*} key The key to search for. * @returns {number} Returns the index of the matched value, else `-1`. */ function assocIndexOf(array, key) { var length = array.length; while (length--) { if (eq(array[length][0], key)) { return length; } } return -1; } module.exports = assocIndexOf; /***/ }), /* 101 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var identity = __webpack_require__(110), overRest = __webpack_require__(560), setToString = __webpack_require__(563); /** * The base implementation of `_.rest` which doesn't validate or coerce arguments. * * @private * @param {Function} func The function to apply a rest parameter to. * @param {number} [start=func.length-1] The start position of the rest parameter. * @returns {Function} Returns the new function. */ function baseRest(func, start) { return setToString(overRest(func, start, identity), func + ''); } module.exports = baseRest; /***/ }), /* 102 */ /***/ (function(module, exports) { "use strict"; /** * The base implementation of `_.unary` without support for storing metadata. * * @private * @param {Function} func The function to cap arguments for. * @returns {Function} Returns the new capped function. */ function baseUnary(func) { return function (value) { return func(value); }; } module.exports = baseUnary; /***/ }), /* 103 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var baseRest = __webpack_require__(101), isIterateeCall = __webpack_require__(172); /** * Creates a function like `_.assign`. * * @private * @param {Function} assigner The function to assign values. * @returns {Function} Returns the new assigner function. */ function createAssigner(assigner) { return baseRest(function (object, sources) { var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined; customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined; if (guard && isIterateeCall(sources[0], sources[1], guard)) { customizer = length < 3 ? undefined : customizer; length = 1; } object = Object(object); while (++index < length) { var source = sources[index]; if (source) { assigner(object, source, index, customizer); } } return object; }); } module.exports = createAssigner; /***/ }), /* 104 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isKeyable = __webpack_require__(544); /** * Gets the data for `map`. * * @private * @param {Object} map The map to query. * @param {string} key The reference key. * @returns {*} Returns the map data. */ function getMapData(map, key) { var data = map.__data__; return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map; } module.exports = getMapData; /***/ }), /* 105 */ /***/ (function(module, exports) { 'use strict'; /** Used for built-in method references. */ var objectProto = Object.prototype; /** * Checks if `value` is likely a prototype object. * * @private * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is a prototype, else `false`. */ function isPrototype(value) { var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto; return value === proto; } module.exports = isPrototype; /***/ }), /* 106 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var getNative = __webpack_require__(38); /* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, 'create'); module.exports = nativeCreate; /***/ }), /* 107 */ /***/ (function(module, exports) { "use strict"; /** * Converts `set` to an array of its values. * * @private * @param {Object} set The set to convert. * @returns {Array} Returns the values. */ function setToArray(set) { var index = -1, result = Array(set.size); set.forEach(function (value) { result[++index] = value; }); return result; } module.exports = setToArray; /***/ }), /* 108 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isSymbol = __webpack_require__(62); /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0; /** * Converts `value` to a string key if it's not a string or symbol. * * @private * @param {*} value The value to inspect. * @returns {string|symbol} Returns the key. */ function toKey(value) { if (typeof value == 'string' || isSymbol(value)) { return value; } var result = value + ''; return result == '0' && 1 / value == -INFINITY ? '-0' : result; } module.exports = toKey; /***/ }), /* 109 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var baseClone = __webpack_require__(164); /** Used to compose bitmasks for cloning. */ var CLONE_SYMBOLS_FLAG = 4; /** * Creates a shallow clone of `value`. * * **Note:** This method is loosely based on the * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm) * and supports cloning arrays, array buffers, booleans, date objects, maps, * numbers, `Object` objects, regexes, sets, strings, symbols, and typed * arrays. The own enumerable properties of `arguments` objects are cloned * as plain objects. An empty object is returned for uncloneable values such * as error objects, functions, DOM nodes, and WeakMaps. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to clone. * @returns {*} Returns the cloned value. * @see _.cloneDeep * @example * * var objects = [{ 'a': 1 }, { 'b': 2 }]; * * var shallow = _.clone(objects); * console.log(shallow[0] === objects[0]); * // => true */ function clone(value) { return baseClone(value, CLONE_SYMBOLS_FLAG); } module.exports = clone; /***/ }), /* 110 */ /***/ (function(module, exports) { "use strict"; /** * This method returns the first argument it receives. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {*} value Any value. * @returns {*} Returns `value`. * @example * * var object = { 'a': 1 }; * * console.log(_.identity(object) === object); * // => true */ function identity(value) { return value; } module.exports = identity; /***/ }), /* 111 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var baseIndexOf = __webpack_require__(166), isArrayLike = __webpack_require__(24), isString = __webpack_require__(587), toInteger = __webpack_require__(48), values = __webpack_require__(280); /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max; /** * Checks if `value` is in `collection`. If `collection` is a string, it's * checked for a substring of `value`, otherwise * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * is used for equality comparisons. If `fromIndex` is negative, it's used as * the offset from the end of `collection`. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object|string} collection The collection to inspect. * @param {*} value The value to search for. * @param {number} [fromIndex=0] The index to search from. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`. * @returns {boolean} Returns `true` if `value` is found, else `false`. * @example * * _.includes([1, 2, 3], 1); * // => true * * _.includes([1, 2, 3], 1, 2); * // => false * * _.includes({ 'a': 1, 'b': 2 }, 1); * // => true * * _.includes('abcd', 'bc'); * // => true */ function includes(collection, value, fromIndex, guard) { collection = isArrayLike(collection) ? collection : values(collection); fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0; var length = collection.length; if (fromIndex < 0) { fromIndex = nativeMax(length + fromIndex, 0); } return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1; } module.exports = includes; /***/ }), /* 112 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var baseIsArguments = __webpack_require__(493), isObjectLike = __webpack_require__(25); /** Used for built-in method references. */ var objectProto = Object.prototype; /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty; /** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable; /** * Checks if `value` is likely an `arguments` object. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is an `arguments` object, * else `false`. * @example * * _.isArguments(function() { return arguments; }()); * // => true * * _.isArguments([1, 2, 3]); * // => false */ var isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) { return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee'); }; module.exports = isArguments; /***/ }), /* 113 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(module) {'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; var root = __webpack_require__(17), stubFalse = __webpack_require__(596); /** Detect free variable `exports`. */ var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports; /** Detect free variable `module`. */ var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module; /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports; /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined; /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined; /** * Checks if `value` is a buffer. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is a buffer, else `false`. * @example * * _.isBuffer(new Buffer(2)); * // => true * * _.isBuffer(new Uint8Array(2)); * // => false */ var isBuffer = nativeIsBuffer || stubFalse; module.exports = isBuffer; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(39)(module))) /***/ }), /* 114 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var baseToString = __webpack_require__(253); /** * Converts `value` to a string. An empty string is returned for `null` * and `undefined` values. The sign of `-0` is preserved. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {string} Returns the converted string. * @example * * _.toString(null); * // => '' * * _.toString(-0); * // => '-0' * * _.toString([1, 2, 3]); * // => '1,2,3' */ function toString(value) { return value == null ? '' : baseToString(value); } module.exports = toString; /***/ }), /* 115 */ 96, /* 116 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.runtimeProperty = runtimeProperty; exports.isReference = isReference; exports.replaceWithOrRemove = replaceWithOrRemove; var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function runtimeProperty(name) { return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), false); } /** * Copyright (c) 2014, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * https://raw.github.com/facebook/regenerator/master/LICENSE file. An * additional grant of patent rights can be found in the PATENTS file in * the same directory. */ function isReference(path) { return path.isReferenced() || path.parentPath.isAssignmentExpression({ left: path.node }); } function replaceWithOrRemove(path, replacement) { if (replacement) { path.replaceWith(replacement); } else { path.remove(); } } /***/ }), /* 117 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global, process) {'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; // Copyright Joyent, Inc. and other Node contributors. // // Permission is hereby granted, free of charge, to any person obtaining a // copy of this software and associated documentation files (the // "Software"), to deal in the Software without restriction, including // without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to permit // persons to whom the Software is furnished to do so, subject to the // following conditions: // // The above copyright notice and this permission notice shall be included // in all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE // USE OR OTHER DEALINGS IN THE SOFTWARE. var formatRegExp = /%[sdj%]/g; exports.format = function (f) { if (!isString(f)) { var objects = []; for (var i = 0; i < arguments.length; i++) { objects.push(inspect(arguments[i])); } return objects.join(' '); } var i = 1; var args = arguments; var len = args.length; var str = String(f).replace(formatRegExp, function (x) { if (x === '%%') return '%'; if (i >= len) return x; switch (x) { case '%s': return String(args[i++]); case '%d': return Number(args[i++]); case '%j': try { return JSON.stringify(args[i++]); } catch (_) { return '[Circular]'; } default: return x; } }); for (var x = args[i]; i < len; x = args[++i]) { if (isNull(x) || !isObject(x)) { str += ' ' + x; } else { str += ' ' + inspect(x); } } return str; }; // Mark that a method should not be used. // Returns a modified function which warns once by default. // If --no-deprecation is set, then it is a no-op. exports.deprecate = function (fn, msg) { // Allow for deprecating things in the process of starting up. if (isUndefined(global.process)) { return function () { return exports.deprecate(fn, msg).apply(this, arguments); }; } if (process.noDeprecation === true) { return fn; } var warned = false; function deprecated() { if (!warned) { if (process.throwDeprecation) { throw new Error(msg); } else if (process.traceDeprecation) { console.trace(msg); } else { console.error(msg); } warned = true; } return fn.apply(this, arguments); } return deprecated; }; var debugs = {}; var debugEnviron; exports.debuglog = function (set) { if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || ''; set = set.toUpperCase(); if (!debugs[set]) { if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) { var pid = process.pid; debugs[set] = function () { var msg = exports.format.apply(exports, arguments); console.error('%s %d: %s', set, pid, msg); }; } else { debugs[set] = function () {}; } } return debugs[set]; }; /** * Echos the value of a value. Trys to print the value out * in the best way possible given the different types. * * @param {Object} obj The object to print out. * @param {Object} opts Optional options object that alters the output. */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) { // default options var ctx = { seen: [], stylize: stylizeNoColor }; // legacy... if (arguments.length >= 3) ctx.depth = arguments[2]; if (arguments.length >= 4) ctx.colors = arguments[3]; if (isBoolean(opts)) { // legacy... ctx.showHidden = opts; } else if (opts) { // got an "options" object exports._extend(ctx, opts); } // set default options if (isUndefined(ctx.showHidden)) ctx.showHidden = false; if (isUndefined(ctx.depth)) ctx.depth = 2; if (isUndefined(ctx.colors)) ctx.colors = false; if (isUndefined(ctx.customInspect)) ctx.customInspect = true; if (ctx.colors) ctx.stylize = stylizeWithColor; return formatValue(ctx, obj, ctx.depth); } exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics inspect.colors = { 'bold': [1, 22], 'italic': [3, 23], 'underline': [4, 24], 'inverse': [7, 27], 'white': [37, 39], 'grey': [90, 39], 'black': [30, 39], 'blue': [34, 39], 'cyan': [36, 39], 'green': [32, 39], 'magenta': [35, 39], 'red': [31, 39], 'yellow': [33, 39] }; // Don't use 'blue' not visible on cmd.exe inspect.styles = { 'special': 'cyan', 'number': 'yellow', 'boolean': 'yellow', 'undefined': 'grey', 'null': 'bold', 'string': 'green', 'date': 'magenta', // "name": intentionally not styling 'regexp': 'red' }; function stylizeWithColor(str, styleType) { var style = inspect.styles[styleType]; if (style) { return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm'; } else { return str; } } function stylizeNoColor(str, styleType) { return str; } function arrayToHash(array) { var hash = {}; array.forEach(function (val, idx) { hash[val] = true; }); return hash; } function formatValue(ctx, value, recurseTimes) { // Provide a hook for user-specified inspect functions. // Check that value is an object with an inspect function on it if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check. !(value.constructor && value.constructor.prototype === value)) { var ret = value.inspect(recurseTimes, ctx); if (!isString(ret)) { ret = formatValue(ctx, ret, recurseTimes); } return ret; } // Primitive types cannot have properties var primitive = formatPrimitive(ctx, value); if (primitive) { return primitive; } // Look up the keys of the object. var keys = Object.keys(value); var visibleKeys = arrayToHash(keys); if (ctx.showHidden) { keys = Object.getOwnPropertyNames(value); } // IE doesn't make error fields non-enumerable // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) { return formatError(value); } // Some type of object without properties can be shortcutted. if (keys.length === 0) { if (isFunction(value)) { var name = value.name ? ': ' + value.name : ''; return ctx.stylize('[Function' + name + ']', 'special'); } if (isRegExp(value)) { return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp'); } if (isDate(value)) { return ctx.stylize(Date.prototype.toString.call(value), 'date'); } if (isError(value)) { return formatError(value); } } var base = '', array = false, braces = ['{', '}']; // Make Array say that they are Array if (isArray(value)) { array = true; braces = ['[', ']']; } // Make functions say that they are functions if (isFunction(value)) { var n = value.name ? ': ' + value.name : ''; base = ' [Function' + n + ']'; } // Make RegExps say that they are RegExps if (isRegExp(value)) { base = ' ' + RegExp.prototype.toString.call(value); } // Make dates with properties first say the date if (isDate(value)) { base = ' ' + Date.prototype.toUTCString.call(value); } // Make error with message first say the error if (isError(value)) { base = ' ' + formatError(value); } if (keys.length === 0 && (!array || value.length == 0)) { return braces[0] + base + braces[1]; } if (recurseTimes < 0) { if (isRegExp(value)) { return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp'); } else { return ctx.stylize('[Object]', 'special'); } } ctx.seen.push(value); var output; if (array) { output = formatArray(ctx, value, recurseTimes, visibleKeys, keys); } else { output = keys.map(function (key) { return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array); }); } ctx.seen.pop(); return reduceToSingleString(output, base, braces); } function formatPrimitive(ctx, value) { if (isUndefined(value)) return ctx.stylize('undefined', 'undefined'); if (isString(value)) { var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\''; return ctx.stylize(simple, 'string'); } if (isNumber(value)) return ctx.stylize('' + value, 'number'); if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here. if (isNull(value)) return ctx.stylize('null', 'null'); } function formatError(value) { return '[' + Error.prototype.toString.call(value) + ']'; } function formatArray(ctx, value, recurseTimes, visibleKeys, keys) { var output = []; for (var i = 0, l = value.length; i < l; ++i) { if (hasOwnProperty(value, String(i))) { output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true)); } else { output.push(''); } } keys.forEach(function (key) { if (!key.match(/^\d+$/)) { output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true)); } }); return output; } function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) { var name, str, desc; desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }; if (desc.get) { if (desc.set) { str = ctx.stylize('[Getter/Setter]', 'special'); } else { str = ctx.stylize('[Getter]', 'special'); } } else { if (desc.set) { str = ctx.stylize('[Setter]', 'special'); } } if (!hasOwnProperty(visibleKeys, key)) { name = '[' + key + ']'; } if (!str) { if (ctx.seen.indexOf(desc.value) < 0) { if (isNull(recurseTimes)) { str = formatValue(ctx, desc.value, null); } else { str = formatValue(ctx, desc.value, recurseTimes - 1); } if (str.indexOf('\n') > -1) { if (array) { str = str.split('\n').map(function (line) { return ' ' + line; }).join('\n').substr(2); } else { str = '\n' + str.split('\n').map(function (line) { return ' ' + line; }).join('\n'); } } } else { str = ctx.stylize('[Circular]', 'special'); } } if (isUndefined(name)) { if (array && key.match(/^\d+$/)) { return str; } name = JSON.stringify('' + key); if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) { name = name.substr(1, name.length - 2); name = ctx.stylize(name, 'name'); } else { name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"); name = ctx.stylize(name, 'string'); } } return name + ': ' + str; } function reduceToSingleString(output, base, braces) { var numLinesEst = 0; var length = output.reduce(function (prev, cur) { numLinesEst++; if (cur.indexOf('\n') >= 0) numLinesEst++; return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1; }, 0); if (length > 60) { return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n ') + ' ' + braces[1]; } return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]; } // NOTE: These type checking functions intentionally don't use `instanceof` // because it is fragile and can be easily faked with `Object.create()`. function isArray(ar) { return Array.isArray(ar); } exports.isArray = isArray; function isBoolean(arg) { return typeof arg === 'boolean'; } exports.isBoolean = isBoolean; function isNull(arg) { return arg === null; } exports.isNull = isNull; function isNullOrUndefined(arg) { return arg == null; } exports.isNullOrUndefined = isNullOrUndefined; function isNumber(arg) { return typeof arg === 'number'; } exports.isNumber = isNumber; function isString(arg) { return typeof arg === 'string'; } exports.isString = isString; function isSymbol(arg) { return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol'; } exports.isSymbol = isSymbol; function isUndefined(arg) { return arg === void 0; } exports.isUndefined = isUndefined; function isRegExp(re) { return isObject(re) && objectToString(re) === '[object RegExp]'; } exports.isRegExp = isRegExp; function isObject(arg) { return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null; } exports.isObject = isObject; function isDate(d) { return isObject(d) && objectToString(d) === '[object Date]'; } exports.isDate = isDate; function isError(e) { return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error); } exports.isError = isError; function isFunction(arg) { return typeof arg === 'function'; } exports.isFunction = isFunction; function isPrimitive(arg) { return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol typeof arg === 'undefined'; } exports.isPrimitive = isPrimitive; exports.isBuffer = __webpack_require__(627); function objectToString(o) { return Object.prototype.toString.call(o); } function pad(n) { return n < 10 ? '0' + n.toString(10) : n.toString(10); } var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34 function timestamp() { var d = new Date(); var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':'); return [d.getDate(), months[d.getMonth()], time].join(' '); } // log is just a thin wrapper to console.log that prepends a timestamp exports.log = function () { console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments)); }; /** * Inherit the prototype methods from one constructor into another. * * The Function.prototype.inherits from lang.js rewritten as a standalone * function (not on Function.prototype). NOTE: If this file is to be loaded * during bootstrapping this function needs to be rewritten using some native * functions as prototype setup using normal JavaScript does not work as * expected during bootstrapping (see mirror.js in r114903). * * @param {function} ctor Constructor function which needs to inherit the * prototype. * @param {function} superCtor Constructor function to inherit prototype from. */ exports.inherits = __webpack_require__(626); exports._extend = function (origin, add) { // Don't do anything if add isn't an object if (!add || !isObject(add)) return origin; var keys = Object.keys(add); var i = keys.length; while (i--) { origin[keys[i]] = add[keys[i]]; } return origin; }; function hasOwnProperty(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); } /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(8))) /***/ }), /* 118 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(process) {"use strict"; exports.__esModule = true; var _typeof2 = __webpack_require__(11); var _typeof3 = _interopRequireDefault(_typeof2); exports.default = function (loc) { var relative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd(); if ((typeof _module2.default === "undefined" ? "undefined" : (0, _typeof3.default)(_module2.default)) === "object") return null; var relativeMod = relativeModules[relative]; if (!relativeMod) { relativeMod = new _module2.default(); var filename = _path2.default.join(relative, ".babelrc"); relativeMod.id = filename; relativeMod.filename = filename; relativeMod.paths = _module2.default._nodeModulePaths(relative); relativeModules[relative] = relativeMod; } try { return _module2.default._resolveFilename(loc, relativeMod); } catch (err) { return null; } }; var _module = __webpack_require__(115); var _module2 = _interopRequireDefault(_module); var _path = __webpack_require__(19); var _path2 = _interopRequireDefault(_path); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var relativeModules = {}; module.exports = exports["default"]; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8))) /***/ }), /* 119 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _map = __webpack_require__(133); var _map2 = _interopRequireDefault(_map); var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); var _possibleConstructorReturn2 = __webpack_require__(42); var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2); var _inherits2 = __webpack_require__(41); var _inherits3 = _interopRequireDefault(_inherits2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var Store = function (_Map) { (0, _inherits3.default)(Store, _Map); function Store() { (0, _classCallCheck3.default)(this, Store); var _this = (0, _possibleConstructorReturn3.default)(this, _Map.call(this)); _this.dynamicData = {}; return _this; } Store.prototype.setDynamic = function setDynamic(key, fn) { this.dynamicData[key] = fn; }; Store.prototype.get = function get(key) { if (this.has(key)) { return _Map.prototype.get.call(this, key); } else { if (Object.prototype.hasOwnProperty.call(this.dynamicData, key)) { var val = this.dynamicData[key](); this.set(key, val); return val; } } }; return Store; }(_map2.default); exports.default = Store; module.exports = exports["default"]; /***/ }), /* 120 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); var _node = __webpack_require__(239); var _node2 = _interopRequireDefault(_node); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var verboseDebug = (0, _node2.default)("babel:verbose"); var generalDebug = (0, _node2.default)("babel"); var seenDeprecatedMessages = []; var Logger = function () { function Logger(file, filename) { (0, _classCallCheck3.default)(this, Logger); this.filename = filename; this.file = file; } Logger.prototype._buildMessage = function _buildMessage(msg) { var parts = "[BABEL] " + this.filename; if (msg) parts += ": " + msg; return parts; }; Logger.prototype.warn = function warn(msg) { console.warn(this._buildMessage(msg)); }; Logger.prototype.error = function error(msg) { var Constructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error; throw new Constructor(this._buildMessage(msg)); }; Logger.prototype.deprecate = function deprecate(msg) { if (this.file.opts && this.file.opts.suppressDeprecationMessages) return; msg = this._buildMessage(msg); if (seenDeprecatedMessages.indexOf(msg) >= 0) return; seenDeprecatedMessages.push(msg); console.error(msg); }; Logger.prototype.verbose = function verbose(msg) { if (verboseDebug.enabled) verboseDebug(this._buildMessage(msg)); }; Logger.prototype.debug = function debug(msg) { if (generalDebug.enabled) generalDebug(this._buildMessage(msg)); }; Logger.prototype.deopt = function deopt(node, msg) { this.debug(msg); }; return Logger; }(); exports.default = Logger; module.exports = exports["default"]; /***/ }), /* 121 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.ImportDeclaration = exports.ModuleDeclaration = undefined; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); exports.ExportDeclaration = ExportDeclaration; exports.Scope = Scope; var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var ModuleDeclaration = exports.ModuleDeclaration = { enter: function enter(path, file) { var node = path.node; if (node.source) { node.source.value = file.resolveModuleSource(node.source.value); } } }; var ImportDeclaration = exports.ImportDeclaration = { exit: function exit(path, file) { var node = path.node; var specifiers = []; var imported = []; file.metadata.modules.imports.push({ source: node.source.value, imported: imported, specifiers: specifiers }); for (var _iterator = path.get("specifiers"), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var specifier = _ref; var local = specifier.node.local.name; if (specifier.isImportDefaultSpecifier()) { imported.push("default"); specifiers.push({ kind: "named", imported: "default", local: local }); } if (specifier.isImportSpecifier()) { var importedName = specifier.node.imported.name; imported.push(importedName); specifiers.push({ kind: "named", imported: importedName, local: local }); } if (specifier.isImportNamespaceSpecifier()) { imported.push("*"); specifiers.push({ kind: "namespace", local: local }); } } } }; function ExportDeclaration(path, file) { var node = path.node; var source = node.source ? node.source.value : null; var exports = file.metadata.modules.exports; var declar = path.get("declaration"); if (declar.isStatement()) { var bindings = declar.getBindingIdentifiers(); for (var name in bindings) { exports.exported.push(name); exports.specifiers.push({ kind: "local", local: name, exported: path.isExportDefaultDeclaration() ? "default" : name }); } } if (path.isExportNamedDeclaration() && node.specifiers) { for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var specifier = _ref2; var exported = specifier.exported.name; exports.exported.push(exported); if (t.isExportDefaultSpecifier(specifier)) { exports.specifiers.push({ kind: "external", local: exported, exported: exported, source: source }); } if (t.isExportNamespaceSpecifier(specifier)) { exports.specifiers.push({ kind: "external-namespace", exported: exported, source: source }); } var local = specifier.local; if (!local) continue; if (source) { exports.specifiers.push({ kind: "external", local: local.name, exported: exported, source: source }); } if (!source) { exports.specifiers.push({ kind: "local", local: local.name, exported: exported }); } } } if (path.isExportAllDeclaration()) { exports.specifiers.push({ kind: "external-all", source: source }); } } function Scope(path) { path.skip(); } /***/ }), /* 122 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.inspect = exports.inherits = undefined; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _util = __webpack_require__(117); Object.defineProperty(exports, "inherits", { enumerable: true, get: function get() { return _util.inherits; } }); Object.defineProperty(exports, "inspect", { enumerable: true, get: function get() { return _util.inspect; } }); exports.canCompile = canCompile; exports.list = list; exports.regexify = regexify; exports.arrayify = arrayify; exports.booleanify = booleanify; exports.shouldIgnore = shouldIgnore; var _escapeRegExp = __webpack_require__(577); var _escapeRegExp2 = _interopRequireDefault(_escapeRegExp); var _startsWith = __webpack_require__(595); var _startsWith2 = _interopRequireDefault(_startsWith); var _minimatch = __webpack_require__(601); var _minimatch2 = _interopRequireDefault(_minimatch); var _includes = __webpack_require__(111); var _includes2 = _interopRequireDefault(_includes); var _isRegExp = __webpack_require__(276); var _isRegExp2 = _interopRequireDefault(_isRegExp); var _path = __webpack_require__(19); var _path2 = _interopRequireDefault(_path); var _slash = __webpack_require__(284); var _slash2 = _interopRequireDefault(_slash); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function canCompile(filename, altExts) { var exts = altExts || canCompile.EXTENSIONS; var ext = _path2.default.extname(filename); return (0, _includes2.default)(exts, ext); } canCompile.EXTENSIONS = [".js", ".jsx", ".es6", ".es"]; function list(val) { if (!val) { return []; } else if (Array.isArray(val)) { return val; } else if (typeof val === "string") { return val.split(","); } else { return [val]; } } function regexify(val) { if (!val) { return new RegExp(/.^/); } if (Array.isArray(val)) { val = new RegExp(val.map(_escapeRegExp2.default).join("|"), "i"); } if (typeof val === "string") { val = (0, _slash2.default)(val); if ((0, _startsWith2.default)(val, "./") || (0, _startsWith2.default)(val, "*/")) val = val.slice(2); if ((0, _startsWith2.default)(val, "**/")) val = val.slice(3); var regex = _minimatch2.default.makeRe(val, { nocase: true }); return new RegExp(regex.source.slice(1, -1), "i"); } if ((0, _isRegExp2.default)(val)) { return val; } throw new TypeError("illegal type for regexify"); } function arrayify(val, mapFn) { if (!val) return []; if (typeof val === "boolean") return arrayify([val], mapFn); if (typeof val === "string") return arrayify(list(val), mapFn); if (Array.isArray(val)) { if (mapFn) val = val.map(mapFn); return val; } return [val]; } function booleanify(val) { if (val === "true" || val == 1) { return true; } if (val === "false" || val == 0 || !val) { return false; } return val; } function shouldIgnore(filename) { var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : []; var only = arguments[2]; filename = filename.replace(/\\/g, "/"); if (only) { for (var _iterator = only, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var pattern = _ref; if (_shouldIgnore(pattern, filename)) return false; } return true; } else if (ignore.length) { for (var _iterator2 = ignore, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var _pattern = _ref2; if (_shouldIgnore(_pattern, filename)) return true; } } return false; } function _shouldIgnore(pattern, filename) { if (typeof pattern === "function") { return pattern(filename); } else { return pattern.test(filename); } } /***/ }), /* 123 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.ArrayPattern = exports.ObjectPattern = exports.RestProperty = exports.SpreadProperty = exports.SpreadElement = undefined; exports.Identifier = Identifier; exports.RestElement = RestElement; exports.ObjectExpression = ObjectExpression; exports.ObjectMethod = ObjectMethod; exports.ObjectProperty = ObjectProperty; exports.ArrayExpression = ArrayExpression; exports.RegExpLiteral = RegExpLiteral; exports.BooleanLiteral = BooleanLiteral; exports.NullLiteral = NullLiteral; exports.NumericLiteral = NumericLiteral; exports.StringLiteral = StringLiteral; var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); var _jsesc = __webpack_require__(469); var _jsesc2 = _interopRequireDefault(_jsesc); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function Identifier(node) { if (node.variance) { if (node.variance === "plus") { this.token("+"); } else if (node.variance === "minus") { this.token("-"); } } this.word(node.name); } function RestElement(node) { this.token("..."); this.print(node.argument, node); } exports.SpreadElement = RestElement; exports.SpreadProperty = RestElement; exports.RestProperty = RestElement; function ObjectExpression(node) { var props = node.properties; this.token("{"); this.printInnerComments(node); if (props.length) { this.space(); this.printList(props, node, { indent: true, statement: true }); this.space(); } this.token("}"); } exports.ObjectPattern = ObjectExpression; function ObjectMethod(node) { this.printJoin(node.decorators, node); this._method(node); } function ObjectProperty(node) { this.printJoin(node.decorators, node); if (node.computed) { this.token("["); this.print(node.key, node); this.token("]"); } else { if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) { this.print(node.value, node); return; } this.print(node.key, node); if (node.shorthand && t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name) { return; } } this.token(":"); this.space(); this.print(node.value, node); } function ArrayExpression(node) { var elems = node.elements; var len = elems.length; this.token("["); this.printInnerComments(node); for (var i = 0; i < elems.length; i++) { var elem = elems[i]; if (elem) { if (i > 0) this.space(); this.print(elem, node); if (i < len - 1) this.token(","); } else { this.token(","); } } this.token("]"); } exports.ArrayPattern = ArrayExpression; function RegExpLiteral(node) { this.word("/" + node.pattern + "/" + node.flags); } function BooleanLiteral(node) { this.word(node.value ? "true" : "false"); } function NullLiteral() { this.word("null"); } function NumericLiteral(node) { var raw = this.getPossibleRaw(node); var value = node.value + ""; if (raw == null) { this.number(value); } else if (this.format.minified) { this.number(raw.length < value.length ? raw : value); } else { this.number(raw); } } function StringLiteral(node, parent) { var raw = this.getPossibleRaw(node); if (!this.format.minified && raw != null) { this.token(raw); return; } var opts = { quotes: t.isJSX(parent) ? "double" : this.format.quotes, wrap: true }; if (this.format.jsonCompatibleStrings) { opts.json = true; } var val = (0, _jsesc2.default)(node.value, opts); return this.token(val); } /***/ }), /* 124 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.default = function (path, file, helpers) { if (!helpers) { helpers = { wrapAsync: file }; file = null; } path.traverse(awaitVisitor, { file: file, wrapAwait: helpers.wrapAwait }); if (path.isClassMethod() || path.isObjectMethod()) { classOrObjectMethod(path, helpers.wrapAsync); } else { plainFunction(path, helpers.wrapAsync); } }; var _babelHelperFunctionName = __webpack_require__(40); var _babelHelperFunctionName2 = _interopRequireDefault(_babelHelperFunctionName); var _babelTemplate = __webpack_require__(4); var _babelTemplate2 = _interopRequireDefault(_babelTemplate); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); var _forAwait = __webpack_require__(320); var _forAwait2 = _interopRequireDefault(_forAwait); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var buildWrapper = (0, _babelTemplate2.default)("\n (() => {\n var REF = FUNCTION;\n return function NAME(PARAMS) {\n return REF.apply(this, arguments);\n };\n })\n"); var namedBuildWrapper = (0, _babelTemplate2.default)("\n (() => {\n var REF = FUNCTION;\n function NAME(PARAMS) {\n return REF.apply(this, arguments);\n }\n return NAME;\n })\n"); var awaitVisitor = { Function: function Function(path) { if (path.isArrowFunctionExpression() && !path.node.async) { path.arrowFunctionToShadowed(); return; } path.skip(); }, AwaitExpression: function AwaitExpression(_ref, _ref2) { var node = _ref.node; var wrapAwait = _ref2.wrapAwait; node.type = "YieldExpression"; if (wrapAwait) { node.argument = t.callExpression(wrapAwait, [node.argument]); } }, ForAwaitStatement: function ForAwaitStatement(path, _ref3) { var file = _ref3.file, wrapAwait = _ref3.wrapAwait; var node = path.node; var build = (0, _forAwait2.default)(path, { getAsyncIterator: file.addHelper("asyncIterator"), wrapAwait: wrapAwait }); var declar = build.declar, loop = build.loop; var block = loop.body; path.ensureBlock(); if (declar) { block.body.push(declar); } block.body = block.body.concat(node.body.body); t.inherits(loop, node); t.inherits(loop.body, node.body); if (build.replaceParent) { path.parentPath.replaceWithMultiple(build.node); path.remove(); } else { path.replaceWithMultiple(build.node); } } }; function classOrObjectMethod(path, callId) { var node = path.node; var body = node.body; node.async = false; var container = t.functionExpression(null, [], t.blockStatement(body.body), true); container.shadow = true; body.body = [t.returnStatement(t.callExpression(t.callExpression(callId, [container]), []))]; node.generator = false; } function plainFunction(path, callId) { var node = path.node; var isDeclaration = path.isFunctionDeclaration(); var asyncFnId = node.id; var wrapper = buildWrapper; if (path.isArrowFunctionExpression()) { path.arrowFunctionToShadowed(); } else if (!isDeclaration && asyncFnId) { wrapper = namedBuildWrapper; } node.async = false; node.generator = true; node.id = null; if (isDeclaration) { node.type = "FunctionExpression"; } var built = t.callExpression(callId, [node]); var container = wrapper({ NAME: asyncFnId, REF: path.scope.generateUidIdentifier("ref"), FUNCTION: built, PARAMS: node.params.reduce(function (acc, param) { acc.done = acc.done || t.isAssignmentPattern(param) || t.isRestElement(param); if (!acc.done) { acc.params.push(path.scope.generateUidIdentifier("x")); } return acc; }, { params: [], done: false }).params }).expression; if (isDeclaration) { var declar = t.variableDeclaration("let", [t.variableDeclarator(t.identifier(asyncFnId.name), t.callExpression(container, []))]); declar._blockHoist = true; path.replaceWith(declar); } else { var retFunction = container.body.body[1].argument; if (!asyncFnId) { (0, _babelHelperFunctionName2.default)({ node: retFunction, parent: path.parent, scope: path.scope }); } if (!retFunction || retFunction.id || node.params.length) { path.replaceWith(t.callExpression(container, [])); } else { path.replaceWith(built); } } } module.exports = exports["default"]; /***/ }), /* 125 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function () { return { manipulateOptions: function manipulateOptions(opts, parserOpts) { parserOpts.plugins.push("decorators"); } }; }; module.exports = exports["default"]; /***/ }), /* 126 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function () { return { manipulateOptions: function manipulateOptions(opts, parserOpts) { parserOpts.plugins.push("flow"); } }; }; module.exports = exports["default"]; /***/ }), /* 127 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function () { return { manipulateOptions: function manipulateOptions(opts, parserOpts) { parserOpts.plugins.push("jsx"); } }; }; module.exports = exports["default"]; /***/ }), /* 128 */ /***/ (function(module, exports) { "use strict"; exports.__esModule = true; exports.default = function () { return { manipulateOptions: function manipulateOptions(opts, parserOpts) { parserOpts.plugins.push("trailingFunctionCommas"); } }; }; module.exports = exports["default"]; /***/ }), /* 129 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.default = function () { return { inherits: __webpack_require__(67), visitor: { Function: function Function(path, state) { if (!path.node.async || path.node.generator) return; (0, _babelHelperRemapAsyncToGenerator2.default)(path, state.file, { wrapAsync: state.addHelper("asyncToGenerator") }); } } }; }; var _babelHelperRemapAsyncToGenerator = __webpack_require__(124); var _babelHelperRemapAsyncToGenerator2 = _interopRequireDefault(_babelHelperRemapAsyncToGenerator); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 130 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _create = __webpack_require__(9); var _create2 = _interopRequireDefault(_create); exports.default = function () { return { visitor: { ObjectExpression: function ObjectExpression(path) { var node = path.node; var plainProps = node.properties.filter(function (prop) { return !t.isSpreadProperty(prop) && !prop.computed; }); var alreadySeenData = (0, _create2.default)(null); var alreadySeenGetters = (0, _create2.default)(null); var alreadySeenSetters = (0, _create2.default)(null); for (var _iterator = plainProps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var prop = _ref; var name = getName(prop.key); var isDuplicate = false; switch (prop.kind) { case "get": if (alreadySeenData[name] || alreadySeenGetters[name]) { isDuplicate = true; } alreadySeenGetters[name] = true; break; case "set": if (alreadySeenData[name] || alreadySeenSetters[name]) { isDuplicate = true; } alreadySeenSetters[name] = true; break; default: if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) { isDuplicate = true; } alreadySeenData[name] = true; } if (isDuplicate) { prop.computed = true; prop.key = t.stringLiteral(name); } } } } }; }; var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function getName(key) { if (t.isIdentifier(key)) { return key.name; } return key.value.toString(); } module.exports = exports["default"]; /***/ }), /* 131 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _create = __webpack_require__(9); var _create2 = _interopRequireDefault(_create); exports.default = function (_ref) { var t = _ref.types; function isValidRequireCall(path) { if (!path.isCallExpression()) return false; if (!path.get("callee").isIdentifier({ name: "require" })) return false; if (path.scope.getBinding("require")) return false; var args = path.get("arguments"); if (args.length !== 1) return false; var arg = args[0]; if (!arg.isStringLiteral()) return false; return true; } var amdVisitor = { ReferencedIdentifier: function ReferencedIdentifier(_ref2) { var node = _ref2.node, scope = _ref2.scope; if (node.name === "exports" && !scope.getBinding("exports")) { this.hasExports = true; } if (node.name === "module" && !scope.getBinding("module")) { this.hasModule = true; } }, CallExpression: function CallExpression(path) { if (!isValidRequireCall(path)) return; this.bareSources.push(path.node.arguments[0]); path.remove(); }, VariableDeclarator: function VariableDeclarator(path) { var id = path.get("id"); if (!id.isIdentifier()) return; var init = path.get("init"); if (!isValidRequireCall(init)) return; var source = init.node.arguments[0]; this.sourceNames[source.value] = true; this.sources.push([id.node, source]); path.remove(); } }; return { inherits: __webpack_require__(77), pre: function pre() { this.sources = []; this.sourceNames = (0, _create2.default)(null); this.bareSources = []; this.hasExports = false; this.hasModule = false; }, visitor: { Program: { exit: function exit(path) { var _this = this; if (this.ran) return; this.ran = true; path.traverse(amdVisitor, this); var params = this.sources.map(function (source) { return source[0]; }); var sources = this.sources.map(function (source) { return source[1]; }); sources = sources.concat(this.bareSources.filter(function (str) { return !_this.sourceNames[str.value]; })); var moduleName = this.getModuleName(); if (moduleName) moduleName = t.stringLiteral(moduleName); if (this.hasExports) { sources.unshift(t.stringLiteral("exports")); params.unshift(t.identifier("exports")); } if (this.hasModule) { sources.unshift(t.stringLiteral("module")); params.unshift(t.identifier("module")); } var node = path.node; var factory = buildFactory({ PARAMS: params, BODY: node.body }); factory.expression.body.directives = node.directives; node.directives = []; node.body = [buildDefine({ MODULE_NAME: moduleName, SOURCES: sources, FACTORY: factory })]; } } } }; }; var _babelTemplate = __webpack_require__(4); var _babelTemplate2 = _interopRequireDefault(_babelTemplate); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var buildDefine = (0, _babelTemplate2.default)("\n define(MODULE_NAME, [SOURCES], FACTORY);\n"); var buildFactory = (0, _babelTemplate2.default)("\n (function (PARAMS) {\n BODY;\n })\n"); module.exports = exports["default"]; /***/ }), /* 132 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; exports.default = function (_ref) { var t = _ref.types; return { inherits: __webpack_require__(199), visitor: (0, _babelHelperBuilderBinaryAssignmentOperatorVisitor2.default)({ operator: "**", build: function build(left, right) { return t.callExpression(t.memberExpression(t.identifier("Math"), t.identifier("pow")), [left, right]); } }) }; }; var _babelHelperBuilderBinaryAssignmentOperatorVisitor = __webpack_require__(316); var _babelHelperBuilderBinaryAssignmentOperatorVisitor2 = _interopRequireDefault(_babelHelperBuilderBinaryAssignmentOperatorVisitor); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } module.exports = exports["default"]; /***/ }), /* 133 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; module.exports = { "default": __webpack_require__(406), __esModule: true }; /***/ }), /* 134 */ /***/ (function(module, exports, __webpack_require__) { "use strict"; exports.__esModule = true; var _keys = __webpack_require__(14); var _keys2 = _interopRequireDefault(_keys); var _create = __webpack_require__(9); var _create2 = _interopRequireDefault(_create); var _map = __webpack_require__(133); var _map2 = _interopRequireDefault(_map); var _classCallCheck2 = __webpack_require__(3); var _classCallCheck3 = _interopRequireDefault(_classCallCheck2); var _getIterator2 = __webpack_require__(2); var _getIterator3 = _interopRequireDefault(_getIterator2); var _includes = __webpack_require__(111); var _includes2 = _interopRequireDefault(_includes); var _repeat = __webpack_require__(278); var _repeat2 = _interopRequireDefault(_repeat); var _renamer = __webpack_require__(383); var _renamer2 = _interopRequireDefault(_renamer); var _index = __webpack_require__(7); var _index2 = _interopRequireDefault(_index); var _defaults = __webpack_require__(273); var _defaults2 = _interopRequireDefault(_defaults); var _babelMessages = __webpack_require__(20); var messages = _interopRequireWildcard(_babelMessages); var _binding2 = __webpack_require__(225); var _binding3 = _interopRequireDefault(_binding2); var _globals = __webpack_require__(463); var _globals2 = _interopRequireDefault(_globals); var _babelTypes = __webpack_require__(1); var t = _interopRequireWildcard(_babelTypes); var _cache = __webpack_require__(88); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {};if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } }newObj.default = obj;return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var _crawlCallsCount = 0; function getCache(path, parentScope, self) { var scopes = _cache.scope.get(path.node) || []; for (var _iterator = scopes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) { var _ref; if (_isArray) { if (_i >= _iterator.length) break; _ref = _iterator[_i++]; } else { _i = _iterator.next(); if (_i.done) break; _ref = _i.value; } var scope = _ref; if (scope.parent === parentScope && scope.path === path) return scope; } scopes.push(self); if (!_cache.scope.has(path.node)) { _cache.scope.set(path.node, scopes); } } function gatherNodeParts(node, parts) { if (t.isModuleDeclaration(node)) { if (node.source) { gatherNodeParts(node.source, parts); } else if (node.specifiers && node.specifiers.length) { for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) { var _ref2; if (_isArray2) { if (_i2 >= _iterator2.length) break; _ref2 = _iterator2[_i2++]; } else { _i2 = _iterator2.next(); if (_i2.done) break; _ref2 = _i2.value; } var specifier = _ref2; gatherNodeParts(specifier, parts); } } else if (node.declaration) { gatherNodeParts(node.declaration, parts); } } else if (t.isModuleSpecifier(node)) { gatherNodeParts(node.local, parts); } else if (t.isMemberExpression(node)) { gatherNodeParts(node.object, parts); gatherNodeParts(node.property, parts); } else if (t.isIdentifier(node)) { parts.push(node.name); } else if (t.isLiteral(node)) { parts.push(node.value); } else if (t.isCallExpression(node)) { gatherNodeParts(node.callee, parts); } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) { for (var _iterator3 = node.properties, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) { var _ref3; if (_isArray3) { if (_i3 >= _iterator3.length) break; _ref3 = _iterator3[_i3++]; } else { _i3 = _iterator3.next(); if (_i3.done) break; _ref3 = _i3.value; } var prop = _ref3; gatherNodeParts(prop.key || prop.argument, parts); } } } var collectorVisitor = { For: function For(path) { for (var _iterator4 = t.FOR_INIT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) { var _ref4; if (_isArray4) { if (_i4 >= _iterator4.length) break; _ref4 = _iterator4[_i4++]; } else { _i4 = _iterator4.next(); if (_i4.done) break; _ref4 = _i4.value; } var key = _ref4; var declar = path.get(key); if (declar.isVar()) path.scope.getFunctionParent().registerBinding("var", declar); } }, Declaration: function Declaration(path) { if (path.isBlockScoped()) return; if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) return; path.scope.getFunctionParent().registerDeclaration(path); }, ReferencedIdentifier: function ReferencedIdentifier(path, state) { state.references.push(path); }, ForXStatement: function ForXStatement(path, state) { var left = path.get("left"); if (left.isPattern() || left.isIdentifier()) { state.constantViolations.push(left); } }, ExportDeclaration: { exit: function exit(path) { var node = path.node, scope = path.scope; var declar = node.declaration; if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) { var _id = declar.id; if (!_id) return; var binding = scope.getBinding(_id.name); if (binding) binding.reference(path); } else if (t.isVariableDeclaration(declar)) { for (var _iterator5 = declar.declarations, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) { var _ref5; if (_isArray5) { if (_i5 >= _iterator5.length) break; _ref5 = _iterator5[_i5++]; } else { _i5 = _iterator5.next(); if (_i5.done) break; _ref5 = _i5.value; } var decl = _ref5; var ids = t.getBindingIdentifiers(decl); for (var name in ids) { var _binding = scope.getBinding(name); if (_binding) _binding.reference(path); } } } } }, LabeledStatement: function LabeledStatement(path) { path.scope.getProgramParent().addGlobal(path.node); path.scope.getBlockParent().registerDeclaration(path); }, AssignmentExpression: function AssignmentExpression(path, state) { state.assignments.push(path); }, UpdateExpression: function UpdateExpression(path, state) { state.constantViolations.push(path.get("argument")); }, UnaryExpression: function UnaryExpression(path, state) { if (path.node.operator === "delete") { state.constantViolations.push(path.get("argument")); } }, BlockScoped: function BlockScoped(path) { var scope = path.scope; if (scope.path === path) scope = scope.parent; scope.getBlockParent().registerDeclaration(path); }, ClassDeclaration: function ClassDeclaration(path) { var id = path.node.id; if (!id) return; var name = id.name; path.scope.bindings[name] = path.scope.getBinding(name); }, Block: function Block(path) { var paths = path.get("body"); for (var _iterator6 = paths, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) { var _ref6; if (_isArray6) { if (_i6 >= _iterator6.length) break; _ref6 = _iterator6[_i6++]; } else { _i6 = _iterator6.next(); if (_i6.done) break; _ref6 = _i6.value; } var bodyPath = _ref6; if (bodyPath.isFunctionDeclaration()) { path.scope.getBlockParent().registerDeclaration(bodyPath); } } } }; var uid = 0; var Scope = function () { function Scope(path, parentScope) { (0, _classCallCheck3.default)(this, Scope); if (parentScope && parentScope.block === path.node) { return parentScope; } var cached = getCache(path, parentScope, this); if (cached) return cached; this.uid = uid++; this.parent = parentScope; this.hub = path.hub; this.parentBlock = path.parent; this.block = path.node; this.path = path; this.labels = new _map2.default(); } Scope.prototype.traverse = function traverse(node, opts, state) { (0, _index2.default)(node, opts, this, state, this.path); }; Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() { var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp"; var id = this.generateUidIdentifier(name); this.push({ id: id }); return id; }; Scope.prototype.generateUidIdentifier = function generateUidIdentifier() { var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp"; return t.identifier(this.generateUid(name)); }; Scope.prototype.generateUid = function generateUid() { var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp"; name = t.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, ""); var uid = void 0; var i = 0; do { uid = this._generateUid(name, i); i++; } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid)); var program = this.getProgramParent(); program.references[uid] = true; program.uids[uid] = true; return uid; }; Scope.prototype._generateUid = function _generateUid(name, i) { var id = name; if (i > 1) id += i; return "_" + id; }; Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) { var node = parent; if (t.isAssignmentExpression(parent)) { node = parent.left; } else if (t.isVariableDeclarator(parent)) { node = parent.id; } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) { node = node.key; } var parts = []; gatherNodeParts(node, parts); var id = parts.join("$"); id = id.replace(/^_/, "") || defaultName || "ref"; return this.generateUidIdentifier(id.slice(0, 20)); }; Scope.prototype.isStatic = function isStatic(node) { if (t.isThisExpression(node) || t.isSuper(node)) { return true; } if (t.isIdentifier(node)) { var binding = this.getBinding(node.name); if (binding) { return binding.constant; } else { return this.hasBinding(node.name); } } return false; }; Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) { if (this.isStatic(node)) { return null; } else { var _id2 = this.generateUidIdentifierBasedOnNode(node); if (!dontPush) this.push({ id: _id2 }); return _id2; } }; Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) { if (kind === "param") return; if (kind === "hoisted" && local.kind === "let") return; var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const"); if (duplicate) { throw this.hub.file.buildCodeFrameError(id, messages.get("scopeDuplicateDeclaration", name), TypeError); } }; Scope.prototype.rename = function rename(oldName, newName, block) { var binding = this.getBinding(oldName); if (binding) { newName = newName || this.generateUidIdentifier(oldName).name; return new _renamer2.default(binding, oldName, newName).rename(block); } }; Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) { if (map[oldName]) { map[newName] = value; map[oldName] = null; } }; Scope.prototype.dump = function dump() { var sep = (0, _repeat2.default)("-", 60); console.log(sep); var scope = this; do { console.log("#", scope.block.type); for (var name in scope.bindings) { var binding = scope.bindings[name]; console.log(" -", name, { constant: binding.constant, references: binding.references, violations: binding.constantViolations.length, kind: binding.kind }); } } while (scope = scope.parent); console.log(sep); }; Scope.prototype.toArray = function toArray(node, i) { var file = this.hub.file; if (t.isIdentifier(node)) { var binding = this.getBinding(node.name); if (binding && binding.constant && binding.path.isGenericType("Array")) return node; } if (t.isArrayExpression(node)) { return node; } if (t.isIdentifier(node, { name: "arguments" })) { return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier("Array"), t.identifier("prototype")), t.identifier("slice")), t.identifier("call")), [node]); } var helperName = "toArray"; var args = [node]; if (i === true) { helperName = "toConsumableArray"; } else if (i) { args.push(t.numericLiteral(i)); helperName = "slicedToArray"; } return t.callExpression(file.addHelper(helperName), args); }; Scope.prototype.hasLabel = function hasLabel(name) { return !!this.getLabel(name); }; Scope.prototype.getLabel = function getLabel(name) { return this.labels.get(name); }; Scope.prototype.registerLabel = function registerLabel(path) { this.labels.set(path.node.label.name, path); }; Scope.prototype.registerDeclaration = function registerDeclaration(path) { if (path.isLabeledStatement()) { this.registerLabel(path); } else if (path.isFunctionDeclaration()) { this.registerBinding("hoisted", path.get("id"), path); } else if (path.isVariableDeclaration()) { var declarations = path.get("declarations"); for (var _iterator7 = declarations, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _ge